<?xml version="1.0" encoding="UTF-8"?>
<files>
	<file path='.github\workflows\codecov.yml'>
		name: Code Coverage
		on: [push, pull_request]
		jobs:
		  run:
		    runs-on: ubuntu-latest
		    steps:
		      - name: Checkout
		        uses: actions/checkout@v4
		      - name: Set up JDK 18
		        uses: actions/setup-java@v1
		        with:
		          java-version: 18
		      - name: Install dependencies
		        run: mvn package -DskipTests=true -Dmaven.javadoc.skip=true -B -V
		      - name: Run tests and collect coverage
		        run: mvn -B test jacoco:report
		      - name: Upload coverage to Codecov
		        uses: codecov/codecov-action@v4
		        env:
		          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
		      - name: Upload test custom
		        env:
		          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
		          GIST_ID: ${{ secrets.GIST_ID }}
		        run: bash uploadnumber.sh
		      - name: Upload test numbers
		        uses: gaelgirodon/ci-badges-action@v1
		        with:
		          gist-id: ${{ secrets.GIST_ID }}
		          token: ${{ secrets.GIST_TOKEN }}</file>
	<file path='.github\workflows\maven.yml'>
		# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
		# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven
		
		# This workflow uses actions that are not certified by GitHub.
		# They are provided by a third-party and are governed by
		# separate terms of service, privacy policy, and support
		# documentation.
		
		name: Java CI with Maven
		
		on:
		  push:
		    branches: [ "main" ]
		  pull_request:
		    branches: [ "main" ]
		
		jobs:
		  build:
		
		    runs-on: ubuntu-latest
		
		    steps:
		    - uses: actions/checkout@v4
		    - name: Set up JDK 18
		      uses: actions/setup-java@v4
		      with:
		        java-version: '18'
		        distribution: 'temurin'
		        cache: maven
		    - name: Build with Maven
		      run: mvn -B package --file pom.xml
		
		    # Optional: Uploads the full dependency graph to GitHub to improve the quality of Dependabot alerts this repository can receive
		   # - name: Update dependency graph
		   #   uses: advanced-security/maven-dependency-submission-action@571e99aab1055c2e71a1e2309b9691de18d6b7d6</file>
	<file path='.gitignore'>
		target/
		!.mvn/wrapper/maven-wrapper.jar
		!**/src/main/**/target/
		!**/src/test/**/target/
		
		### IntelliJ IDEA ###
		.idea/modules.xml
		.idea/jarRepositories.xml
		.idea/compiler.xml
		.idea/libraries/
		*.iws
		*.iml
		*.ipr
		
		### Eclipse ###
		.apt_generated
		.classpath
		.factorypath
		.project
		.settings
		.springBeans
		.sts4-cache
		
		### NetBeans ###
		/nbproject/private/
		/nbbuild/
		/dist/
		/nbdist/
		/.nb-gradle/
		build/
		!**/src/main/**/build/
		!**/src/test/**/build/
		
		### VS Code ###
		.vscode/
		
		### Mac OS ###
		.DS_Store</file>
	<file path='LICENSE'>
		MIT License
		
		Copyright (c) 2024 vishal mysore
		
		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.
		
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.</file>
	<file path='pom.xml'><![CDATA[
		<?xml version="1.0" encoding="UTF-8"?>
		<project xmlns="http://maven.apache.org/POM/4.0.0"
		         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		    <modelVersion>4.0.0</modelVersion>
		
		    <groupId>io.github.vishalmysore</groupId>
		    <artifactId>a2ajava</artifactId>
		    <version>0.1.9.6</version>
		    <name>A2A Protocol Implementation for Java</name>
		    <description>
		        Java implementation of the A2A protocol, which allows for the exchange of data between different AI systems.
		        This project is designed to facilitate the integration of various AI models and tools, enabling seamless communication and collaboration.
		        The A2A protocol is a standardized way for AI systems to share information, making it easier to build complex applications that leverage multiple AI technologies.
		        This implementation is built using Java and Spring Boot, providing a robust and scalable solution for developers looking to integrate AI capabilities into their applications.
		        The project includes support for WebSocket communication, allowing for real-time data exchange between systems.
		        The project also supports MCP Model Context Protocol, enabling the use of multiple AI models in a single application.
		    </description>
		    <url>https://github.com/vishalmysore/a2ajava</url>
		    <licenses>
		        <license>
		            <name>MIT License</name>
		            <url>https://opensource.org/license/mit</url>
		        </license>
		    </licenses>
		    <developers>
		        <developer>
		            <name>Vishal Mysore</name>
		            <email>visrow@gmail.com</email>
		            <organization>Vishal Mysore</organization>
		            <organizationUrl>Vishal Mysore</organizationUrl>
		        </developer>
		    </developers>
		    <scm>
		        <connection>scm:git:git://github.com/vishalmysore/a2ajava.git</connection>
		        <developerConnection>scm:git:ssh://github.com:vishalmysore/a2ajava.git</developerConnection>
		        <url>http://github.com/vishalmysore/a2ajava/tree/master</url>
		    </scm>
		
		    <properties>
		        <maven.compiler.source>18</maven.compiler.source>
		        <maven.compiler.target>18</maven.compiler.target>
		        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		        <langchain4j.version>0.29.1</langchain4j.version>
		        <slf4j.version>2.0.16</slf4j.version>
		    </properties>
		
		    <dependencies>
		        <!-- https://mvnrepository.com/artifact/io.ultreia/bluecove -->
		
		
		
		        <dependency>
		            <groupId>org.junit.jupiter</groupId>
		            <artifactId>junit-jupiter-api</artifactId>
		            <version>5.10.2</version>
		            <scope>test</scope>
		        </dependency>
		        <dependency>
		            <groupId>org.junit.jupiter</groupId>
		            <artifactId>junit-jupiter-engine</artifactId>
		            <version>5.10.2</version>
		            <scope>test</scope>
		        </dependency>
		        <dependency>
		            <groupId>org.mockito</groupId>
		            <artifactId>mockito-core</artifactId>
		            <version>5.11.0</version>
		            <scope>test</scope>
		        </dependency>
		        <dependency>
		            <groupId>org.mockito</groupId>
		            <artifactId>mockito-junit-jupiter</artifactId>
		            <version>5.11.0</version>
		            <scope>test</scope>
		        </dependency>
		
		
		        <!-- https://mvnrepository.com/artifact/io.github.vishalmysore/tools4ai -->
		        <dependency>
		            <groupId>io.github.vishalmysore</groupId>
		            <artifactId>tools4ai</artifactId>
		            <version>1.1.6.2</version>
		        </dependency>
		
		        <dependency>
		            <groupId>org.java-websocket</groupId>
		            <artifactId>Java-WebSocket</artifactId>
		            <version>1.6.0</version>
		        </dependency>
		
		
		        <!-- Optional: If you need to use SockJS -->
		
		
		
		        <!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt -->
		        <dependency>
		            <groupId>io.jsonwebtoken</groupId>
		            <artifactId>jjwt</artifactId>
		            <version>0.12.6</version>
		        </dependency>
		
		
		        <dependency>
		            <groupId>com.fasterxml.jackson.module</groupId>
		            <artifactId>jackson-module-jsonSchema</artifactId>
		            <version>2.13.0</version>
		        </dependency>
		
		
		        <dependency>
		            <groupId>com.fasterxml.jackson.core</groupId>
		            <artifactId>jackson-core</artifactId>
		            <version>2.16.2</version>
		        </dependency>
		        <dependency>
		            <groupId>com.fasterxml.jackson.core</groupId>
		            <artifactId>jackson-databind</artifactId>
		            <version>2.16.2</version>
		        </dependency>
		        <dependency>
		            <groupId>com.fasterxml.jackson.core</groupId>
		            <artifactId>jackson-annotations</artifactId>
		            <version>2.16.2</version>
		        </dependency>
		
		
		        <dependency>
		            <groupId>org.springdoc</groupId>
		            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
		            <version>2.3.0</version>
		        </dependency>
		
		        <!-- https://mvnrepository.com/artifact/dev.langchain4j/langchain4j -->
		        <dependency>
		            <groupId>dev.langchain4j</groupId>
		            <artifactId>langchain4j-open-ai</artifactId>
		            <version>1.0.0-alpha1</version>
		        </dependency>
		        <dependency>
		            <groupId>com.microsoft.playwright</groupId>
		            <artifactId>playwright</artifactId>
		            <version>1.18.0</version>  <!-- Use the latest version -->
		        </dependency>
		
		        <dependency>
		            <groupId>dev.langchain4j</groupId>
		            <artifactId>langchain4j</artifactId>
		            <version>1.0.0-alpha1</version>
		        </dependency>
		
		        <dependency>
		            <groupId>dev.langchain4j</groupId>
		            <artifactId>langchain4j-embeddings-all-minilm-l6-v2</artifactId>
		            <version>1.0.0-alpha1</version>
		        </dependency>
		
		
		
		
		        <dependency>
		            <groupId>org.jsoup</groupId>
		            <artifactId>jsoup</artifactId>
		            <version>1.14.3</version>
		        </dependency>
		
		        <!-- AWS SDK for DynamoDB -->
		        <!-- https://mvnrepository.com/artifact/software.amazon.awssdk/dynamodb -->
		        <dependency>
		            <groupId>software.amazon.awssdk</groupId>
		            <artifactId>dynamodb</artifactId>
		            <version>2.20.55</version> <!-- Use the latest version -->
		        </dependency>
		        <!-- AWS SDK v2 for authentication -->
		        <dependency>
		            <groupId>software.amazon.awssdk</groupId>
		            <artifactId>auth</artifactId>
		            <version>2.20.55</version>
		        </dependency>
		
		        <!-- https://mvnrepository.com/artifact/jakarta.annotation/jakarta.annotation-api -->
		        <dependency>
		            <groupId>jakarta.annotation</groupId>
		            <artifactId>jakarta.annotation-api</artifactId>
		            <version>3.0.0</version>
		        </dependency>
		
		        <dependency>
		            <groupId>org.projectlombok</groupId>
		            <artifactId>lombok</artifactId>
		            <version>1.18.30</version>
		            <scope>provided</scope>
		        </dependency>
		        <!-- Spring Security dependency for Maven -->
		
		        <dependency>
		            <groupId>jakarta.servlet</groupId>
		            <artifactId>jakarta.servlet-api</artifactId>
		            <version>5.0.0</version> <!-- Replace with the latest version -->
		            <scope>provided</scope>
		        </dependency>
		
		    </dependencies>
		
		    <dependencyManagement>
		        <dependencies>
		            <!-- Fix CVE-2018-8088: Force safe SLF4J versions -->
		            <dependency>
		                <groupId>org.slf4j</groupId>
		                <artifactId>slf4j-api</artifactId>
		                <version>${slf4j.version}</version>
		            </dependency>
		            <dependency>
		                <groupId>org.slf4j</groupId>
		                <artifactId>slf4j-ext</artifactId>
		                <version>${slf4j.version}</version>
		            </dependency>
		            <dependency>
		                <groupId>org.slf4j</groupId>
		                <artifactId>slf4j-simple</artifactId>
		                <version>${slf4j.version}</version>
		            </dependency>
		            <dependency>
		                <groupId>org.slf4j</groupId>
		                <artifactId>jcl-over-slf4j</artifactId>
		                <version>${slf4j.version}</version>
		            </dependency>
		            <dependency>
		                <groupId>org.slf4j</groupId>
		                <artifactId>jul-to-slf4j</artifactId>
		                <version>${slf4j.version}</version>
		            </dependency>
		            <dependency>
		                <groupId>org.slf4j</groupId>
		                <artifactId>log4j-over-slf4j</artifactId>
		                <version>${slf4j.version}</version>
		            </dependency>
		        </dependencies>
		    </dependencyManagement>
		
		    <build>
		        <testResources>
		            <testResource>
		                <directory>src/test/resources</directory>
		            </testResource>
		        </testResources>
		        <plugins>
		
		
		            <plugin>
		                <groupId>org.apache.maven.plugins</groupId>
		                <artifactId>maven-compiler-plugin</artifactId>
		                <version>3.1</version>
		                <configuration>
		                    <source>18</source>
		                    <target>18</target>
		                    <compilerArgs>
		                        <arg>-parameters</arg>
		                    </compilerArgs>
		                </configuration>
		
		            </plugin>
		
		
		            <plugin>
		                <groupId>org.sonatype.central</groupId>
		                <artifactId>central-publishing-maven-plugin</artifactId>
		                <version>0.4.0</version>
		                <extensions>true</extensions>
		                <configuration>
		                    <publishingServerId>central</publishingServerId>
		                    <tokenAuth>true</tokenAuth>
		                </configuration>
		            </plugin>
		            <plugin>
		                <groupId>org.jacoco</groupId>
		                <artifactId>jacoco-maven-plugin</artifactId>
		                <version>0.8.12</version> <!-- Define the version, preferably using a property -->
		                <executions>
		                    <execution>
		                        <id>prepare-agent</id>
		                        <goals>
		                            <goal>prepare-agent</goal>
		                        </goals>
		                    </execution>
		                    <execution>
		                        <id>report</id>
		                        <phase>prepare-package</phase> <!-- Generate report during the 'prepare-package' phase -->
		                        <goals>
		                            <goal>report</goal>
		                        </goals>
		                    </execution>
		                </executions>
		            </plugin>
		            <plugin>
		                <groupId>org.apache.maven.plugins</groupId>
		                <artifactId>maven-gpg-plugin</artifactId>
		                <executions>
		                    <execution>
		                        <id>sign-artifacts</id>
		                        <phase>verify</phase>
		                        <goals>
		                            <goal>sign</goal>
		                        </goals>
		                        <configuration>
		                            <keyname>${mykey}</keyname>
		                            <passphraseServerId>myid</passphraseServerId>
		                        </configuration>
		                    </execution>
		                </executions>
		            </plugin>
		            <plugin>
		                <groupId>org.apache.maven.plugins</groupId>
		                <artifactId>maven-source-plugin</artifactId>
		                <version>2.2.1</version>
		                <executions>
		                    <execution>
		                        <id>attach-sources</id>
		                        <goals>
		                            <goal>jar-no-fork</goal>
		                        </goals>
		                    </execution>
		                </executions>
		            </plugin>
		            <plugin>
		                <groupId>org.apache.maven.plugins</groupId>
		                <artifactId>maven-javadoc-plugin</artifactId>
		                <version>2.9.1</version>
		                <executions>
		                    <execution>
		                        <id>attach-javadocs</id>
		                        <goals>
		                            <goal>jar</goal>
		                        </goals>
		                    </execution>
		                </executions>
		            </plugin>
		        </plugins>
		    </build>
		
		</project>]]></file>
	<file path='README.MD'><![CDATA[
		# Java Implementation of Google's A2A Protocol: Connecting the Agentverse
		
		This project provides a Java implementation for both an A2A (Agent-to-Agent) server and client. 
		**A2A is an open protocol developed by Google** to standardize how AI agents communicate and exchange information, fostering a vibrant ecosystem of interoperable AI. This api also supports building MCP Servers in Java with use of simple annotations. Imagine a world where diverse AI agents, built with different tools and by different creators, can seamlessly collaborate to solve complex problems - that's the vision A2A is bringing to life. This implementation demonstrates how to set up this communication in Java, using the Spring Framework, with a focus on sending and retrieving tasks.
		a2ajava is a Swiss Army knife for building agentic applications. It is multi-protocol — works seamlessly with both A2A (Agent-to-Agent) and MCP (Model Context Protocol). It is multi-language — supports Java, Kotlin, and Groovy. It is multi-platform — compatible with Gemini, OpenAI, Claude, and Grok. It is multi-client — includes A2A and MCP clients with connectors in Java, Node, and Python. It offers multi-integration — out-of-the-box support for Selenium, human-in-the-loop workflows, and multi-LLM voting for consensus-based decision making. Agents built using the A2A protocol with a2ajava run seamlessly on MCP as well, ensuring maximum interoperability across platforms.
		
		[![Need More Info? Ask DeepWiki](https://deepwiki.com/badge.svg)](https://deepwiki.com/vishalmysore/a2ajava) [![codecov](https://codecov.io/gh/vishalmysore/a2ajava/graph/badge.svg?token=HieisRv0xC)](https://codecov.io/gh/vishalmysore/a2ajava)
		<a target="_blank" href="https://sonarcloud.io/summary/new_code?id=vishalmysore_a2ajava"><img src="https://sonarcloud.io/api/project_badges/measure?project=vishalmysore_a2ajava&metric=alert_status"/></a>
		<a target="_blank" href="https://sonarcloud.io/summary/new_code?id=vishalmysore_a2ajava"><img src="https://sonarcloud.io/api/project_badges/measure?project=vishalmysore_a2ajava&metric=bugs"/></a>
		<a target="_blank" href="https://sonarcloud.io/summary/new_code?id=vishalmysore_a2ajava"><img src="https://sonarcloud.io/api/project_badges/measure?project=vishalmysore_a2ajava&metric=vulnerabilities"/></a>
		<a target="_blank" href="https://sonarcloud.io/summary/new_code?id=vishalmysore_a2ajava"><img src="https://sonarcloud.io/api/project_badges/measure?project=vishalmysore_a2ajava&metric=sqale_rating"/></a>
		<a target="_blank" href="https://sonarcloud.io/summary/new_code?id=vishalmysore_a2ajava"><img src="https://sonarcloud.io/api/project_badges/measure?project=vishalmysore_a2ajava&metric=security_rating"/></a>
		<a target="_blank" href="https://sonarcloud.io/summary/new_code?id=vishalmysore_a2ajava"><img src="https://sonarcloud.io/api/project_badges/measure?project=vishalmysore_a2ajava&metric=reliability_rating"/></a>
		<a target="_blank" href="https://github.com/vishalmysore/a2ajava/actions/workflows/maven.yml"><img src="https://github.com/vishalmysore/a2ajava/actions/workflows/maven.yml/badge.svg"/></a>
		<a target="_blank" href="https://github.com/vishalmysore/a2ajava/actions/workflows/codecov.yml"> <img src="https://github.com/vishalmysore/a2ajava/actions/workflows/codecov.yml/badge.svg"/></a>
		<img alt="Test Number" src="https://img.shields.io/endpoint?url=https://gist.githubusercontent.com/vishalmysore/6c825c69028a4f8fac9d7c1707628733/raw/test.json"/>
		[![MIT License](https://img.shields.io/badge/License-MIT-green.svg)](https://choosealicense.com/licenses/mit/)
		[![Java Version](https://img.shields.io/badge/Java-23-orange.svg)](https://www.oracle.com/java/technologies/javase/jdk23-archive-downloads.html)
		[![Spring Boot](https://img.shields.io/badge/Spring%20Boot-3.2.4-brightgreen.svg)](https://spring.io/projects/spring-boot)
		
		## Quick Start  
		
		Use these example to quickly build agents using this library , forking and cloning these examples is the best way to get started with a2ajava. 
		
		* [Spring A2A Agent](https://github.com/vishalmysore/SpringActions) - Use a2ajava to build a spring agent using A2A and MCP, can work with a2a client or with mcp client like claude desktop or connect to visual studio code as agent. This should be the first project to learn if you are new to agentic ai.
		* [Connect MCP Agent in Java](https://github.com/vishalmysore/mcp-connector/) - MCP Connector for Java Based agents , connect your a2a server to MCP client like claude or connect your MCP server to a2a client. Or vice versa or any permutation and combination
		* [Database Agent](https://github.com/vishalmysore/SqlAIAgent) - Use a2ajava to build a database agent using Derby DB, start stop database , insert data , create table all with agentic operation for both mcp as well as a2a      
		* [Standalone Java](https://github.com/vishalmysore/a2a-examples) - Several Examples on how to Use a2ajava to build a standalone java agent using A2A and MCP work with any client     
		* [Log Monitoring Agent](https://github.com/vishalmysore/agenticlog) - Use a2ajava to build a log monitoring agent which triggers a2a task based on the log messages. Works with both a2a and mcp clients dual protocol 
		* [A2A Kafka Agent](https://github.com/vishalmysore/a2akafkaagent) - Use a2ajava to build a kafka agent which can trigger a2a task or mcp tool based on the kafka messages.
		* [A2A Selenium Web Agent](https://github.com/vishalmysore/a2awebagent) - Use a2ajava to build a selenium agent which can trigger a2a task or mcp tool for web browsing , validation of web pages.
		* [A2A Grafana Agent](https://github.com/vishalmysore/a2a-grafana) - Build observable Agents using A2A or MCP and Grafana
		* [A2A MongoDB RAG Agent](https://github.com/vishalmysore/a2a-mongo-rag-search) – Perform semantic search and reasoning across agent tasks using RAG with MongoDB Agent. 
		* [Simple Agent in Kotlin](https://github.com/vishalmysore/a2a-kotlin) - Use A2AJava to build a simple agent in Kotlin.
		* [Build Agent in MCP](tutorial/mcp/11_MCP.md) - Use A2AJava to build a simple agent in MCP. 
		* [MCP Agent in Kotlin](https://github.com/vishalmysore/mcp-kotlin) - Build MCP Agent in Kotlin and connect to Claude or A2A Clients  
		* [MCP and A2A RAG Server](https://github.com/vishalmysore/mcp-rag-server) - State of the art RAG server using A2A and MCP with MongoDB Atlas works with both MCP as well as A2A clients
		* [A2A and MCP Agent with Security](https://github.com/vishalmysore/a2a-mcp-with-security) - Build A2A and MCP agent with security using Spring Security and JWT. 
		* [A2A and MCP in Groovy](https://github.com/vishalmysore/a2aGroovy) - Build A2A and MCP agent in Groovy using A2AJava library.
		* [A2A and MCP in Scala](https://github.com/vishalmysore/a2aScala) - Build A2A and MCP agent in Scala using A2AJava library.
		* [A2A and MCP with Playwright](https://github.com/vishalmysore/a2aPlaywright) - Build A2A and MCP agent with Playwright for web automation using A2AJava library.
		* [MCP and A2A with Apache Thrift](https://github.com/vishalmysore/mcp-apache-thrift) - Build A2A and MCP agent with Apache Thrift for cross-language communication using A2AJava library. This example demonstrates how to use Thrift to call a service implemented in another language (e.g., Python, Go, C++) from a Java-based A2A or MCP agent.
		* [Single MCP Server and Client](https://github.com/vishalmysore/mcp-server-client)- Build a MCP server and client using A2AJava library. This example demonstrates how to build a MCP server and client using A2AJava library. It also demonstrates how to use the MCP protocol to call tools and tasks from the server.
		* [MCP Multi Server and Client](https://github.com/vishalmysore/mcp-a2a-multi-agent) - Build a MCP server and client with multiple servers using A2AJava library. This example demonstrates how to build a MCP server and client with multiple servers using A2AJava library. It also demonstrates how to use the MCP protocol to call tools and tasks from the server.
		* [Agentic Mesh - 4 Servers](https://github.com/vishalmysore/mcp-agentic-mesh)- Build a Agentic Mesh using A2AJava library. This example demonstrates how to build a Agentic Mesh using A2AJava library. It also demonstrates how to use the A2A protocol to call tools and tasks from the server.* 
		
		### Coming Soon
		* **A2A Sensor Agent** – Use A2A to stream data from physical sensors and trigger real-time actions. ( [Please look at ChotuRobo Series](https://www.linkedin.com/posts/vishalrow_github-modelcontextprotocolservers-model-activity-7318222463857766400-YuFV/))
		* **A2A Home Automation Agent** – Use A2A to control smart home devices via MQTT or Home Assistant integrations. ( [Please look at ChotuRobo Series](https://www.linkedin.com/posts/vishalrow_and-here-is-a-demo-of-%F0%9D%90%82%F0%9D%90%A1%F0%9D%90%A8%F0%9D%90%AD%F0%9D%90%AE%F0%9D%90%91%F0%9D%90%A8%F0%9D%90%9B%F0%9D%90%A8-activity-7319065900031098880-SV4p/))
		* **A2A MyScale Agent** – Use A2A to run scalable, SQL-based vector searches on tasks and documents with MyScale.
		
		## Tutorials
		* [FAQ](tutorial/0_FAQ.md)
		* [Introduction](tutorial/1_introduction.md)
		* [Annotations Deep Dive](tutorial/2_AnnotationsDeepDive.md)
		* [Enterprise Integration](tutorial/3_EnterpriseIntegration.md)
		* [Image Processing](tutorial/4_ImageProcessing.md)
		* [Selenium Integration with A2A and MCP](tutorial/5_UISeleniumI.md)
		* [Advanced Features with Spring](tutorial/6_SpringAndSelenium.md)
		* [Handling Risk in A2A and MCP](tutorial/7_HandlingRisksinAgents.md)
		* [Human In Loop](tutorial/8_HumanInLoop.md)
		* [Kubernetes Example](tutorial/9_Kubernetes.md)
		* [Multi Agents](tutorial/10_ComplexAgents.md)
		
		## Live Demo 
		Live demos have been deployed on hugginface you are welcome to try them out. Or clone the space and create your own space
		
		* [A2A MCP RAG Application with Tool calling](https://vishalmysore-a2amcpmongo.hf.space/) - A2A Java Agent with Spring Boot and MongoDB Atlas for semantic search and reasoning. This application demonstrates how to use A2A and MCP protocols to build a RAG application with tool calling capabilities. It uses MongoDB Atlas for vector search and reasoning across agent tasks.
		* [A2A and MCP RBAC Security](https://vishalmysore-a2amcpdemo.hf.space/) - A2A and MCP demo with RBAC security. This application demonstrates how to use A2A and MCP protocols to build a secure application with role-based access control. It uses Spring Security and JWT for authentication and authorization.
		* [A2A and MCP with Selenium](https://vishalmysore-a2amcpselenium.hf.space/) - A2A and MCP demo with Selenium integration. This application demonstrates how to use A2A and MCP protocols to build a web automation application with Selenium. It uses Spring Boot and Selenium for web automation and A2A and MCP protocols for communication.
		* [A2A and MCP with Playwright](https://vishalmysore-a2apw.hf.space/) - A2A and MCP demo with Playwright integration. This application demonstrates how to use A2A and MCP protocols to build a web automation application with Playwright. It uses Spring Boot and Playwright for web automation and A2A and MCP protocols for communication.
		* [A2A and MCP with Spring](https://huggingface.co/spaces/VishalMysore/a2amcpspring) - A2A and MCP demo with Spring integration. This application demonstrates how to use A2A and MCP protocols to build a web application with Spring Boot. It uses Spring Boot and A2A and MCP protocols for communication.
		* [A2A and MCP with Database](https://huggingface.co/spaces/VishalMysore/a2amcpdatabase) - A2A and MCP demo with Database integration. This application demonstrates how to use A2A and MCP protocols to build a database application with Spring Boot and Derby DB. It uses Spring Boot and A2A and MCP protocols for communication.
		
		## Whats so special about A2AJava library?
		
		You can simple annotate your classes with @Agent and @Action and build a server.  The library will take care of the rest.  You can also use this library to build a client to send and receive messages from the server.  The library is built on top of Spring Boot and uses Jackson for JSON serialization/deserialization.  The library is designed to be easy to use and extend, so you can build your own agents quickly and easily.
		ALl methods annotated with @Action are exposed as A2A tasks and also MCP tools you dont need to do anything . 
		Infuse AI in any running application  
		
		You can convert you entire springboot based application into a2a and mcp compliant agent by using these  4 annotations:
		
		```java
		
		1 @EnableAgent  - converts your springboot application into an A2A agent
		2 @EnabaleAgentSecurity- adds security features to your agent
		3 @Agent(groupName = "", groupDescription = "") - creates an agent group
		4 @Action(description = "") - creates an action within the agent group
		
		```
		
		
		## Maven Dependency
		you can include this library in your project by following dependency in your `pom.xml` file:
		
		```
		<dependency>
		    <groupId>io.github.vishalmysore</groupId>
		    <artifactId>a2ajava</artifactId>
		    <version>0.1.8.2</version>
		</dependency>
		```
		
		and for annotations you can use the following dependency:
		
		```json
		<dependency>
		    <groupId>io.github.vishalmysore</groupId>
		    <artifactId>tools4ai-annotations</artifactId>
		    <version>0.0.2</version>
		</dependency>
		```
		
		
		optionally for security you can use the following dependency:
		
		```json
		<dependency>
		<groupId>io.github.vishalmysore</groupId>
		<artifactId>tools4ai-security</artifactId>
		<version>0.0.3</version>
		</dependency>
		```
		
		Get the latest version from [here](https://repo1.maven.org/maven2/io/github/vishalmysore/a2ajava) 
		
		## Articles
		* [A2A Protocol and Java](https://medium.com/p/54deb16302c0)  
		* [Building A2A Agents in Java](https://medium.com/p/e61bfcec28ea)  
		* [MCP vs A2A](https://medium.com/p/fef8d1d6d3ca)  
		* [Build Database Agent](https://medium.com/@visrow/google-a2a-protocol-building-a-database-agent-d5287a387b41)
		
		## A2A Protocol: A Universal Agent Language + MCP Protocol USB-C port for AI applications
		
		The **A2A protocol**, spearheaded by Google, is designed to be the universal language for AI agents.  It moves us away from a closed way of  agent communication methods and towards a future where agents can:
		
		* **Discover** each other's capabilities.
		* **Securely** exchange information.
		* **Coordinate** actions to achieve common goals.
		
		Key components of the A2A protocol include:
		
		* **Agents:** The autonomous entities that communicate.
		* **Messages:** The containers for information exchanged between agents.
		* **Parts:** The building blocks of a message (text, files, structured data).
		* **Tasks:** The units of work that agents perform for each other.
		* **Agent Card:** A cornerstone of A2A, think of it as an agent's digital business card.
		
		### The Agent Card: An Agent's Identity
		
		The **Agent Card** is a JSON-formatted file that an agent publishes to advertise its capabilities.  It's typically located at a well-known URL (`/.well-known/agent.json`) and provides essential information for other agents to discover and interact with it.  An Agent Card typically includes:
		
		* **Agent Name and Description:** Human-readable information about the agent.
		* **Endpoint URL:** The address where the agent can be reached for A2A communication.
		* **Version:** The A2A protocol version the agent supports.
		* **Capabilities:** The features the agent supports (e.g., streaming, push notifications).
		* **Authentication:** The security mechanisms the agent requires.
		* **Skills:** A detailed description of the specific functions the agent can perform.
		
		With Agent Cards, agents can dynamically discover each other and understand how to communicate, enabling flexible and extensible multi-agent systems.
		
		In our case we have exposed it as a rest end point
		
		## Features
		
		This Java implementation provides the foundation for building A2A and MCP compliant agents:
		
		* **A2A Server:**
		    * Receives and processes tasks from client agents, acting as a hub for agent collaboration.
		    * Manages the lifecycle of tasks, tracking their state and history.
		    * Serializes task data into JSON for standardized communication.
		    * Exposes A2A endpoints using the Spring MVC framework. As rest calls as well as one endpoint for JSONRPC communicaiton 
		    * 
		* **A2A Client:**
		    * Sends tasks to A2A servers, initiating agent interactions.
		    * Retrieves task information, allowing agents to monitor progress and obtain results.
		    * Communicates with A2A servers using Spring's `RestTemplate`. With JSONRPC protocol, there is only one endpoint to send and receive messages.
		* **JSON Handling:** Uses Jackson, a  Java library, for seamless JSON serialization/deserialization.
		* **Task Management:** Supports the core A2A task operations: sending tasks and retrieving their information, including historical data.
		* **Message Parts:** Handles `TextPart`, `FilePart`, and `DataPart`, providing flexibility in message content to support various data formats.
		
		* ** MCP Server:**
		    * Exposes MCP endpoints using the Spring MVC framework.
		    * Supports MCP tools and tasks, allowing agents to interact with MCP clients.
		    * Provides a unified interface for both A2A and MCP clients, enabling seamless communication across protocols.
		
		
		## Usage
		
		Fastest way to use to create the A2A amd MCP server is by using the annonvation 
		
		``` 
		@SpringBootApplication
		@EnableAgent
		public class Application {
		
		    public static void main(String[] args) {
		        SpringApplication.run(Application.class, args);
		    }
		
		}
		```
		
		This will expose all the services annotated with `@Action` as A2A tasks and MCP tools. You can also use the `@Agent` annotation to create an agent and register it with the A2A server.
		
		```java
		@Service
		@Agent(groupName ="whatThisPersonFavFood", groupDescription = "Provide persons name and then find out what does that person like")
		@Slf4j
		public class SimpleService {
		
		    /**
		     * Each action has access to AIProcessor and ActionCallback which are autowired by tools4ai
		     */
		    private ActionCallback callback;
		
		    /**
		     * Each action has access to AIProcessor and ActionCallback which are autowired by tools4ai
		     */
		    private AIProcessor processor;
		    public SimpleService(){
		      log.info(" Created Simple Service");
		    }
		
		    @Action(description = "Get the favourite food of a person")
		    public String whatThisPersonFavFood(String name) {
		        if("vishal".equalsIgnoreCase(name))
		        return "Paneer Butter Masala";
		        else if ("vinod".equalsIgnoreCase(name)) {
		            return "aloo kofta";
		        }else
		            return "something yummy";
		    }
		
		}
		```
		
		Thats it , yeah its that simple!!!
		
		Now this agent will be avaiable to both a2a as well as MCP clients. For more advanced features look at the tutorials section
		
		## Client 
		
		If you want to connect a java base client you can use 
		```java
		  A2AAgent a2aagent = new A2AAgent();
		  a2aagent.connect("http://localhost:7860");
		  Object task = a2aagent.remoteMethodCall("vishal is coming home what should i cook");
		```
		
		
		## Contributing
		Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change
		
		## Important Disclaimer(s)
		
		  
		* The A2A and MCP protocol is an evolving standard, and this implementation may need to be updated as the protocols matures.  Always refer to the official A2A documentation for the latest specifications and best practices.  
		* This implementation is not affiliated with or endorsed by Google or Anthropic.  It is my independent effort to demonstrate the A2A and MCP protocol in Java.
		* Unit test coverage needs to be enhanced , will be working on it 
		  
		  
		  ]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\client\A2AAgent.java'><![CDATA[
		package io.github.vishalmysore.a2a.client;
		
		import com.fasterxml.jackson.databind.DeserializationFeature;
		import com.fasterxml.jackson.databind.ObjectMapper;
		import io.github.vishalmysore.a2a.domain.*;
		import io.github.vishalmysore.common.Agent;
		import io.github.vishalmysore.common.AgentInfo;
		
		import io.github.vishalmysore.common.CommonClientResponse;
		
		import lombok.extern.java.Log;
		import org.springframework.http.ResponseEntity;
		import org.springframework.web.client.HttpClientErrorException;
		import org.springframework.web.client.RestTemplate;
		
		import java.io.BufferedReader;
		import java.io.IOException;
		import java.io.InputStreamReader;
		import java.net.HttpURLConnection;
		import java.net.URISyntaxException;
		import java.net.URL;
		import java.nio.charset.StandardCharsets;
		import java.util.Collections;
		import java.util.UUID;
		
		/** * A2AAgent is a client for interacting with an A2A (Agent to Agent) server.
		 * It allows sending tasks and retrieving agent information.
		 */
		
		@Log
		public class A2AAgent implements Agent {
		
		    private AgentCard agentCard;
		    private ObjectMapper mapper ;
		    private URL serverUrl;
		    public static final String WELL_KNOWN_PATH = ".well-known";
		    public static final String AGENT_PATH ="/agent.json";
		
		    private String type ="a2a";
		
		
		    public A2AAgent() {
		        this.agentCard = null;
		        this.serverUrl = null;
		        mapper = new ObjectMapper();
		        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		    }
		
		    @Override
		    public String getType() {
		        return type;
		    }
		
		    @Override
		    public CommonClientResponse remoteMethodCall(String query) {
		        try {
		            Message message = new Message();
		            TextPart textPart = new TextPart();
		            textPart.setText(query);
		            message.setParts(Collections.singletonList(textPart));
		
		            TaskSendParams params = new TaskSendParams();
		            params.setMessage(message);
		
		            params.setId(String.valueOf(UUID.randomUUID()));
		            JsonRpcRequest request = createRequest("tasks/send", params);
		            RestTemplate restTemplate = new RestTemplate();
		            ResponseEntity<SendTaskResponse> response = restTemplate.postForEntity(
		                    getServerUrl().toURI().toString(),
		                    request,
		                    SendTaskResponse.class
		            );
		
		            return response.getBody();
		        } catch (HttpClientErrorException e) {
		            log.severe("Error sending task: " + e.getMessage());
		            throw e;
		        } catch (URISyntaxException e) {
		            throw new RuntimeException(e);
		        }
		
		    }
		
		    private JsonRpcRequest createRequest(String method, Object params) {
		        return new JsonRpcRequest("2.0", method, params, UUID.randomUUID().toString());
		    }
		
		    @Override
		    public CommonClientResponse remoteMethodCall(String remoteMethodName, String query) {
		      return remoteMethodCall(query+" - possible action for this query is "+remoteMethodName);
		    }
		
		    @Override
		    public void connect(String url, String token) {
		        try {
		        serverUrl = new URL(url);
		        if(!url.endsWith(".json")) {
		            if (url.endsWith("/")) {
		                url += WELL_KNOWN_PATH + AGENT_PATH;
		            } else {
		                url += "/"+WELL_KNOWN_PATH + AGENT_PATH;
		            }
		        } else {
		            if (!url.contains(WELL_KNOWN_PATH)) {
		                throw new IllegalArgumentException("URL must end with " + WELL_KNOWN_PATH + AGENT_PATH);
		            }
		        }
		
		            URL agentCardUrl = new URL(url);
		            HttpURLConnection conn = (HttpURLConnection) agentCardUrl.openConnection();
		            conn.setRequestMethod("GET");
		            conn.setRequestProperty("Accept", "application/json");
		
		            if (conn.getResponseCode() != 200) {
		                throw new RuntimeException("Failed to connect: HTTP " + conn.getResponseCode());
		            }
		
		            try (BufferedReader br = new BufferedReader(
		                    new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
		                StringBuilder response = new StringBuilder();
		                String line;
		                while ((line = br.readLine()) != null) {
		                    response.append(line);
		                }
		
		
		                this.agentCard = mapper.readValue(response.toString(), AgentCard.class);
		
		            }
		
		        } catch (IOException e) {
		            log.severe("Failed to connect to agent server: " + e.getMessage());
		            throw new RuntimeException("Connection failed", e);
		        }
		    }
		
		    @Override
		    public void disconnect() {
		        this.agentCard = null;
		        this.serverUrl = null;
		
		    }
		
		    @Override
		    public AgentInfo getInfo() {
		        return agentCard;
		    }
		
		    @Override
		    public boolean isConnected() {
		        return agentCard != null && agentCard.getName() != null;
		    }
		
		    @Override
		    public URL getServerUrl() {
		        return serverUrl;
		    }
		
		
		    @Override
		    public ObjectMapper getMapper() {
		        return mapper;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\client\A2ATaskClient.java'><![CDATA[
		package io.github.vishalmysore.a2a.client;
		
		
		import com.fasterxml.jackson.databind.ObjectMapper;
		import io.github.vishalmysore.a2a.domain.*;
		import lombok.Getter;
		import lombok.extern.java.Log;
		import org.springframework.http.*;
		import org.springframework.web.client.HttpClientErrorException;
		import org.springframework.web.client.RestTemplate;
		
		import java.util.ArrayList;
		import java.util.Collections;
		import java.util.List;
		import java.util.UUID;
		
		/**
		 * A client for interacting with the A2A server. This might be only needed when you wnat to
		 * "infuse" Ai into your application in the sense call the A2A server from your application
		 * and get the response back.
		 * For normal client server application you can use client built in angular or react or any other web framework
		 */
		@Log
		@Getter
		
		public class A2ATaskClient {
		    private static final String DEFAULT_BASE_URL = "http://localhost:8080/rpc";
		    private final String baseUrl;
		    private final RestTemplate restTemplate;
		    private final ObjectMapper objectMapper;
		    private final List<Task> pendingTasks;
		    private final List<Task> completedTasks;
		
		    public A2ATaskClient() {
		        this(DEFAULT_BASE_URL);
		    }
		
		    public A2ATaskClient(String baseUrl) {
		        this.baseUrl = baseUrl;
		        this.restTemplate = new RestTemplate();
		        this.objectMapper = new ObjectMapper();
		        this.pendingTasks = Collections.synchronizedList(new ArrayList<>());
		        this.completedTasks = Collections.synchronizedList(new ArrayList<>());
		    }
		
		    private JsonRpcRequest createRequest(String method, Object params) {
		        return new JsonRpcRequest("2.0", method, params, UUID.randomUUID().toString());
		    }
		
		    public SendTaskResponse sendTask(String prompt) {
		        try {
		            Message message = new Message();
		            TextPart textPart = new TextPart();
		            textPart.setText(prompt);
		            message.setParts(Collections.singletonList(textPart));
		
		            TaskSendParams params = new TaskSendParams();
		            params.setMessage(message);
		            params.setId(String.valueOf(UUID.randomUUID()));
		            JsonRpcRequest request = createRequest("tasks/send", params);
		            ResponseEntity<SendTaskResponse> response = restTemplate.postForEntity(
		                    baseUrl,
		                    request,
		                    SendTaskResponse.class
		            );
		
		            SendTaskResponse task = response.getBody();
		            if (task != null) {
		                pendingTasks.add(task.getResult());
		            }
		            return task;
		        } catch (HttpClientErrorException e) {
		            log.severe("Error sending task: " + e.getMessage());
		            throw e;
		        }
		    }
		
		    public Task getTask(String taskId, Integer historyLength) {
		        try {
		            TaskQueryParams params = new TaskQueryParams();
		            params.setId(taskId);
		            params.setHistoryLength(historyLength);
		
		            JsonRpcRequest request = createRequest("tasks/get", params);
		            ResponseEntity<Task> response = restTemplate.postForEntity(
		                    baseUrl,
		                    request,
		                    Task.class
		            );
		
		            Task task = response.getBody();
		            if (task != null && task.getStatus().toString().equals("completed")) {
		                pendingTasks.removeIf(t -> t.getId().equals(taskId));
		                completedTasks.add(task);
		            }
		            return task;
		        } catch (HttpClientErrorException e) {
		            log.severe("Error getting task: " + e.getMessage());
		            throw e;
		        }
		    }
		
		    public boolean cancelTask(String taskId) {
		        try {
		            TaskCancelParams params = new TaskCancelParams();
		            params.setId(taskId);
		
		            JsonRpcRequest request = createRequest("tasks/cancel", params);
		            restTemplate.postForEntity(baseUrl, request, Object.class);
		
		            pendingTasks.removeIf(t -> t.getId().equals(taskId));
		            return true;
		        } catch (HttpClientErrorException e) {
		            log.severe("Error cancelling task: " + e.getMessage());
		            throw e;
		        }
		    }
		
		    public List<Task> getPendingTasks() {
		        return new ArrayList<>(pendingTasks);
		    }
		
		    public List<Task> getCompletedTasks() {
		        return new ArrayList<>(completedTasks);
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\client\LocalA2ATaskClient.java'><![CDATA[
		package io.github.vishalmysore.a2a.client;
		
		import io.github.vishalmysore.a2a.domain.*;
		import io.github.vishalmysore.common.server.JsonRpcController;
		import lombok.extern.java.Log;
		import org.springframework.http.ResponseEntity;
		import org.springframework.web.client.HttpClientErrorException;
		
		import java.io.File;
		import java.util.*;
		
		/**
		 * A client for interacting with the A2A server. This might be only needed when you wnat to
		 * "infuse" Ai into your application in the sense call the A2A server from your application
		 * and get the response back.
		 * For normal client server application you can use client built in angular or react or any other web framework
		 */
		@Log
		
		public class LocalA2ATaskClient {
		
		    public static final String TASKS_SEND = "tasks/send";
		    public static final String TASKS_GET = "tasks/get";
		    public static final String ERROR_SENDING_FILE_TASK = "Error sending file task: ";
		
		    private JsonRpcController jrc = null;
		
		
		    /**
		     * need for spring autowiring
		     */
		    public LocalA2ATaskClient() {
		        jrc = new JsonRpcController();
		    }
		
		    public LocalA2ATaskClient(JsonRpcController jrc) {
		        this.jrc = jrc;
		    }
		
		
		
		    private JsonRpcRequest createRequest(String method, Object params) {
		        return new JsonRpcRequest("2.0", method, params, UUID.randomUUID().toString());
		    }
		
		    public Task sendTask(String prompt) {
		        try {
		            Message message = new Message();
		            TextPart textPart = new TextPart();
		            textPart.setText(prompt);
		            message.setParts(Collections.singletonList(textPart));
		
		            TaskSendParams params = new TaskSendParams();
		            params.setId(String.valueOf(UUID.randomUUID()));
		            params.setMessage(message);
		
		            JsonRpcRequest request = createRequest(TASKS_SEND, params);
		           return ((SendTaskResponse)jrc.handleRpc(request)).getResult();
		
		
		        } catch (HttpClientErrorException e) {
		            log.severe("Error sending task: " + e.getMessage());
		            throw e;
		        }
		    }
		
		    public Task getTask(String taskId, Integer historyLength) {
		        try {
		            TaskQueryParams params = new TaskQueryParams();
		            params.setId(taskId);
		            params.setHistoryLength(historyLength);
		
		            JsonRpcRequest request = createRequest(TASKS_GET, params);
		            ResponseEntity<Task> response = (ResponseEntity<Task>)jrc.handleRpc(request);
		
		          return response.getBody();
		
		
		        } catch (HttpClientErrorException e) {
		            log.severe("Error getting task: " + e.getMessage());
		            throw e;
		        }
		    }
		
		    public Task sendFileTask(String filePath) {
		        try {
		            log.info(filePath);
		            Message message = new Message();
		            FilePart filePart = new FilePart();
		            FileContent content = new FileContent();
		            filePart.setFile(content);
		            message.setParts(Collections.singletonList(filePart));
		
		            TaskSendParams params = new TaskSendParams();
		            params.setId(String.valueOf(UUID.randomUUID()));
		            params.setMessage(message);
		
		            JsonRpcRequest request = createRequest(TASKS_SEND, params);
		            return ((SendTaskResponse)jrc.handleRpc(request)).getResult();
		
		
		        } catch (HttpClientErrorException e) {
		            log.severe(ERROR_SENDING_FILE_TASK
		                    + e.getMessage());
		            throw e;
		        }
		    }
		
		    public Task sendFileTask(FilePart filePart) {
		        try {
		            Message message = new Message();
		
		            message.setParts(Collections.singletonList(filePart));
		
		            TaskSendParams params = new TaskSendParams();
		            params.setId(String.valueOf(UUID.randomUUID()));
		            params.setMessage(message);
		
		            JsonRpcRequest request = createRequest(TASKS_SEND, params);
		            return  ((SendTaskResponse)jrc.handleRpc(request)).getResult();
		
		
		        } catch (HttpClientErrorException e) {
		            log.severe(ERROR_SENDING_FILE_TASK + e.getMessage());
		            throw e;
		        }
		    }
		
		    public Task sendFileTask(TextPart textPart,FilePart filePart) {
		        try {
		            Message message = new Message();
		
		            List<Part> partList = new ArrayList<>();
		            partList.add(textPart);
		            partList.add(filePart);
		            message.setParts(partList);
		
		            TaskSendParams params = new TaskSendParams();
		            params.setId(String.valueOf(UUID.randomUUID()));
		            params.setMessage(message);
		
		            JsonRpcRequest request = createRequest(TASKS_SEND, params);
		            return ((SendTaskResponse)jrc.handleRpc(request)).getResult();
		
		
		        } catch (HttpClientErrorException e) {
		            log.severe(ERROR_SENDING_FILE_TASK+ e.getMessage());
		            throw e;
		        }
		    }
		
		    public Task sendDataTask(Map<String,Object> data) {
		        try {
		            Message message = new Message();
		            DataPart dataPart = new DataPart();
		            dataPart.setData(data);
		            message.setParts(Collections.singletonList(dataPart));
		
		            TaskSendParams params = new TaskSendParams();
		            params.setId(String.valueOf(UUID.randomUUID()));
		            params.setMessage(message);
		
		            JsonRpcRequest request = createRequest(TASKS_SEND, params);
		            return((SendTaskResponse)jrc.handleRpc(request)).getResult();
		
		
		        } catch (HttpClientErrorException e) {
		            log.severe("Error sending data task: " + e.getMessage());
		            throw e;
		        }
		    }
		
		    public Task sendMultiPartTask(List<Object> parts) {
		        try {
		            Message message = new Message();
		            List<Object> messageParts = new ArrayList<>();
		
		            for (Object part : parts) {
		                if (part instanceof String) {
		                    TextPart textPart = new TextPart();
		                    textPart.setText((String) part);
		                    messageParts.add(textPart);
		                } else if (part instanceof File) {
		                    FilePart filePart = new FilePart();
		                    FileContent content = new FileContent();
		                    filePart.setFile(content);
		                    messageParts.add(filePart);
		                } else {
		                    DataPart dataPart = new DataPart();
		
		                    messageParts.add(dataPart);
		                }
		            }
		
		
		
		            TaskSendParams params = new TaskSendParams();
		            params.setId(String.valueOf(UUID.randomUUID()));
		            params.setMessage(message);
		
		            JsonRpcRequest request = createRequest(TASKS_SEND, params);
		           return ((SendTaskResponse)jrc.handleRpc(request)).getResult();
		
		
		        } catch (HttpClientErrorException e) {
		            log.severe("Error sending multi-part task: " + e.getMessage());
		            throw e;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\A2ATask.java'>
		package io.github.vishalmysore.a2a.domain;
		
		public interface A2ATask {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\AgentCard.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import com.t4a.annotations.ListType;
		import io.github.vishalmysore.common.AgentInfo;
		import lombok.Data;
		import lombok.EqualsAndHashCode;
		import lombok.ToString;
		
		import java.util.ArrayList;
		import java.util.List;
		import java.util.UUID;
		
		@Data
		@ToString
		@EqualsAndHashCode
		public class AgentCard implements AgentInfo {
		    private String name;
		    private String description;
		    private String url;
		    private Provider provider;
		    private String version;
		    private String documentationUrl;
		    private Capabilities capabilities;
		    private Authentication authentication;
		    private String[] defaultInputModes;
		    private String[] defaultOutputModes;
		    //private Skill[] skills;
		    @ListType(Skill.class)
		    private List<Skill> skills;
		
		    // Getters and setters
		    public void addSkill(String name, String description) {
		        if (skills == null) {
		            skills = new ArrayList<>();
		        }
		
		        Skill skill = new Skill();
		        skill.setId(UUID.randomUUID().toString());
		        skill.setName(name);
		        skill.setDescription(description);
		
		        skills.add(skill);
		    }
		
		    public void addSkill(String name, String description, String... tags) {
		        if (skills == null) {
		            skills = new ArrayList<>();
		        }
		
		        Skill skill = new Skill();
		        skill.setId(UUID.randomUUID().toString());
		        skill.setName(name);
		        skill.setDescription(description);
		        skill.setTags(tags);
		
		        skills.add(skill);
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\Artifact.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		
		import lombok.Data;
		import lombok.ToString;
		
		import java.util.HashMap;
		import java.util.List;
		import java.util.Map;
		
		@Data
		
		@ToString
		public class Artifact {
		
		    @JsonIgnore
		    private String id;
		    private String name;
		    private String description;
		
		    private List<Part> parts;
		
		    private Map<String, String> metadata = new HashMap<>();
		    private int index;
		    private boolean append;
		    private boolean lastChunk;
		
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\Authentication.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		
		
		import com.t4a.annotations.Prompt;
		import lombok.Data;
		import lombok.ToString;
		
		import java.util.Base64;
		
		@Data
		
		@ToString(exclude = "credentials")
		public class Authentication {
		
		    @Prompt(describe = "The authentication schemes supported by the a2a protocol server, e.g., Basic, Bearer, ApiKey. Dont keep it empty")
		    private String[] schemes;
		    private String credentials;
		
		    public Authentication() {
		    }
		
		    public Authentication(String[] schemes) {
		        this.schemes = schemes;
		    }
		
		    public void setBasicAuth(String username, String password) {
		        this.schemes = new String[]{"Basic"};
		        String auth = username + ":" + password;
		        this.credentials = Base64.getEncoder().encodeToString(auth.getBytes());
		    }
		
		    public void setBearerAuth(String token) {
		        this.schemes = new String[]{"Bearer"};
		        this.credentials = token;
		    }
		
		    public void setApiKeyAuth(String apiKey) {
		        this.schemes = new String[]{"ApiKey"};
		        this.credentials = apiKey;
		    }
		
		    public boolean isBasicAuth() {
		        return schemes != null && schemes.length > 0 && "Basic".equals(schemes[0]);
		    }
		
		    public boolean isBearerAuth() {
		        return schemes != null && schemes.length > 0 && "Bearer".equals(schemes[0]);
		    }
		
		
		    public static Authentication fromAuthorizationHeader(String header) {
		        if (header == null || header.isEmpty()) {
		            return null;
		        }
		
		        Authentication auth = new Authentication();
		        if (header.startsWith("Basic ")) {
		            auth.setSchemes(new String[]{"Basic"});
		            auth.setCredentials(header.substring(6));
		        } else if (header.startsWith("Bearer ")) {
		            auth.setSchemes(new String[]{"Bearer"});
		            auth.setCredentials(header.substring(7));
		        } else {
		            auth.setSchemes(new String[]{"ApiKey"});
		            auth.setCredentials(header);
		        }
		        return auth;
		    }
		
		    public boolean isValid() {
		        return schemes != null &&
		                schemes.length > 0 &&
		                credentials != null &&
		                !credentials.isEmpty();
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\CancelTaskResponse.java'>
		package io.github.vishalmysore.a2a.domain;
		
		
		
		import com.fasterxml.jackson.annotation.JsonInclude;
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@JsonInclude(JsonInclude.Include.NON_NULL)
		@ToString
		public class CancelTaskResponse {
		    private final String jsonrpc = "2.0";
		    private Object id;
		    private Task result;
		    private JSONRPCError error;
		
		    public CancelTaskResponse() {
		    }
		
		    public CancelTaskResponse(Object id, Task result) {
		        this.id = id;
		        this.result = result;
		        this.error = null;
		    }
		
		    public CancelTaskResponse(Object id, JSONRPCError error) {
		        this.id = id;
		        this.result = null;
		        this.error = error;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\Capabilities.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.AllArgsConstructor;
		import lombok.Data;
		import lombok.NoArgsConstructor;
		import lombok.ToString;
		
		@Data
		@NoArgsConstructor
		@AllArgsConstructor
		@ToString
		public class Capabilities {
		    private boolean streaming;
		    private boolean pushNotifications;
		    private boolean stateTransitionHistory;
		
		
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\DataPart.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		
		import lombok.ToString;
		
		import java.util.HashMap;
		import java.util.Map;
		
		@ToString
		public class DataPart extends Part {
		
		
		    @JsonIgnore
		    private String id;
		    private String type = "data";
		
		
		    private Map<String, Object> data;
		
		    private Map<String, String> metadata;
		
		    public String getType() {
		        return type;
		    }
		
		    public Map<String, Object> getData() {
		        return data;
		    }
		
		    public void setType(String type) {
		        this.type = type;
		    }
		    public void setData(Map<String, Object> data) {
		        this.data = data;
		    }
		
		    public Map<String, String> getMetadata() {
		        return metadata;
		    }
		
		    public void setMetadata(Map<String, String> metadata) {
		        this.metadata = metadata;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\FileContent.java'>
		package io.github.vishalmysore.a2a.domain;
		
		
		import lombok.Data;
		import lombok.ToString;
		
		/**
		 * Represents the content of a file, either as base64 encoded bytes or a URI.\n\n
		 * Ensures that either 'bytes' or 'uri' is provided, but not both.
		 */
		
		@Data
		
		@ToString
		public class FileContent {
		
		    private String id;
		
		    private String name;
		    private String mimeType;
		
		
		    private String bytes;  // base64 encoded
		
		    private String uri;
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\FilePart.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		
		import lombok.ToString;
		
		
		import java.util.Map;
		
		
		@ToString
		public class FilePart extends Part {
		
		    @JsonIgnore
		    private String id;
		    private String type = "file";
		
		    private FileContent file;
		
		    private Map<String, String> metadata;
		
		    public String getType() {
		        return type;
		    }
		
		    public FileContent getFile() {
		        return file;
		    }
		
		    public void setType(String type) {
		        this.type = type;
		    }
		    public void setFile(FileContent file) {
		        this.file = file;
		    }
		
		    public Map<String, String> getMetadata() {
		        return metadata;
		    }
		
		    public void setMetadata(Map<String, String> metadata) {
		        this.metadata = metadata;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\GetTaskPushNotificationResponse.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonInclude;
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@JsonInclude(JsonInclude.Include.NON_NULL)
		@ToString
		public class GetTaskPushNotificationResponse {
		    private final String jsonrpc = "2.0";
		    private Object id;
		    private TaskPushNotificationConfig result;
		
		
		    public GetTaskPushNotificationResponse() {
		    }
		
		    public GetTaskPushNotificationResponse(Object id, TaskPushNotificationConfig result) {
		        this.id = id;
		        this.result = result;
		
		    }
		
		    public GetTaskPushNotificationResponse(Object id) {
		        this.id = id;
		        this.result = null;
		
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\JSONRPCError.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		
		
		import com.fasterxml.jackson.annotation.JsonInclude;
		import lombok.Data;
		import lombok.ToString;
		
		import java.util.Map;
		
		@Data
		@JsonInclude(JsonInclude.Include.NON_NULL)
		@ToString
		public class JSONRPCError {
		    private int code;
		    private String message;
		    private Map<String, Object> data;
		
		    public JSONRPCError() {
		    }
		
		    public JSONRPCError(int code, String message) {
		        this.code = code;
		        this.message = message;
		    }
		
		    public JSONRPCError(int code, String message, Map<String, Object> data) {
		        this.code = code;
		        this.message = message;
		        this.data = data;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\JsonRpcRequest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.databind.ObjectMapper;
		import io.github.vishalmysore.common.CommonClientRequest;
		import io.github.vishalmysore.mcp.domain.ClientRequest;
		import lombok.*;
		
		@Getter
		@Setter
		@AllArgsConstructor
		@NoArgsConstructor
		@ToString
		public class JsonRpcRequest implements CommonClientRequest {
		    private String jsonrpc;
		    private String method;
		    private Object params;
		    private Object id;
		
		    public static JsonRpcRequest fromString(String jsonString) {
		        try {
		            ObjectMapper mapper = new ObjectMapper();
		            return mapper.readValue(jsonString, JsonRpcRequest.class);
		        } catch (Exception e) {
		            throw new RuntimeException("Error parsing JSON RPC request: " + e.getMessage(), e);
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\Message.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		
		import lombok.Data;
		
		import java.util.List;
		import java.util.Map;
		
		@Data
		
		public class Message {
		
		    @JsonIgnore
		    private String id;
		
		    private String role;
		
		
		    private List<Part> parts;
		
		
		    private Map<String, String> metadata;
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\Part.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		import com.fasterxml.jackson.annotation.JsonSubTypes;
		import com.fasterxml.jackson.annotation.JsonTypeInfo;
		
		
		import java.util.Map;
		
		
		@JsonTypeInfo(
		        use = JsonTypeInfo.Id.NAME,
		        include = JsonTypeInfo.As.PROPERTY,
		        property = "type"
		)
		@JsonSubTypes({
		        @JsonSubTypes.Type(value = TextPart.class, name = "text"),
		        @JsonSubTypes.Type(value = FilePart.class, name = "file"),
		        @JsonSubTypes.Type(value = DataPart.class, name = "data")
		})
		public abstract class Part {
		
		    @JsonIgnore
		    private String id;
		
		    private String type;
		
		
		    private Map<String, String> metadata;
		
		    public abstract String getType();
		    public abstract Map<String, String> getMetadata();
		    public abstract void setType(String type);
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\Provider.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.AllArgsConstructor;
		import lombok.Data;
		import lombok.NoArgsConstructor;
		import lombok.ToString;
		
		@Data
		@AllArgsConstructor
		@NoArgsConstructor
		@ToString
		public class Provider {
		    private String organization;
		    private String url;
		
		
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\PushNotificationNotSupportedError.java'>
		package io.github.vishalmysore.a2a.domain;
		
		
		public class PushNotificationNotSupportedError extends JSONRPCError {
		    private static final int ERROR_CODE = -32003;
		    private static final String ERROR_MESSAGE = "Push Notification is not supported";
		
		    public PushNotificationNotSupportedError() {
		        super(ERROR_CODE, ERROR_MESSAGE, null);
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\SendTaskResponse.java'>
		package io.github.vishalmysore.a2a.domain;
		
		
		
		import io.github.vishalmysore.common.CommonClientResponse;
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@ToString
		public class SendTaskResponse implements CommonClientResponse {
		    private final String jsonrpc = "2.0";
		    private String id;
		    private Task result;
		    private JSONRPCError error;
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\SendTaskStreamingResponse.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonInclude;
		import com.fasterxml.jackson.annotation.JsonProperty;
		import lombok.ToString;
		
		@JsonInclude(JsonInclude.Include.NON_NULL)
		@ToString
		public class SendTaskStreamingResponse {
		
		    @JsonProperty("jsonrpc")
		    private String jsonrpc = "2.0";
		
		    @JsonProperty("id")
		    private Object id; // Can be Integer, String, or null
		
		    @JsonProperty("result")
		    private Object result; // Should be TaskStatusUpdateEvent or TaskArtifactUpdateEvent or null
		
		
		
		
		    // Constructors
		    public SendTaskStreamingResponse() {
		    }
		
		    public SendTaskStreamingResponse(Object id, Object result) {
		        this.id = id;
		        this.result = result;
		
		    }
		
		    // Getters and Setters
		    public String getJsonrpc() {
		        return jsonrpc;
		    }
		
		    public void setJsonrpc(String jsonrpc) {
		        this.jsonrpc = jsonrpc;
		    }
		
		    public Object getId() {
		        return id;
		    }
		
		    public void setId(Object id) {
		        this.id = id;
		    }
		
		    public Object getResult() {
		        return result;
		    }
		
		    public void setResult(Object result) {
		        this.result = result;
		    }
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\Skill.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@ToString
		public class Skill {
		    private String id;
		    private String name;
		    private String description;
		    private String[] tags;
		    private String[] examples;
		    private String[] inputModes;
		    private String[] outputModes;
		
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\Task.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		
		
		
		import io.github.vishalmysore.common.CommonClientRequest;
		import io.github.vishalmysore.common.CommonClientResponse;
		import lombok.Data;
		import lombok.Getter;
		import lombok.Setter;
		import lombok.ToString;
		
		import java.util.ArrayList;
		import java.util.Date;
		import java.util.List;
		import java.util.Map;
		
		/**
		 * Represents a task in the system. We can have multiple tasks in a session. and each task can have multiple artifacts.
		 * A task can be in one of the following states:
		 * 1. PENDING: The task is created but not yet started.
		 * 2. IN_PROGRESS: The task is currently being processed.
		 * 3. COMPLETED: The task has been completed successfully.
		 * 4. FAILED: The task has failed.
		 * 5. CANCELLED: The task has been cancelled.
		 * 6. TIMEOUT: The task has timed out.
		 * 7. EXPIRED: The task has expired.
		 *
		 * Implementation of TaskStatus enum is not provided in the original code.
		 * All implementation of Task can be done in applications extending this library
		 */
		@Data
		@Getter
		@Setter
		@ToString
		public class Task implements A2ATask, CommonClientRequest, CommonClientResponse {
		
		    private String id;
		    private String sessionId;
		
		    private TaskStatus status;
		
		    private List<Message> history;
		
		    private List<Artifact> artifacts;
		
		
		    private Map<String, String> metadata;
		
		    private TaskPushNotificationConfig pushNotificationConfig; // Added
		    private String pushNotificationUrl; // Added
		    boolean subscribed;
		
		    private Date subscriptionDateNow;
		    boolean cancelled;
		
		    public void setDetailedAndMessage(TaskState state, String messageStr) {
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText(messageStr);
		
		        Message message = new Message();
		        message.setRole("agent");
		        message.setParts(new ArrayList<>(List.of(textPart)));
		
		        TaskStatus processingStatus = new TaskStatus(state);
		        processingStatus.setMessage(message);
		        this.setStatus(processingStatus);
		    }
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskArtifactUpdateEvent.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.AllArgsConstructor;
		import lombok.Data;
		import lombok.NoArgsConstructor;
		
		import java.util.Map;
		
		@Data
		@AllArgsConstructor
		@NoArgsConstructor
		public class TaskArtifactUpdateEvent {
		    private String id;
		    private Artifact artifact;
		    private Map<String, Object> metadata;
		
		
		    public TaskArtifactUpdateEvent(String taskId, Artifact artifact) {
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskCancelParams.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@ToString
		public class TaskCancelParams {
		    private String id; // Task ID to cancel
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskGetPushNotificationParams.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@ToString
		public class TaskGetPushNotificationParams {
		    private String taskId; // Task ID to retrieve the push notification settings
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskPushNotificationConfig.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		
		import lombok.Data;
		
		@Data
		
		public class TaskPushNotificationConfig {
		
		    @JsonIgnore
		    private String id;
		
		    private String url;
		    private String token;
		
		
		    private Authentication authentication;
		
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskPushNotificationConfigRequest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		
		@Data
		public class TaskPushNotificationConfigRequest {
		    private String id;
		    private TaskPushNotificationConfig pushNotificationConfig;
		
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskQueryParams.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		import java.util.List;
		import java.util.Map;
		
		@Data
		@ToString
		public class TaskQueryParams {
		    private String id;
		    private Integer historyLength;
		    private Map<String, Object> metadata;
		    private String sessionId;
		    private Message message;
		    private TaskPushNotificationConfig pushNotification;
		    private List<String> acceptedOutputModes;
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskResubscriptionParams.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@ToString
		public class TaskResubscriptionParams {
		    private String subscriptionId; // Subscription ID to resubscribe
		    private String taskId; // Task ID to resubscribe
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskSendParams.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		import java.util.List;
		import java.util.Map;
		
		@Data
		@ToString
		public class TaskSendParams {
		    private String id;
		    private String sessionId;
		    private Message message;
		    private int historyLength;
		    private TaskPushNotificationConfig pushNotification;
		    private Map<String, Object> metadata;
		    private List<String> acceptedOutputModes;
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskSendSubscribeParams.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		import java.util.List;
		import java.util.Map;
		
		@Data
		@ToString
		public class TaskSendSubscribeParams {
		    private String id;
		    private String sessionId;
		    private Message message;
		    private List<String> acceptedOutputModes;
		    private Object pushNotification; // you can make a special class later if needed
		    private Integer historyLength;
		    private Map<String, Object> metadata; // dynamic structure, so Map
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskSetPushNotificationParams.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@ToString
		public class TaskSetPushNotificationParams {
		    private String taskId;         // Task ID
		    private String notificationUrl; // URL where notifications should be sent
		
		    private String pushNotificationUrl;
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskState.java'>
		package io.github.vishalmysore.a2a.domain;
		
		
		
		import com.fasterxml.jackson.annotation.JsonCreator;
		import com.fasterxml.jackson.annotation.JsonValue;
		
		public enum TaskState {
		    SUBMITTED("submitted"),
		    WORKING("working"),
		    INPUT_REQUIRED("input-required"),
		    COMPLETED("completed"),
		    CANCELED("canceled"),
		    FAILED("failed"),
		    UNKNOWN("unknown");
		
		    private final String value;
		
		    TaskState(String value) {
		        this.value = value;
		    }
		
		    @JsonValue
		    public String getValue() {
		        return value;
		    }
		
		    @JsonCreator
		    public static TaskState forValue(String value) {
		        for (TaskState state : values()) {
		            if (state.value.equalsIgnoreCase(value)) { // Case-insensitive comparison
		                return state;
		            }
		        }
		        return UNKNOWN;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskStatus.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		
		import lombok.Data;
		
		import java.time.Instant;
		import java.time.format.DateTimeFormatter;
		
		@Data
		
		public class TaskStatus {
		
		    @JsonIgnore
		    private String id;
		
		
		    private TaskState state;
		
		
		    private Message message;
		
		    private String timestamp;
		
		    public TaskStatus() {
		        this.state = TaskState.SUBMITTED;
		        setCurrentTimestamp();
		    }
		
		    public TaskStatus(TaskState state) {
		        this.state = state;
		        setCurrentTimestamp();
		    }
		
		    public TaskStatus(String state) {
		        this.state = TaskState.forValue(state);
		        setCurrentTimestamp();
		    }
		
		    private void setCurrentTimestamp() {
		        this.timestamp = DateTimeFormatter.ISO_INSTANT.format(Instant.now());
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TaskStatusUpdateEvent.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import lombok.Data;
		
		import java.util.Map;
		
		@Data
		public class TaskStatusUpdateEvent {
		    private String id;
		    private TaskStatus status;
		    private boolean finalValue;
		    private Map<String, Object> metadata;
		
		    public TaskStatusUpdateEvent() {
		    }
		
		    public TaskStatusUpdateEvent(String id, TaskStatus status, boolean finalValue) {
		        this.id = id;
		        this.status = status;
		        this.finalValue = finalValue;
		    }
		
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\domain\TextPart.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import com.fasterxml.jackson.annotation.JsonIgnore;
		
		import lombok.ToString;
		
		import java.util.HashMap;
		import java.util.Map;
		
		
		@ToString
		public class TextPart extends Part {
		
		
		    @JsonIgnore
		    private String id;
		    private String type = "text";
		    private String text;
		
		
		    private Map<String, String> metadata = new HashMap<>();
		
		    // Update getter and setter to use String instead of Object
		    @Override
		    public Map<String, String> getMetadata() {
		        return metadata;
		    }
		
		    public void setMetadata(Map<String, String> metadata) {
		        this.metadata = metadata;
		    }
		
		    // Other getters and setters remain the same
		    @Override
		    public String getType() {
		        return type;
		    }
		
		    public String getText() {
		        return text;
		    }
		
		    @Override
		    public void setType(String type) {
		        this.type = type;
		    }
		
		    public void setText(String text) {
		        this.text = text;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\A2AAgentCardController.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		import com.t4a.api.AIAction;
		import com.t4a.api.GenericJavaMethodAction;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.a2a.domain.AgentCard;
		import io.github.vishalmysore.a2a.domain.Skill;
		import org.springframework.http.ResponseEntity;
		
		/**
		 * Interface for A2A Agent Card Controller.
		 */
		public interface A2AAgentCardController {
		    public ResponseEntity<AgentCard> getAgentCard();
		
		    public PromptTransformer getPromptTransformer();
		
		    default Skill getSkill(String actionName) throws AIProcessingException {
		        GenericJavaMethodAction action = (GenericJavaMethodAction)PredictionLoader.getInstance().getAiAction(actionName);
		        return (Skill)getPromptTransformer().transformIntoPojo(
		                "use this description and also populate skills in detail " + "Name of the skill : " + action.getActionName() + " description : " + action.getDescription() + " parameter " + action.getJsonRPC(),
		                Skill.class);
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\A2ARPCController.java'>
		package io.github.vishalmysore.a2a.server;
		
		import io.github.vishalmysore.a2a.domain.JsonRpcRequest;
		import org.springframework.web.bind.annotation.RequestBody;
		
		public interface A2ARPCController {
		    default void preProcessing(String method, Object params) {};
		    default void postProcessing(String method, Object params) {};
		    public Object handleRpc(JsonRpcRequest request);
		    public A2ATaskController getTaskController();
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\A2ATaskController.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.processor.AIProcessor;
		import io.github.vishalmysore.a2a.domain.*;
		import org.springframework.http.ResponseEntity;
		import org.springframework.web.bind.annotation.RequestParam;
		import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
		
		
		import java.util.List;
		
		public interface A2ATaskController {
		
		
		    public SseEmitter sendSubscribeTask(TaskSendSubscribeParams params);
		
		    Object setTaskPushNotification(TaskSetPushNotificationParams setPushParams);
		
		    public ResponseEntity<Task> getTask(@RequestParam String id, @RequestParam(defaultValue = "0") int historyLength) ;
		
		    Object cancelTask(String id);
		
		    Object getTaskPushNotification(TaskGetPushNotificationParams getPushParams);
		
		    Object resubscribeToTask(TaskResubscriptionParams resubParams);
		
		    default SendTaskResponse sendTask(TaskSendParams taskSendParams, ActionCallback callback) {
		        return sendTask(taskSendParams, callback, true);
		    }
		
		    public SendTaskResponse sendTask(TaskSendParams taskSendParams, ActionCallback callback,boolean isAsync);
		
		    public default SendTaskResponse sendTask(TaskSendParams taskSendParams) {
		        return sendTask(taskSendParams, null);
		    }
		
		    public AIProcessor getBaseProcessor ();
		
		    default List<Task> getTasks() {
		        throw new UnsupportedOperationException();
		    }
		
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\DyanamicTaskContoller.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		import com.fasterxml.jackson.databind.ObjectMapper;
		import com.t4a.JsonUtils;
		import com.t4a.detect.ActionCallback;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.processor.AIProcessor;
		import com.t4a.processor.GeminiV2ActionProcessor;
		import com.t4a.processor.OpenAiActionProcessor;
		import com.t4a.processor.scripts.BaseScriptProcessor;
		import com.t4a.processor.scripts.ScriptProcessor;
		import com.t4a.processor.scripts.ScriptResult;
		
		import com.t4a.transform.GeminiV2PromptTransformer;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.a2a.domain.*;
		
		import lombok.Getter;
		import lombok.extern.java.Log;
		
		import org.springframework.http.HttpStatus;
		import org.springframework.http.ResponseEntity;
		
		import org.springframework.web.bind.annotation.*;
		import org.springframework.web.server.ResponseStatusException;
		import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
		
		
		import javax.annotation.PostConstruct;
		import java.io.IOException;
		import java.io.InputStream;
		import java.io.PrintWriter;
		import java.io.StringWriter;
		import java.nio.file.Files;
		import java.nio.file.Path;
		import java.nio.file.Paths;
		import java.nio.file.StandardCopyOption;
		import java.util.*;
		import java.util.concurrent.ConcurrentHashMap;
		import java.util.concurrent.ExecutorService;
		import java.util.concurrent.Executors;
		
		/**
		 * This will be used to process dynamic tasks , the tasks are not hard coded but decided by AI
		 * based on the input prompt
		 */
		@Log
		public class DyanamicTaskContoller implements A2ATaskController {
		    public static final String MESSAGE = "message";
		    protected final Map<String, Task> tasks = new ConcurrentHashMap<>();
		    private final Map<String, SseEmitter> emitters = new ConcurrentHashMap<>();
		    @Getter
		    private final ExecutorService nonBlockingService = Executors.newCachedThreadPool();
		    protected AIProcessor baseProcessor = new GeminiV2ActionProcessor();
		
		    protected PromptTransformer promptTransformer = new GeminiV2PromptTransformer();
		
		
		
		    private BaseScriptProcessor scriptProcessor;
		    protected PromptTransformer getPromptTransformer() {
		        return promptTransformer;
		    }
		
		    private JsonUtils utils = new JsonUtils();
		
		    ObjectMapper objectMapper = new ObjectMapper();
		
		    public DyanamicTaskContoller() {
		      init();
		    }
		
		
		    @PostConstruct
		    public void initOptionalProcessors (){
		        scriptProcessor = new ScriptProcessor();
		    }
		
		    public BaseScriptProcessor getScriptProcessor() {
		        return scriptProcessor;
		    }
		
		    public void init() {
		       baseProcessor = PredictionLoader.getInstance().createOrGetAIProcessor();
		    }
		    @Override
		    public AIProcessor getBaseProcessor() {
		        return baseProcessor;
		    }
		
		
		
		    public SendTaskResponse sendTask(TaskSendParams taskSendParams, ActionCallback actionCallback,boolean isAsync) {
		        String taskId = taskSendParams.getId();
		        Task task;
		
		        if (tasks.containsKey(taskId)) {
		            task = tasks.get(taskId);
		            List<Message> history = task.getHistory();
		            if (history == null) {
		                history = new ArrayList<>();
		            }
		            List<Message> mutableHistory = new ArrayList<>(history);
		            mutableHistory.add(taskSendParams.getMessage());
		            task.setHistory(mutableHistory);
		        } else {
		            task = new Task();
		            task.setId(taskId);
		            String sessionId = taskSendParams.getSessionId();
		            if (sessionId == null || sessionId.isEmpty()) {
		                sessionId = UUID.randomUUID().toString();
		            }
		            task.setSessionId(sessionId);
		            task.setDetailedAndMessage(TaskState.SUBMITTED," Your Task with id " + taskId + " is submitted");
		            task.setHistory(new ArrayList<>(List.of(taskSendParams.getMessage())));
		
		            tasks.put(taskId, task);
		        }
		
		        processTaskLogicForSyncndAsync(taskSendParams, actionCallback, isAsync, task, taskId);
		
		        SendTaskResponse response = new SendTaskResponse();
		        response.setId(taskId);
		        response.setResult(task);
		        return response;
		    }
		
		    protected void processTaskLogicForSyncndAsync(TaskSendParams taskSendParams, ActionCallback actionCallback, boolean isAsync, Task task, String taskId) {
		        if (isAsync) {
		            nonBlockingService.execute(() -> processTaskLogic(taskSendParams, task, taskId, actionCallback));
		        } else {
		            processTaskLogic(taskSendParams, task, taskId, actionCallback);
		        }
		    }
		
		
		    protected void processTaskLogic(TaskSendParams taskSendParams, Task task, String taskId, ActionCallback actionCallback) {
		        try {
		            processParts(taskSendParams, task, taskId, actionCallback);
		        } catch (Exception e) {
		            handleProcessingError(task, taskId, e);
		        }
		    }
		
		    private void processParts(TaskSendParams taskSendParams, Task task, String taskId, ActionCallback actionCallback) throws AIProcessingException {
		        List<Part> parts = taskSendParams.getMessage().getParts();
		        if (parts == null || parts.isEmpty()) {
		            return;
		        }
		
		        Part part = parts.get(0);
		        if (part instanceof TextPart textPart) {
		            processTextPart(textPart, task, actionCallback);
		        } else if (part instanceof FilePart) {
		            processFileTaskLogic(taskSendParams, task, taskId, actionCallback);
		        }
		    }
		
		    private void processTextPart(TextPart textPart, Task task, ActionCallback actionCallback) throws AIProcessingException {
		        if (!"text".equals(textPart.getType())) {
		            return;
		        }
		
		        String text = textPart.getText();
		        if (actionCallback != null) {
		            processWithCallback(text, task, actionCallback);
		        } else {
		            processWithoutCallback(text, task);
		        }
		    }
		
		    private void processWithCallback(String text, Task task, ActionCallback actionCallback) throws AIProcessingException {
		        actionCallback.setContext(task);
		        getBaseProcessor().processSingleAction(text, actionCallback);
		    }
		
		    private void processWithoutCallback(String text, Task task) throws AIProcessingException {
		        Object obj = getBaseProcessor().processSingleAction(text);
		        updateTaskWithResult(task, obj);
		    }
		
		    private void updateTaskWithResult(Task task, Object obj) {
		        List<Part> currentParts = task.getStatus().getMessage().getParts();
		        List<Part> partsList = new ArrayList<>(currentParts != null ? currentParts : new ArrayList<>());
		
		        TextPart resultPart = createResultPart(obj);
		        partsList.add(resultPart);
		
		        task.getStatus().setState(TaskState.COMPLETED);
		        task.getStatus().getMessage().setParts(partsList);
		    }
		
		    private TextPart createResultPart(Object obj) {
		        TextPart resultPart = new TextPart();
		        resultPart.setType("text");
		        resultPart.setText(obj != null ? JsonUtils.convertObjectToJson(obj) : "No result");
		        return resultPart;
		    }
		
		    private void handleProcessingError(Task task, String taskId, Exception e) {
		        StringWriter sw = new StringWriter();
		        e.printStackTrace(new PrintWriter(sw));
		
		        TaskStatus failedStatus = createFailedStatus();
		        task.setStatus(failedStatus);
		
		        log.severe("Complete stack trace:\n" + sw.toString());
		        tasks.put(taskId, task);
		    }
		
		    private TaskStatus createFailedStatus() {
		        TaskStatus failedStatus = new TaskStatus(TaskState.FAILED);
		        Message errorMessage = new Message();
		        errorMessage.setRole("agent");
		
		        TextPart errorPart = new TextPart();
		        errorPart.setType("text");
		        errorPart.setText("Processing failed: Access Denied");
		
		        errorMessage.setParts(List.of(errorPart));
		        failedStatus.setMessage(errorMessage);
		        return failedStatus;
		    }
		    protected void processFileTaskLogic(TaskSendParams taskSendParams, Task task, String taskId, ActionCallback actionCallback) {
		        try {
		            List<Part> parts = taskSendParams.getMessage().getParts();
		            FilePart filePart = (FilePart) parts.get(0);
		            FileContent fileInfo = filePart.getFile();
		            String base64EcbodedString = fileInfo.getBytes();
		            // Create an artifact for the file
		
		
		            String originalString = new String(Base64.getDecoder().decode(base64EcbodedString));
		            tasks.put(taskId, task);
		
		                if(actionCallback!= null) {
		                    actionCallback.setContext(task);
		                }
		                FileProcessingInfo info = (FileProcessingInfo) getPromptTransformer().transformIntoPojo(originalString,FileProcessingInfo.class);
		                log.info("taskId " + taskId + " file info " + info);
		                Path tempFile = Files.createTempFile(task.getId()+System.currentTimeMillis()+"web_steps_", ".txt");
		
		
		                String fileName = tempFile.getFileName().toString();
		                log.info("Created temp file: " + fileName);
		
		                // Write steps to file
		                Files.write(tempFile, originalString.getBytes());
		                ScriptResult result  = getScriptProcessor().process(tempFile.toAbsolutePath().toString());
		                String resultString = objectMapper.writeValueAsString(result);
		                log.info(resultString);
		                task.setDetailedAndMessage(TaskState.COMPLETED,resultString);
		                Path archiveDir = Paths.get("archive");
		                Files.createDirectories(archiveDir);
		                Files.move(tempFile, archiveDir.resolve(fileName), StandardCopyOption.REPLACE_EXISTING);
		                log.info("Moved file to archive: " + fileName);
		
		
		        } catch (AIProcessingException | IOException e) {
		            log.warning(e.getMessage());
		        }
		    }
		
		
		    @Override
		    public ResponseEntity<Task> getTask(@RequestParam String id, @RequestParam(defaultValue = "0") int historyLength) {
		        Task task = tasks.get(id);
		        if (task == null) {
		            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Task not found");
		        }
		        //basic get
		        if (historyLength == 0) {
		            return ResponseEntity.ok(task);
		        }
		        else {
		            //return history
		            Task taskWithHistory = new Task();
		            taskWithHistory.setId(task.getId());
		            taskWithHistory.setSessionId(task.getSessionId());
		            taskWithHistory.setStatus(task.getStatus());
		            //get artifacts
		            taskWithHistory.setArtifacts(task.getArtifacts());
		            //get history
		            List<Message> history = task.getHistory();
		            if (history != null) {
		                int start = Math.max(0, history.size() - historyLength);
		                taskWithHistory.setHistory(history.subList(start, history.size()));
		            }
		            return ResponseEntity.ok(taskWithHistory);
		        }
		    }
		
		
		    public ResponseEntity<Task> cancelTask(@RequestBody Map<String, String> body) {
		        String id = body.get("id");
		        Task task = tasks.get(id);
		        if (task == null) {
		            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Task not found");
		        }
		        task.setStatus(new TaskStatus("canceled"));
		        tasks.put(id, task); //update
		        return ResponseEntity.ok(task);
		    }
		
		    public String setTaskPushNotification(TaskSetPushNotificationParams params) {
		        // Retrieve the task from the map
		        Task task = tasks.get(params.getTaskId());
		
		        if (task == null) {
		            throw new IllegalArgumentException("Task not found");
		        }
		
		        // Set the push notification URL
		        task.setPushNotificationUrl(params.getPushNotificationUrl());
		
		        return "Push notification URL set successfully!";
		    }
		
		    public String resubscribeToTask(TaskResubscriptionParams params) {
		        // Retrieve the task from the map
		        Task task = tasks.get(params.getTaskId());
		
		        if (task == null) {
		            throw new IllegalArgumentException("Task not found");
		        }
		
		        // Resubscribe logic (e.g., resetting the task's subscription status)
		        task.setSubscribed(true);
		        task.setSubscriptionDateNow(new Date()); //
		
		        return "Task resubscribed successfully!";
		    }
		
		    public String cancelTask(String taskId) {
		        // Retrieve the task from the map
		        Task task = tasks.get(taskId);
		
		        if (task == null) {
		            throw new IllegalArgumentException("Task not found");
		        }
		
		        // Mark the task as cancelled
		        task.setCancelled(true);
		
		        // Optionally, remove the task from the map if needed
		         tasks.remove(taskId);
		
		        return "Task cancelled successfully!";
		    }
		    public String getTaskPushNotification(TaskGetPushNotificationParams params) {
		        // Retrieve the task from the map
		        Task task = tasks.get(params.getTaskId());
		
		        if (task == null) {
		            throw new IllegalArgumentException("Task not found");
		        }
		
		        // Return the push notification URL
		        return task.getPushNotificationUrl();
		    }
		
		    public ResponseEntity<TaskPushNotificationConfig> setTaskPushNotificationConfig(
		            @RequestBody TaskPushNotificationConfigRequest request) {
		        String id = request.getId();
		        Task task = tasks.get(id);
		        if (task == null) {
		            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Task not found");
		        }
		        // In a real application, you would store this configuration
		        // and use it when sending push notifications.  For this
		        // example, we just store it in the Task object.
		        task.setPushNotificationConfig(request.getPushNotificationConfig());
		        tasks.put(id, task);
		        return ResponseEntity.ok(request.getPushNotificationConfig());
		    }
		
		
		    public ResponseEntity<TaskPushNotificationConfig> getTaskPushNotificationConfig(@RequestParam String id) {
		        Task task = tasks.get(id);
		        if (task == null) {
		            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Task not found");
		        }
		        TaskPushNotificationConfig config = task.getPushNotificationConfig();
		        if (config == null) {
		            return ResponseEntity.notFound().build();
		        }
		        return ResponseEntity.ok(config);
		    }
		    public void sendSseEvent(String taskId, Object event) {
		        SseEmitter emitter = emitters.get(taskId);
		        if (emitter != null) {
		            try {
		                emitter.send(SseEmitter.event().name(MESSAGE).data(event));
		            } catch (IOException e) {
		                // Handle client disconnection or error
		                emitters.remove(taskId);
		                emitter.completeWithError(e);
		                log.severe("Error sending SSE event: " + e.getMessage()); // Log
		            }        }
		    }
		
		
		
		    public SseEmitter sendSubscribeTask(TaskSendSubscribeParams params) {
		        String id = params.getId();
		        SseEmitter emitter = createEmitter(id);
		        Task task = getOrCreateTask(params);
		
		        processTaskAsync(task, emitter, id, params.getMessage());
		
		        return emitter;
		    }
		
		    private SseEmitter createEmitter(String id) {
		        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
		        emitters.put(id, emitter);
		
		        emitter.onCompletion(() -> {
		            emitters.remove(id);
		            log.info("Client disconnected for task: " + id);
		        });
		
		        emitter.onError((throwable) -> {
		            emitters.remove(id);
		            log.info("Error occurred for task " + id + ": " + throwable.getMessage());
		        });
		
		        emitter.onTimeout(() -> {
		            emitters.remove(id);
		            emitter.complete();
		            log.info("Timeout occurred for task: " + id);
		        });
		
		        return emitter;
		    }
		
		    private Task getOrCreateTask(TaskSendSubscribeParams params) {
		        String taskId = params.getId();
		        Message message = params.getMessage();
		
		        Task task = tasks.get(taskId);
		        if (task != null) {
		            List<Message> history = task.getHistory() != null ? new ArrayList<>(task.getHistory()) : new ArrayList<>();
		            history.add(message);
		            task.setHistory(history);
		            return task;
		        }
		
		        task = new Task();
		        task.setId(taskId);
		        String sessionId = Optional.ofNullable(params.getSessionId()).filter(s -> !s.isEmpty()).orElse(UUID.randomUUID().toString());
		        task.setSessionId(sessionId);
		        task.setStatus(new TaskStatus(TaskState.SUBMITTED));
		        task.setHistory(List.of(message));
		
		        tasks.put(taskId, task);
		        return task;
		    }
		
		    private void processTaskAsync(Task task, SseEmitter emitter, String id, Message message) {
		        nonBlockingService.execute(() -> {
		            try {
		                List<Part> parts = message.getParts();
		                if (parts != null && !parts.isEmpty()) {
		                    Part part = parts.get(0);
		                    if (part instanceof TextPart textPart && "text".equals(textPart.getType())) {
		                        String text = textPart.getText();
		                        SSEEmitterCallback callback = new SSEEmitterCallback(id, emitter);
		                        callback.setContext(task);
		                        getBaseProcessor().processSingleAction(text, callback);
		                    }
		                }
		            } catch (Exception e) {
		                emitter.completeWithError(e);
		            }
		        });
		    }
		
		    public SseEmitter resubscribe(String id) {
		        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
		        emitters.put(id, emitter);
		
		        Task task = tasks.get(id);
		        if (task != null) {
		            //send current status
		            try {
		                emitter.send(SseEmitter.event().name(MESSAGE).data(new TaskStatusUpdateEvent(id, task.getStatus(), false)));
		                //send all artifacts
		                if (task.getArtifacts() != null) {
		                    for (Artifact artifact : task.getArtifacts()) {
		                        emitter.send(SseEmitter.event().name(MESSAGE).data(new TaskArtifactUpdateEvent(id, artifact)));
		                    }
		                }
		
		            } catch (IOException e) {
		                emitters.remove(id);
		                emitter.completeWithError(e);
		                log.severe("Error re-subscribing" + e.getMessage());
		            }
		        }
		        else {
		            try {
		                emitter.send(SseEmitter.event().name(MESSAGE).data("Task does not exist"));
		                emitter.complete();
		                emitters.remove(id);
		            } catch (IOException e) {
		                log.severe("Error sending task "+MESSAGE + e.getMessage());
		            }
		
		        }
		
		        emitter.onCompletion(() -> {
		            emitters.remove(id);
		            log.severe("Client disconnected on resubscribe: " + id);
		        });
		        emitter.onError(throwable -> {
		            emitters.remove(id);
		            log.severe("Error on resubscribe for task " + id + ": " + throwable.getMessage());
		        });
		        emitter.onTimeout(() -> {
		            emitters.remove(id);
		            emitter.complete();
		            log.severe("Timeout on resubscribe for task: " + id);
		        });
		        return emitter;
		    }
		
		    public JsonUtils getUtils() {
		        return utils;
		    }
		
		    public void setUtils(JsonUtils utils) {
		        this.utils = utils;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\DynamicAgentCardController.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		import com.t4a.api.AIAction;
		import com.t4a.api.GroupInfo;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.transform.GeminiV2PromptTransformer;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.a2a.domain.*;
		import org.springframework.http.ResponseEntity;
		
		
		import java.util.ArrayList;
		import java.util.List;
		import java.util.Map;
		
		/**
		 * This controller serves the dynamic agent card for the TicketQueen agent.
		 * It provides information about the agent's capabilities, skills, and actions.
		 * Generates the agent card dynamically based on the available actions and groups rather than
		 * hardcoding it.
		 */
		
		public class DynamicAgentCardController implements A2AAgentCardController {
		
		    public static final String CONTENT_TYPE = "application/json";
		    private PromptTransformer promptTransformer = new GeminiV2PromptTransformer();
		
		    @Override
		    public PromptTransformer getPromptTransformer() {
		        return promptTransformer;
		    }
		
		    public ResponseEntity<AgentCard> getAgentCard() {
		        AgentCard agentCard = new AgentCard();
		        agentCard.setName("TicketQueen : Ticket Booking Agent");
		        Map<String, AIAction> actions = PredictionLoader.getInstance().getPredictions();
		        StringBuilder description = new StringBuilder("This agent can help you with: ");
		        actions.values().forEach(action ->
		            description.append(action.getActionName())
		                    .append(" - ")
		                    .append(action.getDescription())
		                    .append(", ")
		        );
		
		        // Remove trailing comma and space
		        if (description.length() > 2) {
		            description.setLength(description.length() - 2);
		        }
		
		        agentCard.setDescription(description.toString());
		
		
		        agentCard.setUrl("http://localhost:8080"); //  Replace with actual URL
		        agentCard.setProvider(new Provider("Ticket Corp", "https://github.com/vishalmysore/choturobo"));
		        agentCard.setVersion("1.0.0");
		        agentCard.setDocumentationUrl("https://github.com/vishalmysore/Tools4AI");  // Replace
		        agentCard.setCapabilities(new Capabilities(false, false, false));
		        agentCard.setAuthentication(new Authentication(new String[]{"Bearer"}));
		        agentCard.setDefaultInputModes(new String[]{"text/plain"});
		        agentCard.setDefaultOutputModes(new String[]{CONTENT_TYPE});
		
		        Map<GroupInfo, String> groupActions = PredictionLoader.getInstance().getActionGroupList().getGroupActions();
		        List<Skill> skills = new ArrayList<>();
		
		        for (Map.Entry<GroupInfo, String> entry : groupActions.entrySet()) {
		            GroupInfo groupInfo = entry.getKey();
		            String actionTags = entry.getValue();
		
		            Skill skill = new Skill();
		            skill.setId(groupInfo.getGroupName().toLowerCase().replace(" ", "-"));
		            skill.setName(groupInfo.getGroupName());
		            skill.setDescription(groupInfo.getGroupDescription());
		
		            // Convert action names to tags
		            String[] tags = actionTags != null ?
		                    actionTags.toLowerCase().split(",") :
		                    new String[]{groupInfo.getGroupName().toLowerCase()};
		
		            skill.setTags(tags);
		            skill.setExamples(new String[]{"Example for " + groupInfo.getGroupName()});
		            skill.setInputModes(new String[]{CONTENT_TYPE});
		            skill.setOutputModes(new String[]{CONTENT_TYPE});
		            skills.add(skill);
		        }
		
		        agentCard.setSkills(List.of(skills.toArray(new Skill[0])));
		
		        return ResponseEntity.ok(agentCard);
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\FileProcessingInfo.java'>
		package io.github.vishalmysore.a2a.server;
		
		import com.t4a.annotations.Prompt;
		import lombok.*;
		
		/**
		 * This will be send to AI to decide the type of the file to be proceessed and decide
		 * what to do
		 */
		@Data
		@Getter
		@Setter
		@NoArgsConstructor
		@AllArgsConstructor
		@ToString
		public class FileProcessingInfo {
		    @Prompt(describe = "What type of processing will be required for the content? your options are only one of these Selenium,Non-Selenium or FileIO")
		    String typeOfProcessingRequired;
		    @Prompt(describe = "check each line? can each line in this  be parallel processed? your options are only one of these true or false")
		    boolean parallelProcessingAllowed;
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\RealTimeAgentCardController.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		
		import com.t4a.api.AIAction;
		import com.t4a.api.GenericJavaMethodAction;
		import com.t4a.api.GroupInfo;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.transform.GeminiV2PromptTransformer;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.a2a.domain.AgentCard;
		import jakarta.annotation.PostConstruct;
		import lombok.Getter;
		import lombok.extern.java.Log;
		import org.springframework.beans.factory.annotation.Value;
		import org.springframework.context.ApplicationContext;
		import org.springframework.http.ResponseEntity;
		
		
		import java.lang.reflect.Method;
		import java.net.InetAddress;
		import java.net.UnknownHostException;
		import java.util.Map;
		import java.util.Properties;
		
		/**
		 * This controller serves the real-time agent card for the TicketQueen agent.
		 * It provides information about the agent's capabilities, skills, and actions.
		 * Generates the agent card dynamically based on the available actions and groups rather than
		 * hardcoding it.
		 * In real applicaiton you can extend his class and call the super class
		 */
		
		@Log
		public class RealTimeAgentCardController implements A2AAgentCardController {
		
		    private PromptTransformer promptTransformer;
		
		
		    public static final String WELL_KNOWN_PATH = "/.well-known/";
		    public static final String AGENT_PATH ="/agent.json";
		
		    @Getter
		    private AgentCard cachedAgentCard;
		    @Value("${server.port:8080}")
		    private String serverPort;
		
		    public RealTimeAgentCardController() {
		        promptTransformer = new GeminiV2PromptTransformer();
		    }
		
		    public RealTimeAgentCardController(ApplicationContext context) {
		
		        PredictionLoader.getInstance(context);
		        promptTransformer = new GeminiV2PromptTransformer();
		    }
		    public boolean isMethodAllowed(Method method)    {
		        log.info(method.getName());
		        return true;
		    }
		    @Override
		    public PromptTransformer getPromptTransformer() {
		        return promptTransformer;
		    }
		
		    @PostConstruct
		    public void init() {
		        promptTransformer = PredictionLoader.getInstance().createOrGetPromptTransformer();
		        Map<GroupInfo, String> groupActions = PredictionLoader.getInstance().getActionGroupList().getGroupActions();
		        Map<String, AIAction> predictions = PredictionLoader.getInstance().getPredictions();
		        StringBuilder realTimeDescription = new StringBuilder("This agent provides the following capabilities: ");
		
		        for (Map.Entry<GroupInfo, String> entry : groupActions.entrySet()) {
		            GroupInfo group = entry.getKey();
		            String[] actionNames = entry.getValue().split(",");
		            StringBuilder methodNames = new StringBuilder();
		
		            for (String actionName : actionNames) {
		                AIAction action = predictions.get(actionName.trim());
		                if (action instanceof GenericJavaMethodAction methodAction) {
		                    Method m = methodAction.getActionMethod();
		                    if (isMethodAllowed(m)) {
		                        methodNames.append(",");
		                        methodNames.append(actionName.trim());
		                    }
		                }
		            }
		            realTimeDescription.append(group.getGroupName())
		                    .append(" (")
		                    .append(group.getGroupDescription())
		                    .append("), with actions: ")
		                    .append(methodNames)
		                    .append("; ");
		        }
		
		        if (realTimeDescription.length() > 2) {
		            realTimeDescription.setLength(realTimeDescription.length() - 2);
		        }
		
		        String finalDescription = realTimeDescription.toString();
		
		        try {
		            if(groupActions.isEmpty()) {
		                log.warning("No actions found for the agent card");
		                AgentCard card = new AgentCard();
		                storeCard(card);
		
		            } else {
		                AgentCard card = (AgentCard) promptTransformer.transformIntoPojo(
		                        "use this description and also populate skills in detail " + finalDescription,
		                        AgentCard.class);
		                  storeCard(card);
		
		            }
		            String hostName = InetAddress.getLocalHost().getHostName();
		            this.cachedAgentCard.setUrl("http://" + hostName + ":" + serverPort);
		            poplateCardFromProperties(this.cachedAgentCard);
		        } catch (AIProcessingException e) {
		            log.severe("The skills are not populate in the agent card as actions are more in number \n you can either try with different processor \n" +
		                    " or you can populate skills individually and add to agent card , or it could be that AI key is not initialized "+e.getMessage());
		        } catch (UnknownHostException e) {
		            log.warning("host not knwon set the url manually card.setUrl");
		        }
		    }
		
		
		   public void storeCard(AgentCard card) {
		        this.cachedAgentCard = card;
		    }
		
		    private boolean isNonEmptyString(String value) {
		        return value != null && !value.trim().isEmpty();
		    }
		
		    public void poplateCardFromProperties(AgentCard card) {
		        Map<Object, Object> tools4AI = PredictionLoader.getInstance().getTools4AIProperties();
		
		        // Check and set description
		        String cardDescription = (String) tools4AI.get("a2a.card.description");
		        if (isNonEmptyString(cardDescription)) {
		            card.setDescription(cardDescription);
		        }
		
		        // Check and set name
		        String cardName = (String) tools4AI.get("a2a.card.name");
		        if (isNonEmptyString(cardName)) {
		            card.setName(cardName);
		        }
		
		        // Check and set capabilities
		        Boolean streaming = (Boolean) tools4AI.get("a2a.card.capabilities.streaming");
		        if (streaming != null) {
		            card.getCapabilities().setStreaming(streaming);
		        }
		
		        Boolean pushNotifications = (Boolean) tools4AI.get("a2a.card.capabilities.pushNotifications");
		        if (pushNotifications != null) {
		            card.getCapabilities().setPushNotifications(pushNotifications);
		        }
		
		        Boolean stateTransitionHistory = (Boolean) tools4AI.get("a2a.card.capabilities.stateTransitionHistory");
		        if (stateTransitionHistory != null) {
		            card.getCapabilities().setStateTransitionHistory(stateTransitionHistory);
		        }
		
		        // Check and set URL
		        String url = (String) tools4AI.get("a2a.card.url");
		        if (isNonEmptyString(url)) {
		            card.setUrl(url);
		        }
		
		        // Check and set version
		        String version = (String) tools4AI.get("a2a.card.version");
		        if (isNonEmptyString(version)) {
		            card.setVersion(version);
		        }
		
		        // Check and set documentation URL
		        String documentationUrl = (String) tools4AI.get("a2a.card.documentationUrl");
		        if (isNonEmptyString(documentationUrl)) {
		            card.setDocumentationUrl(documentationUrl);
		        }
		
		        // Check and set default output modes
		        String defaultOutputModes = (String) tools4AI.get("a2a.card.defaultOutputModes");
		        if (isNonEmptyString(defaultOutputModes)) {
		            card.setDefaultOutputModes(defaultOutputModes.split(","));
		        }
		
		        // Check and set default input modes
		        String defaultInputModes = (String) tools4AI.get("a2a.card.defaultInputModes");
		        if (isNonEmptyString(defaultInputModes)) {
		            card.setDefaultInputModes(defaultInputModes.split(","));
		        }
		
		        String organization = (String) tools4AI.get("a2a.card.provider.organization");
		        if (isNonEmptyString(organization)) {
		            card.getProvider().setOrganization(organization);
		        }
		
		// Set provider URL
		        String providerUrl = (String) tools4AI.get("a2a.card.provider.url");
		        if (isNonEmptyString(providerUrl)) {
		            card.getProvider().setUrl(providerUrl);
		        }
		
		// Set authentication schemes
		        String authSchemes = (String) tools4AI.get("a2a.card.authentication.schemes");
		        if (isNonEmptyString(authSchemes)) {
		            card.getAuthentication().setSchemes(authSchemes.split(","));
		        }
		
		// Set authentication credentials
		        String authCredentials = (String) tools4AI.get("a2a.card.authentication.credentials");
		        if (isNonEmptyString(authCredentials)) {
		            card.getAuthentication().setCredentials(authCredentials);
		        }
		    }
		
		    public ResponseEntity<AgentCard> getAgentCard() {
		        return ResponseEntity.ok(cachedAgentCard);
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\SpringAwareAgentCardController.java'>
		package io.github.vishalmysore.a2a.server;
		
		
		import org.springframework.context.ApplicationContext;
		
		/**
		 * SpringAwareAgentCardController is a controller that handles agent card-related operations.
		 * It extends the RealTimeAgentCardController and is aware of the Spring application context.
		 */
		public class SpringAwareAgentCardController extends RealTimeAgentCardController{
		    public SpringAwareAgentCardController(ApplicationContext context) {
		        super(context);
		    }
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\SSEEmitterCallback.java'>
		package io.github.vishalmysore.a2a.server;
		
		import com.t4a.detect.ActionState;
		import io.github.vishalmysore.a2a.domain.*;
		import io.github.vishalmysore.common.A2AActionCallBack;
		import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
		
		import java.io.IOException;
		import java.util.List;
		
		
		public class SSEEmitterCallback extends A2AActionCallBack {
		
		    private SseEmitter sseEmitter;
		    private Object context ;
		    private String status;
		    private String taskId;
		
		
		
		    public SSEEmitterCallback(String taskId, SseEmitter sseEmitter) {
		        this.sseEmitter = sseEmitter;
		        this.taskId = taskId;
		
		    }
		
		
		    @Override
		    public void setContext(Object context) {
		        this.context = context;
		    }
		
		    @Override
		    public Object getContext() {
		        return context;
		    }
		
		
		
		    @Override
		    public void sendtStatus(String status, ActionState state){
		        this.status = status;
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText(status);
		
		        Message message = new Message();
		        message.setRole("agent");
		        message.setParts(List.of(textPart));
		
		        TaskState taskState = TaskState.valueOf(state.name());
		        TaskStatus processingStatus = new TaskStatus(taskState);
		        processingStatus.setMessage(message);
		        SendTaskStreamingResponse response = new SendTaskStreamingResponse();
		        response.setId(taskId);
		        response.setResult((new TaskStatusUpdateEvent(taskId, processingStatus, false)));
		        try {
		            sseEmitter.send(SseEmitter.event().name("message").data(response));
		        } catch (IOException e) {
		            throw new RuntimeException(e);
		        }
		    }
		
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\a2a\server\TaskControllerQualifiers.java'>
		package io.github.vishalmysore.a2a.server;
		
		
		
		public class TaskControllerQualifiers {
		    public static final String DYNAMIC_TASK_CONTROLLER = "dynamicTaskController";
		    public static final String FILEBASED_TASK_CONTROLLER  = "filebasedController";
		    public static final String DBBASED_TASK_CONTROLLER  = "dbbasedController";
		
		    private TaskControllerQualifiers() {
		        // private constructor to prevent instantiation
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\common\A2AActionCallBack.java'>
		package io.github.vishalmysore.common;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.detect.ActionState;
		import io.github.vishalmysore.a2a.domain.Task;
		import io.github.vishalmysore.a2a.domain.TaskState;
		
		/**
		 * A2AActionCallBack is an interface that extends ActionCallback.
		 * It provides default implementations for the setType and getType methods,
		 * setting the type to "A2A". The AI processor will pass this to the action class which can use
		 * this to set the Task detaails .
		 */
		public class A2AActionCallBack implements ActionCallback {
		
		    private String status;
		    private Object context;
		
		    @Override
		    public void setContext(Object obj) {
		        this.context = obj;
		    }
		
		    @Override
		    public Object getContext() {
		        return context;
		    }
		
		
		    @Override
		    public String setType(String type) {
		        return CallBackType.A2A.name();
		    }
		
		
		
		    @Override
		    public  String getType() {
		        return CallBackType.A2A.name();
		    };
		
		    @Override
		    public void sendtStatus(String status, ActionState state) {
		        ((Task) getContext()).setDetailedAndMessage(TaskState.forValue(state.getValue()), status );
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\common\Agent.java'><![CDATA[
		package io.github.vishalmysore.common;
		
		
		import com.fasterxml.jackson.core.type.TypeReference;
		import com.fasterxml.jackson.databind.ObjectMapper;
		import io.github.vishalmysore.mcp.domain.JSONRPCResponse;
		import io.github.vishalmysore.mcp.domain.MCPGenericResponse;
		
		import java.io.BufferedReader;
		import java.io.IOException;
		import java.io.InputStreamReader;
		import java.net.HttpURLConnection;
		import java.net.URL;
		import java.nio.charset.StandardCharsets;
		import java.util.stream.Collectors;
		
		public interface Agent {
		
		    void connect(String url, String token);
		    default void connect(String url) {
		        connect(url, null);
		    }
		    void disconnect();
		    AgentInfo getInfo();
		    boolean isConnected();
		
		    URL getServerUrl();
		
		    ObjectMapper getMapper();
		
		    String getType();
		
		    default <T> T invokeRPC(CommonClientRequest request, Class<T> responseType) {
		        if (!isConnected() || getServerUrl() == null) {
		            throw new IllegalStateException("Agent not connected");
		        }
		
		        return getRemoteData(request, responseType);
		    }
		
		
		
		    default <T> MCPGenericResponse<T> getRemoteData(CommonClientRequest request, TypeReference<MCPGenericResponse<T>> typeRef) {
		        try {
		            HttpURLConnection conn = (HttpURLConnection) getServerUrl().openConnection();
		            conn.setRequestMethod("POST");
		            conn.setRequestProperty("Content-Type", "application/json");
		            conn.setRequestProperty("Accept", "application/json");
		            conn.setDoOutput(true);
		
		            String jsonRequest = getMapper().writeValueAsString(request);
		            try (var os = conn.getOutputStream()) {
		                os.write(jsonRequest.getBytes(StandardCharsets.UTF_8));
		            }
		
		            if (conn.getResponseCode() >= 400) {
		                throw new RuntimeException("Request failed: HTTP " + conn.getResponseCode());
		            }
		
		            try (BufferedReader br = new BufferedReader(
		                    new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
		                String response = br.lines().collect(Collectors.joining());
		                return getMapper().readValue(response, typeRef);  // return full response wrapper
		            }
		
		        } catch (IOException e) {
		            throw new RuntimeException("Request failed - Probably sever is down "+getInfo(), e);
		        }
		    }
		
		
		    default  <T> T getRemoteData(CommonClientRequest request, Class<T> responseType) {
		        try {
		            HttpURLConnection conn = (HttpURLConnection) getServerUrl().openConnection();
		            conn.setRequestMethod("POST");
		            conn.setRequestProperty("Content-Type", "application/json");
		            conn.setRequestProperty("Accept", "application/json");
		            conn.setDoOutput(true);
		
		
		            String jsonRequest = getMapper().writeValueAsString(request);
		
		            try (var os = conn.getOutputStream()) {
		                byte[] input = jsonRequest.getBytes(StandardCharsets.UTF_8);
		                os.write(input, 0, input.length);
		            }
		
		            if (conn.getResponseCode() >= 400) {
		                throw new RuntimeException("Request failed: HTTP " + conn.getResponseCode());
		            }
		
		            try (BufferedReader br = new BufferedReader(
		                    new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))) {
		                String response = br.lines().collect(Collectors.joining());
		                return getMapper().readValue(response, responseType);
		            }
		
		        } catch (IOException e) {
		            throw new RuntimeException("Request failed", e);
		        }
		    }
		
		    CommonClientResponse remoteMethodCall(String query);
		    CommonClientResponse remoteMethodCall(String remoteMethodName,String query);
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\common\AgentIdentity.java'>
		package io.github.vishalmysore.common;
		
		import com.t4a.annotations.Prompt;
		import lombok.*;
		
		import java.util.UUID;
		
		@Getter
		@Setter
		@ToString(of = {"agentUniqueIDTobeUsedToIdentifyTheAgent", "allTheCapabilitiesOfTheAgent"})
		@EqualsAndHashCode(onlyExplicitlyIncluded = true)
		public class AgentIdentity {
		    @EqualsAndHashCode.Include
		    @Prompt(describe = "Unique ID to identify the agent to be used for the query")
		    private String agentUniqueIDTobeUsedToIdentifyTheAgent;
		    @Prompt(ignore = true)
		    private AgentInfo allTheCapabilitiesOfTheAgent;
		    @Prompt(ignore = true)
		    private String url;
		    @Builder
		    public AgentIdentity(AgentInfo info, String url) {
		        this.agentUniqueIDTobeUsedToIdentifyTheAgent = UUID.randomUUID().toString();
		        this.allTheCapabilitiesOfTheAgent = info;
		        this.url = url;
		    }
		
		    // Keep existing all-args constructor
		    public AgentIdentity(String uniqueId, AgentInfo info, String url) {
		        this.agentUniqueIDTobeUsedToIdentifyTheAgent = uniqueId;
		        this.allTheCapabilitiesOfTheAgent = info;
		        this.url = url;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\common\AgentInfo.java'>
		package io.github.vishalmysore.common;
		
		import io.github.vishalmysore.a2a.domain.AgentCard;
		import io.github.vishalmysore.mcp.domain.CallToolResult;
		import io.github.vishalmysore.mcp.domain.ListToolsResult;
		
		//marker interface for agent information
		public interface AgentInfo {
		
		    default String getAgentCapabilities() {
		        String capabilities = "Capabilities: ";
		        if (this instanceof AgentCard) {
		            capabilities = ((AgentCard) this).getCapabilities().toString();
		        } else if (this instanceof ListToolsResult) {
		            capabilities = ((ListToolsResult) this).getTools().toString();
		        }
		        return capabilities;
		    }
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\common\CallBackType.java'>
		package io.github.vishalmysore.common;
		
		public enum CallBackType {
		    MCP,    // Protocol for LLM communication
		    A2A     // App-to-App communication
		}</file>
	<file path='src\main\java\io\github\vishalmysore\common\ClientRegistryForAgents.java'><![CDATA[
		package io.github.vishalmysore.common;
		
		import java.util.HashMap;
		import java.util.Map;
		import java.util.stream.Collectors;
		import lombok.extern.java.Log;
		
		/**
		 * Registry for all the agents and cards for both MCP and A2A
		 * I'd like to propose a flexible enhancement to the A2A protocol to support client-specific agent experiences. Currently, AgentCard objects are generally served uniformly to all clients, regardless of the context or identity of the requesting client. In many real-world applications, however, different clients may need different views, capabilities, or even agent skillsets based on:
		 *
		 * Their identity (e.g., clientId)
		 *
		 * Their type (e.g., mobile vs. desktop, internal vs. external)
		 *
		 * Runtime context (e.g., device info, region, tenant)
		 *
		 * 💡 Proposal Summary
		 * Introduce a ClientInfo object in the A2A request schema that allows clients to optionally identify themselves, enabling the server to tailor AgentCard responses accordingly.
		 *
		 * Example Schema:
		 * json
		 * Copy
		 * Edit
		 * "clientInfo": {
		 *   "type": "object",
		 *   "properties": {
		 *     "clientId": { "type": "string" },
		 *     "clientType": { "type": "string" },
		 *     "deviceId": { "type": "string" },
		 *     "tags": {
		 *       "type": "array",
		 *       "items": { "type": "string" }
		 *     }
		 *   },
		 *   "required": ["clientId"]
		 * }
		 * Optionally, enhance AgentCard with:
		 * json
		 * Copy
		 * Edit
		 * "audience": {
		 *   "type": "array",
		 *   "items": { "type": "string" },
		 *   "description": "List of client IDs or tags this card is intended for."
		 * }
		 * 🧠 Use Cases
		 * Multi-tenant SaaS: Serve different capabilities to clients based on their subscription plan.
		 *
		 * Context-aware agents: Deliver simplified AgentCards to mobile clients and full-featured ones to desktop.
		 *
		 * Security filtering: Hide certain skills or capabilities for restricted clients or user roles.
		 *
		 * A/B testing: Dynamically adjust agent exposure based on experiment tags.
		 *
		 * ✅ Benefits
		 * Backward-compatible: Clients that don’t provide clientInfo can continue receiving the default card.
		 *
		 * Enhances personalization and UX.
		 *
		 * Enables richer agent ecosystem logic (like context-specific cards or private/internal agent networks).
		 */
		@Log
		public class ClientRegistryForAgents {
		    private Map<AgentInfo, Agent> agents;
		
		    public ClientRegistryForAgents() {
		        this.agents = new HashMap<>();
		    }
		
		    /**
		     * Add an agent to the registry
		     * @param agent The agent to add
		     * @return true if added successfully, false if agent was null or couldn't be added
		     */
		    public boolean addAgent(Agent agent) {
		        if (agent == null) {
		            log.warning("Attempted to add null agent to registry");
		            return false;
		        }
		
		        AgentInfo info = agent.getInfo();
		        if (info == null) {
		            log.warning("Agent has null info, cannot add to registry");
		            return false;
		        }
		
		        agents.put(info, agent);
		        log.info("Added agent: " + info);
		        return true;
		    }
		
		    /**
		     * Get a comma-separated list of all agent info
		     * @return String containing comma-separated agent info
		     */
		    public String getAgentsInfo() {
		        if (agents.isEmpty()) {
		            return "";
		        }
		        return agents.keySet().stream()
		            .map(Object::toString)
		            .collect(Collectors.joining(", "));
		    }
		
		    /**
		     * Retrieve an agent by its info
		     * @param info The AgentInfo to look up
		     * @return The agent if found, null otherwise
		     */
		    public Agent retrieveAgent(AgentInfo info) {
		        if (info == null) {
		            log.warning("Attempted to retrieve agent with null info");
		            return null;
		        }
		        return agents.get(info);
		    }
		
		    /**
		     * Get the total number of registered agents
		     * @return The number of agents in the registry
		     */
		    public int getAgentCount() {
		        return agents.size();
		    }
		
		    /**
		     * Check if an agent exists in the registry
		     * @param info The AgentInfo to check
		     * @return true if the agent exists, false otherwise
		     */
		    public boolean hasAgent(AgentInfo info) {
		        if (info == null) {
		            return false;
		        }
		        return agents.containsKey(info);
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\common\CommonClientRequest.java'>
		package io.github.vishalmysore.common;
		
		/**
		 * Marker interface for client requests.
		 */
		public interface CommonClientRequest {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\common\CommonClientResponse.java'><![CDATA[
		package io.github.vishalmysore.common;
		
		import io.github.vishalmysore.a2a.domain.SendTaskResponse;
		import io.github.vishalmysore.a2a.domain.Task;
		import io.github.vishalmysore.a2a.domain.TextPart;
		import io.github.vishalmysore.mcp.domain.CallToolResult;
		import io.github.vishalmysore.mcp.domain.TextContent;
		
		public interface CommonClientResponse {
		
		    default String getTextResult() {
		        if (this instanceof CallToolResult) {
		            CallToolResult toolResult = (CallToolResult) this;
		            Object content = toolResult.getContent();
		
		            if (content instanceof TextContent) {
		                return ((TextContent) content).getText();
		            }
		
		            if (content instanceof java.util.List<?>) {
		                java.util.List<?> list = (java.util.List<?>) content;
		                if (!list.isEmpty() && list.get(0) instanceof TextContent) {
		                    return ((TextContent) list.get(0)).getText();
		                }
		            }
		
		            return "";
		        } else if (this instanceof SendTaskResponse) {
		            SendTaskResponse taskResponse = (SendTaskResponse) this;
		            var status = taskResponse.getResult().getStatus();
		            if (status != null && status.getMessage() != null) {
		                var parts = status.getMessage().getParts();
		                if (parts != null && !parts.isEmpty()) {
		                    Object lastPart = parts.get(parts.size() - 1);
		                    if (lastPart instanceof TextPart) {
		                        return ((TextPart) lastPart).getText();
		                    }
		                }
		            }
		
		            return "";
		        } else if (this instanceof Task) {
		            Task task = (Task) this;
		            var status = task.getStatus();
		            if (status != null && status.getMessage() != null) {
		                var parts = status.getMessage().getParts();
		                if (parts != null && !parts.isEmpty()) {
		                    Object lastPart = parts.get(parts.size() - 1);
		                    if (lastPart instanceof TextPart) {
		                        return ((TextPart) lastPart).getText();
		                    }
		                }
		            }
		            return "";
		        } else {
		            throw new IllegalStateException("Unexpected response type inside CommonClientResponse class: " + this.getClass());
		        }
		    }
		
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\common\MCPActionCallback.java'><![CDATA[
		package io.github.vishalmysore.common;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.detect.ActionState;
		import io.github.vishalmysore.a2a.domain.Task;
		import io.github.vishalmysore.a2a.domain.TaskState;
		import io.github.vishalmysore.mcp.domain.CallToolResult;
		import io.github.vishalmysore.mcp.domain.TextContent;
		
		import java.util.ArrayList;
		import java.util.List;
		
		/**
		 * This interface is used to define the callback type for the Model Context Protocol (MCP). This will be passed
		 * to the AIProcessor to handle the callback for the MCP. The AI processor will set the context and other parameters
		 * and pass it to the action clsas which can use it to set real time values
		 */
		public class MCPActionCallback implements ActionCallback  {
		
		    private String status;
		    private Object context;
		    @Override
		    public String setType(String type) {
		        return CallBackType.MCP.name();
		    }
		
		    @Override
		    public void setContext(Object context) {
		     this.context= context;
		    }
		
		    @Override
		    public Object getContext() {
		        return context;
		    }
		
		    @Override
		    public  String getType() {
		        return CallBackType.MCP.name();
		    };
		
		    @Override
		    public void sendtStatus(String status, ActionState state) {
		
		        List list =  ((CallToolResult) getContext()).getContent();
		        if (list == null) {
		            list = new ArrayList<>();
		            ((CallToolResult) getContext()).setContent(list);
		        }
		        TextContent textContent = new TextContent();
		        textContent.setType("text");
		        textContent.setText(status+state.getValue());
		        list.add(textContent);
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\common\MCPResultsCallBack.java'>
		package io.github.vishalmysore.common;
		
		import com.t4a.detect.ActionState;
		
		public class MCPResultsCallBack extends MCPActionCallback{
		    private String status;
		    private Object context;
		
		    @Override
		    public void setContext(Object obj) {
		        this.context = obj;
		    }
		
		    @Override
		    public Object getContext() {
		        return context;
		    }
		
		    @Override
		    public void sendtStatus(String status, ActionState state) {
		
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\common\server\JsonRpcController.java'><![CDATA[
		package io.github.vishalmysore.common.server;
		
		
		
		import com.fasterxml.jackson.databind.ObjectMapper;
		import com.t4a.predict.PredictionLoader;
		import io.github.vishalmysore.a2a.domain.*;
		import io.github.vishalmysore.a2a.server.A2ARPCController;
		import io.github.vishalmysore.a2a.server.A2ATaskController;
		import io.github.vishalmysore.a2a.server.DyanamicTaskContoller;
		import io.github.vishalmysore.mcp.domain.*;
		import io.github.vishalmysore.mcp.server.MCPToolsController;
		import lombok.extern.java.Log;
		import org.springframework.context.ApplicationContext;
		import org.springframework.http.HttpStatus;
		import org.springframework.http.ResponseEntity;
		import org.springframework.web.bind.annotation.RequestBody;
		import org.springframework.web.server.ResponseStatusException;
		
		import java.util.ArrayList;
		import java.util.HashMap;
		import java.util.List;
		import java.util.Map;
		
		/**
		 * JsonRpcController handles JSON-RPC requests and routes them to the appropriate methods in the TaskController.
		 * This is the main entry point for the JSON-RPC API for Google A2A clients
		 * You need to look at the sample to see how it works
		 */
		
		@Log
		public class JsonRpcController implements A2ARPCController {
		
		
		
		    /**
		     * The DynamicTaskController is responsible for handling dynamic task-related operations.
		     * IT can handle any task wheter ticket or food prefernce etc
		     */
		    private DyanamicTaskContoller dynamicTaskController;
		
		    private MCPToolsController  mcpToolsController;
		
		    public JsonRpcController() {
		        dynamicTaskController = new DyanamicTaskContoller();
		        mcpToolsController = new MCPToolsController();
		        mcpToolsController.init();
		    }
		
		    public JsonRpcController(ApplicationContext applicationContext) {
		        PredictionLoader.getInstance(applicationContext);
		        dynamicTaskController = new DyanamicTaskContoller();
		        mcpToolsController = new MCPToolsController();
		        mcpToolsController.init();
		    }
		
		    public A2ATaskController getTaskController() {
		        return dynamicTaskController;
		    }
		
		    public MCPToolsController getMCPToolsController() {
		        return mcpToolsController;
		    }
		
		    public void setMcpToolsController(MCPToolsController mcpToolsController) {
		        this.mcpToolsController = mcpToolsController;
		    }
		
		    /**
		     * This method handles JSON-RPC requests. It is the main entry point for the JSON-RPC API.
		     * Will optimize this method later     *
		     */
		    public Object handleRpc(@RequestBody JsonRpcRequest request) {
		        String method = request.getMethod();
		        Object params = request.getParams();
		        log.info(request.toString());
		        preProcessing(method,params);
		        Object result ;
		        switch (method) {
		            case "tasks/send":
		                TaskSendParams sendParams = new ObjectMapper().convertValue(params, TaskSendParams.class);
		                result = getTaskController().sendTask(sendParams,null,false);
		                postProcessing(method,result);
		                return result;
		            case "tasks/get":
		                TaskQueryParams queryParams = new ObjectMapper().convertValue(params, TaskQueryParams.class);
		                result = getTaskController().getTask(queryParams.getId(), queryParams.getHistoryLength());
		                postProcessing(method,result);
		                return result;
		            case "tasks/sendSubscribe":
		                TaskSendSubscribeParams sendSubscribeParams = new ObjectMapper().convertValue(params, TaskSendSubscribeParams.class);
		
		                 result = getTaskController().sendSubscribeTask(sendSubscribeParams);
		                postProcessing(method,result);
		                return result;
		            case "tasks/cancel":
		                TaskCancelParams cancelParams = new ObjectMapper().convertValue(params, TaskCancelParams.class);
		                result = getTaskController().cancelTask(cancelParams.getId());
		                postProcessing(method,result);
		                return result;
		            case "tasks/setPushNotification":
		                TaskSetPushNotificationParams setPushParams = new ObjectMapper().convertValue(params, TaskSetPushNotificationParams.class);
		
		                result = getTaskController().setTaskPushNotification(setPushParams);
		                postProcessing(method,result);
		                return result;
		            case "tasks/getPushNotification":
		                TaskGetPushNotificationParams getPushParams = new ObjectMapper().convertValue(params, TaskGetPushNotificationParams.class);
		
		                result = getTaskController().getTaskPushNotification(getPushParams);
		                postProcessing(method,result);
		                return result;
		            case "tasks/resubscribe":
		                TaskResubscriptionParams resubParams = new ObjectMapper().convertValue(params, TaskResubscriptionParams.class);
		                result = getTaskController().resubscribeToTask(resubParams);
		                postProcessing(method,result);
		                return result;
		            case "initialize":
		               {
		                Map<String, Object> response = new HashMap<>();
		                Map<String, Object> mcpResult = new HashMap<>();
		                Map<String, Object> serverInfo = new HashMap<>();
		                Map<String, Object> capabilities = new HashMap<>();
		                Map<String, Object> tools = new HashMap<>();
		                serverInfo.put("name", getMCPToolsController().getServerName());
		                serverInfo.put("version", getMCPToolsController().getVersion());
		
		                capabilities.put("tools", tools);
		
		                   mcpResult.put("protocolVersion", getMCPToolsController().getProtocolVersion());
		                   mcpResult.put("serverInfo", serverInfo);
		                   mcpResult.put("capabilities", capabilities);
		
		                response.put("jsonrpc", "2.0");
		                response.put("id", request.getId());
		                response.put("result", mcpResult);
		                postProcessing(method,response);
		                return response;
		            } case "notifications/initialized": {
		                // For notifications, return null since no response is expected
		                return ResponseEntity.noContent().build();
		            } case "tools/list": {
		
		                ResponseEntity<Map<String, List<Tool>>> toolsResponse = getMCPToolsController().listTools();
		
		                Map<String, Object> response = new HashMap<>();
		                Map<String, Object> mcpResult = new HashMap<>();
		
		                // Create ListToolsResult structure
		                mcpResult.put("tools", toolsResponse.getBody().get("tools"));
		                mcpResult.put("_meta", new HashMap<>());
		
		                // Wrap in JSON-RPC response
		                response.put("jsonrpc", "2.0");
		                response.put("id", request.getId());
		                response.put("result", mcpResult);
		                postProcessing(method,response);
		                return response;
		            } case "tools/call": {
		
		                ToolCallRequest toolRequest = new ToolCallRequest();
		                if (request.getParams() instanceof Map) {
		                    Map<String, Object> mcpParams = (Map<String, Object>) request.getParams();
		                    toolRequest.setName((String) mcpParams.get("name"));
		                    toolRequest.setArguments((Map<String, Object>) mcpParams.get("arguments"));
		                }
		
		
		                ResponseEntity<JSONRPCResponse> toolResponse = getMCPToolsController().callTool(toolRequest);
		
		                Map<String, Object> response = new HashMap<>();
		                response.put("jsonrpc", "2.0");
		                response.put("id", request.getId());
		                response.put("result", toolResponse.getBody().getResult());
		                postProcessing(method,response);
		                return response;
		            } case "resources/list": {
		                ListResourcesRequest listResourcesRequest = new ObjectMapper().convertValue(request, ListResourcesRequest.class);
		
		                ListResourcesResult listResourcesResult = new ListResourcesResult();
		                // Initialize with empty collections
		
		                listResourcesResult.setResources(new ArrayList<>());
		
		
		
		                Map<String, Object> response = new HashMap<>();
		                response.put("jsonrpc", "2.0");
		                response.put("id", request.getId());
		                response.put("result", listResourcesResult);
		                getMCPToolsController().addResources(listResourcesResult);
		                postProcessing(method, response);
		                return response;
		            } case "notifications/cancelled": {
		                 return ResponseEntity.noContent().build();
		            } case "prompts/list": {
		                ListPromptsResult listPromptsResult = new ListPromptsResult();
		                Map<String, Object> response = new HashMap<>();
		                response.put("jsonrpc", "2.0");
		                response.put("id", request.getId());
		                response.put("result", listPromptsResult);
		                getMCPToolsController().addPrompts(listPromptsResult);
		                postProcessing(method, response);
		                return response;
		            } case "ping": {
		                Map<String, Object> response = new HashMap<>();
		                Map<String, Object> mcpResult = new HashMap<>();
		                // Wrap in JSON-RPC response
		                response.put("jsonrpc", "2.0");
		                response.put("id", request.getId());
		                response.put("result", mcpResult);
		                postProcessing(method,response);
		                return response;
		            }
		            default:
		                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Method not found: " + method);
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\common\server\SpringAwareJSONRpcController.java'>
		package io.github.vishalmysore.common.server;
		
		import org.springframework.context.ApplicationContext;
		
		/**
		 * SpringAwareJSONRpcController is a subclass of JsonRpcController that is aware of the Spring application context.
		 * It allows for dependency injection and other Spring features to be used within the JSON-RPC controller.
		 */
		public class SpringAwareJSONRpcController extends JsonRpcController{
		
		    public SpringAwareJSONRpcController(ApplicationContext applicationContext) {
		     super(applicationContext);
		
		    }
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\client\MCPAgent.java'><![CDATA[
		package io.github.vishalmysore.mcp.client;
		
		import com.fasterxml.jackson.core.JsonProcessingException;
		import com.fasterxml.jackson.core.type.TypeReference;
		import com.fasterxml.jackson.databind.DeserializationFeature;
		import com.fasterxml.jackson.databind.JsonNode;
		import com.fasterxml.jackson.databind.ObjectMapper;
		import com.t4a.JsonUtils;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.processor.AIProcessor;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.common.Agent;
		import io.github.vishalmysore.common.AgentInfo;
		import io.github.vishalmysore.common.CommonClientRequest;
		import io.github.vishalmysore.common.CommonClientResponse;
		import io.github.vishalmysore.mcp.domain.*;
		import lombok.extern.java.Log;
		
		import java.net.MalformedURLException;
		import java.net.URL;
		import java.util.HashMap;
		import java.util.List;
		import java.util.Map;
		@Log
		public class MCPAgent implements Agent {
		    private URL serverUrl;
		    private ListToolsResult toolsResult;
		    private JsonUtils utils = new JsonUtils();
		    private String availableTools = "[]";
		
		    private String type ="mcp";
		    private ObjectMapper mapper;
		
		    public MCPAgent() {
		        this(null);
		    }
		    public MCPAgent(URL serverUrl) {
		        this.serverUrl = serverUrl;
		        mapper = new ObjectMapper();
		        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		    }
		
		
		    @Override
		    public String getType() {
		        return type;
		    }
		
		    @Override
		    public CommonClientResponse remoteMethodCall(String query) {
		        PromptTransformer processor = PredictionLoader.getInstance().createOrGetPromptTransformer();
		        String toolNameJson = null;
		        try {
		            toolNameJson = processor.transformIntoJson("{toolName:''}", query);
		        } catch (AIProcessingException e) {
		            log.severe("Error processing query: " + e.getMessage());
		        }
		        toolNameJson = utils.extractJson(toolNameJson);
		        JsonNode root = null;
		        try {
		            root = mapper.readTree(toolNameJson);
		        } catch (JsonProcessingException e) {
		            log.severe("Error processing query: " + e.getMessage());
		        }
		
		        JsonNode idNode = root.get("toolName");
		        if (idNode == null || idNode.asText().trim().isEmpty()) {
		            log.warning("No valid agent ID found in JSON");
		            return null;
		        }
		        String methodName = idNode.asText();
		        return remoteMethodCall(methodName, query);
		    }
		
		    @Override
		    public CommonClientResponse remoteMethodCall(String methodName, String query) {
		        CallToolRequest request = new CallToolRequest();
		        request.putArgument("provideAllValuesInPlainEnglish", query);
		        request.putArgument("name", methodName);
		        return callTool(request);
		
		    }
		
		    @Override
		    public ObjectMapper getMapper() {
		        return mapper;
		    }
		
		    @Override
		    public void connect(String url, String token) {
		        try {
		            serverUrl = new URL(url);
		        } catch (MalformedURLException e) {
		            log.severe("Invalid server URL: " + e.getMessage());
		        }
		        ListToolsRequest request = new ListToolsRequest();
		        MCPGenericResponse<ListToolsResult> response = getRemoteData(request, new TypeReference<MCPGenericResponse<ListToolsResult>>() {});
		
		        toolsResult =(ListToolsResult) response.getResult();
		        if (toolsResult != null) {
		            availableTools = toolsResult.retrieveToolList();
		        }
		    }
		
		    @Override
		    public void disconnect() {
		      log.info("Disconnecting MCPAgent");
		    }
		
		    @Override
		    public AgentInfo getInfo() {
		        return toolsResult;
		    }
		
		    @Override
		    public boolean isConnected() {
		       return serverUrl!= null && toolsResult != null;
		    }
		
		    @Override
		    public URL getServerUrl() {
		        return serverUrl;
		    }
		
		
		
		    public CallToolResult  callTool(CallToolRequest request) {
		        MCPGenericResponse<CallToolResult> response =  getRemoteData(request, new TypeReference<MCPGenericResponse<CallToolResult>>() {});
		        return response.getResult();
		
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Annotations.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		import java.util.Map;
		
		// Classes generated from JSON schema
		
		/**
		 * Optional annotations for the client. The client can use annotations to inform how objects are used or displayed
		 */
		public class Annotations {
		    /**
		     * Describes who the intended customer of this object or data is.
		     * <p>
		     * It can include multiple entries to indicate content useful for multiple audiences (e.g., `["user", "assistant"]`).
		     */
		    private List<Role> audience;
		    /**
		     * Describes how important this data is for operating the server.
		     * <p>
		     * A value of 1 means "most important," and indicates that the data is
		     * effectively required, while 0 means "least important," and indicates that
		     * the data is entirely optional.
		     */
		    private Double priority;
		
		    public List<Role> getAudience() {
		        return audience;
		    }
		
		    public void setAudience(List<Role> audience) {
		        this.audience = audience;
		    }
		
		    public Double getPriority() {
		        return priority;
		    }
		
		    public void setPriority(Double priority) {
		        this.priority = priority;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\AudioContent.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * Audio provided to or from an LLM.
		 */
		public class AudioContent {
		    /**
		     * Optional annotations for the client.
		     */
		    private Annotations annotations;
		    /**
		     * The base64-encoded audio data.
		     */
		    private String data;
		    /**
		     * The MIME type of the audio. Different providers may support different audio types.
		     */
		    private String mimeType;
		    private final String type = "audio";
		
		    public Annotations getAnnotations() {
		        return annotations;
		    }
		
		    public void setAnnotations(Annotations annotations) {
		        this.annotations = annotations;
		    }
		
		    public String getData() {
		        return data;
		    }
		
		    public void setData(String data) {
		        this.data = data;
		    }
		
		    public String getMimeType() {
		        return mimeType;
		    }
		
		    public void setMimeType(String mimeType) {
		        this.mimeType = mimeType;
		    }
		
		    public String getType() {
		        return type;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\BlobResourceContents.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public class BlobResourceContents {
		    /**
		     * A base64-encoded string representing the binary data of the item.
		     */
		    private String blob;
		    /**
		     * The MIME type of this resource, if known.
		     */
		    private String mimeType;
		    /**
		     * The URI of this resource.
		     */
		    private String uri;
		
		    public String getBlob() {
		        return blob;
		    }
		
		    public void setBlob(String blob) {
		        this.blob = blob;
		    }
		
		    public String getMimeType() {
		        return mimeType;
		    }
		
		    public void setMimeType(String mimeType) {
		        this.mimeType = mimeType;
		    }
		
		    public String getUri() {
		        return uri;
		    }
		
		    public void setUri(String uri) {
		        this.uri = uri;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\CallToolRequest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import com.fasterxml.jackson.annotation.JsonSubTypes;
		import com.fasterxml.jackson.annotation.JsonTypeInfo;
		import com.fasterxml.jackson.databind.DeserializationFeature;
		import com.fasterxml.jackson.databind.ObjectMapper;
		import io.github.vishalmysore.common.CommonClientRequest;
		import lombok.AllArgsConstructor;
		import lombok.Getter;
		import lombok.NoArgsConstructor;
		import lombok.Setter;
		
		import java.util.Map;
		
		/**
		 * Used by the client to invoke a tool provided by the server.
		 */
		@Getter
		@Setter
		@NoArgsConstructor
		@AllArgsConstructor
		public class CallToolRequest implements CommonClientRequest {
		    private final String method = "tools/call";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public void putArgument(String key, Object value) {
		        // Initialize params if null
		        if (this.params == null) {
		            this.params = new Params();
		        }
		
		        // Initialize arguments map if null
		        if (this.params.getArguments() == null) {
		            this.params.setArguments(new java.util.HashMap<>());
		        }
		
		        // Put the key-value pair
		        this.params.getArguments().put(key, value);
		    }
		
		
		    public static CallToolRequest fromString(String jsonString) {
		        try {
		            ObjectMapper mapper = new ObjectMapper();
		            mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
		            return mapper.readValue(jsonString, CallToolRequest.class);
		        } catch (Exception e) {
		            throw new RuntimeException("Error parsing CallToolRequest: " + e.getMessage(), e);
		        }
		    }
		
		    public static class Params {
		        private Map<String, Object> arguments;
		        private String name;
		
		        public Map<String, Object> getArguments() {
		            return arguments;
		        }
		
		        public void setArguments(Map<String, Object> arguments) {
		            this.arguments = arguments;
		        }
		
		        public String getName() {
		            return name;
		        }
		
		        public void setName(String name) {
		            this.name = name;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\CallToolResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		import javax.validation.constraints.NotNull;
		import java.util.List;
		import java.util.Map;
		
		/**
		 * The server's response to a tool call.
		 * <p>
		 * Any errors that originate from the tool SHOULD be reported inside the result
		 * object, with `isError` set to true, _not_ as an MCP protocol-level error
		 * response. Otherwise, the LLM would not be able to see that an error occurred
		 * and self-correct.
		 * <p>
		 * However, any errors in _finding_ the tool, an error indicating that the
		 * server does not support tool calls, or any other exceptional conditions,
		 * should be reported as an MCP error response.
		 */
		@Data
		@ToString
		public class CallToolResult extends Result{
		    @NotNull
		    private List<Content> content;
		  //  private Boolean isError;
		  //  private Map<String, Object> _meta;
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\CancelledNotification.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * This notification can be sent by either side to indicate that it is cancelling a previously-issued request.
		 * <p>
		 * The request SHOULD still be in-flight, but due to communication latency, it is always possible that this notification MAY arrive after the request has already finished.
		 * <p>
		 * This notification indicates that the result will be unused, so any associated processing SHOULD cease.
		 * <p>
		 * A client MUST NOT attempt to cancel its `initialize` request.
		 */
		public class CancelledNotification {
		    private final String method = "notifications/cancelled";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
		         */
		        private String reason;
		        /**
		         * The ID of the request to cancel.
		         * <p>
		         * This MUST correspond to the ID of a request previously issued in the same direction.
		         */
		        private String requestId;
		
		        public String getReason() {
		            return reason;
		        }
		
		        public void setReason(String reason) {
		            this.reason = reason;
		        }
		
		        public String getRequestId() {
		            return requestId;
		        }
		
		        public void setRequestId(String requestId) {
		            this.requestId = requestId;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ClientCapabilities.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.Map;
		
		/**
		 * Capabilities a client may support. Known capabilities are defined here,
		 * in this schema, but this is not a closed set: any client can define its
		 * own, additional capabilities.
		 */
		public class ClientCapabilities {
		    /**
		     * Experimental, non-standard capabilities that the client supports.
		     */
		    private Map<String, Map<String, Object>> experimental;
		    /**
		     * Present if the client supports listing roots.
		     */
		    private Roots roots;
		    /**
		     * Present if the client supports sampling from an LLM.
		     */
		    private Map<String, Object> sampling;
		
		    public Map<String, Map<String, Object>> getExperimental() {
		        return experimental;
		    }
		
		    public void setExperimental(Map<String, Map<String, Object>> experimental) {
		        this.experimental = experimental;
		    }
		
		    public Roots getRoots() {
		        return roots;
		    }
		
		    public void setRoots(Roots roots) {
		        this.roots = roots;
		    }
		
		    public Map<String, Object> getSampling() {
		        return sampling;
		    }
		
		    public void setSampling(Map<String, Object> sampling) {
		        this.sampling = sampling;
		    }
		
		    public static class Roots {
		        /**
		         * Whether the client supports notifications for changes to the roots list.
		         */
		        private Boolean listChanged;
		
		        public Boolean getListChanged() {
		            return listChanged;
		        }
		
		        public void setListChanged(Boolean listChanged) {
		            this.listChanged = listChanged;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ClientNotification.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public abstract class ClientNotification {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ClientRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import io.github.vishalmysore.common.CommonClientRequest;
		
		public abstract class ClientRequest implements CommonClientRequest {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ClientResult.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public abstract class ClientResult {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\CompleteRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import io.github.vishalmysore.mcp.domain.ClientRequest;
		
		public class CompleteRequest extends ClientRequest {
		    private final String method = "completion/complete";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * The argument's information
		         */
		        private Argument argument;
		        private Object ref; // Can be PromptReference or ResourceReference.  Better to use Object
		
		        public Argument getArgument() {
		            return argument;
		        }
		
		        public void setArgument(Argument argument) {
		            this.argument = argument;
		        }
		
		        public Object getRef() {
		            return ref;
		        }
		
		        public void setRef(Object ref) {
		            this.ref = ref;
		        }
		    }
		
		    public static class Argument {
		        /**
		         * The name of the argument
		         */
		        private String name;
		        /**
		         * The value of the argument to use for completion matching.
		         */
		        private String value;
		
		        public String getName() {
		            return name;
		        }
		
		        public void setName(String name) {
		            this.name = name;
		        }
		
		        public String getValue() {
		            return value;
		        }
		
		        public void setValue(String value) {
		            this.value = value;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\CompleteResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		import java.util.Map;
		
		/**
		 * The server's response to a completion/complete request
		 */
		public class CompleteResult extends ClientResult {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    private Completion completion;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public Completion getCompletion() {
		        return completion;
		    }
		
		    public void setCompletion(Completion completion) {
		        this.completion = completion;
		    }
		
		    public static class Completion {
		        /**
		         * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
		         */
		        private Boolean hasMore;
		        /**
		         * The total number of completion options available. This can exceed the number of values actually sent in the response.
		         */
		        private Integer total;
		        /**
		         * An array of completion values. Must not exceed 100 items.
		         */
		        private List<String> values;
		
		        public Boolean getHasMore() {
		            return hasMore;
		        }
		
		        public void setHasMore(Boolean hasMore) {
		            this.hasMore = hasMore;
		        }
		
		        public Integer getTotal() {
		            return total;
		        }
		
		        public void setTotal(Integer total) {
		            this.total = total;
		        }
		
		        public List<String> getValues() {
		            return values;
		        }
		
		        public void setValues(List<String> values) {
		            this.values = values;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Content.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import com.fasterxml.jackson.annotation.JsonSubTypes;
		import com.fasterxml.jackson.annotation.JsonTypeInfo;
		
		@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
		@JsonSubTypes({
		        @JsonSubTypes.Type(value = TextContent.class, name = "text"),
		        @JsonSubTypes.Type(value = ImageContent.class, name = "image")
		})
		public interface Content {
		    String getType();
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\CreateMessageRequest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		import java.util.Map;
		
		/**
		 * A request from the server to sample an LLM via the client.
		 * The client has full discretion over which model to select.
		 * The client should also inform the user before beginning sampling,
		 * to allow them to inspect the request (human in the loop) and decide whether to approve it.
		 */
		public class CreateMessageRequest {
		    private final String method = "sampling/createMessage";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * A request to include context from one or more MCP servers (including the caller),
		         * to be attached to the prompt. The client MAY ignore this request.
		         */
		        private String includeContext;  // Use String instead of the enum
		        /**
		         * The maximum number of tokens to sample, as requested by the server.
		         * The client MAY choose to sample fewer tokens than requested.
		         */
		        private Integer maxTokens;
		        private List<SamplingMessage> messages;
		        /**
		         * Optional metadata to pass through to the LLM provider.
		         * The format of this metadata is provider-specific.
		         */
		        private Map<String, Object> metadata;
		        /**
		         * The server's preferences for which model to select.
		         * The client MAY ignore these preferences.
		         */
		        private ModelPreferences modelPreferences;
		        private List<String> stopSequences;
		        /**
		         * An optional system prompt the server wants to use for sampling.
		         * The client MAY modify or omit this prompt.
		         */
		        private String systemPrompt;
		        private Double temperature;
		
		        public String getIncludeContext() {
		            return includeContext;
		        }
		
		        public void setIncludeContext(String includeContext) {
		            this.includeContext = includeContext;
		        }
		
		        public Integer getMaxTokens() {
		            return maxTokens;
		        }
		
		        public void setMaxTokens(Integer maxTokens) {
		            this.maxTokens = maxTokens;
		        }
		
		        public List<SamplingMessage> getMessages() {
		            return messages;
		        }
		
		        public void setMessages(List<SamplingMessage> messages) {
		            this.messages = messages;
		        }
		
		        public Map<String, Object> getMetadata() {
		            return metadata;
		        }
		
		        public void setMetadata(Map<String, Object> metadata) {
		            this.metadata = metadata;
		        }
		
		        public ModelPreferences getModelPreferences() {
		            return modelPreferences;
		        }
		
		        public void setModelPreferences(ModelPreferences modelPreferences) {
		            this.modelPreferences = modelPreferences;
		        }
		
		        public List<String> getStopSequences() {
		            return stopSequences;
		        }
		
		        public void setStopSequences(List<String> stopSequences) {
		            this.stopSequences = stopSequences;
		        }
		
		        public String getSystemPrompt() {
		            return systemPrompt;
		        }
		
		        public void setSystemPrompt(String systemPrompt) {
		            this.systemPrompt = systemPrompt;
		        }
		
		        public Double getTemperature() {
		            return temperature;
		        }
		
		        public void setTemperature(Double temperature) {
		            this.temperature = temperature;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\CreateMessageResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.Map;
		
		/**
		 * The client's response to a sampling/create_message request from the server.
		 * The client should inform the user before returning the sampled message,
		 * to allow them to inspect the response (human in the loop) and decide whether to allow the server to see it.
		 */
		public class CreateMessageResult extends ClientResult {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    private Content content;
		    /**
		     * The name of the model that generated the message.
		     */
		    private String model;
		    private Role role;
		    /**
		     * The reason why sampling stopped, if known.
		     */
		    private String stopReason;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public Content getContent() {
		        return content;
		    }
		
		    public void setContent(Content content) {
		        this.content = content;
		    }
		
		    public String getModel() {
		        return model;
		    }
		
		    public void setModel(String model) {
		        this.model = model;
		    }
		
		    public Role getRole() {
		        return role;
		    }
		
		    public void setRole(Role role) {
		        this.role = role;
		    }
		
		    public String getStopReason() {
		        return stopReason;
		    }
		
		    public void setStopReason(String stopReason) {
		        this.stopReason = stopReason;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Cursor.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * An opaque token used to represent a cursor for pagination.
		 */
		public class Cursor {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\EmbeddedResource.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import com.fasterxml.jackson.annotation.JsonSubTypes;
		import com.fasterxml.jackson.annotation.JsonTypeInfo;
		
		public class EmbeddedResource implements Content {
		    /**
		     * Optional annotations for the client.
		     */
		    private Annotations annotations;
		    
		    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
		    @JsonSubTypes({
		        @JsonSubTypes.Type(value = TextResourceContents.class, name = "text"),
		        @JsonSubTypes.Type(value = BlobResourceContents.class, name = "blob")
		    })
		    private Object resource;  // Can be TextResourceContents or BlobResourceContents
		
		    private final String type = "resource";
		
		    public Annotations getAnnotations() {
		        return annotations;
		    }
		
		    public void setAnnotations(Annotations annotations) {
		        this.annotations = annotations;
		    }
		
		    public Object getResource() {
		        return resource;
		    }
		
		    public void setResource(Object resource) {
		        this.resource = resource;
		    }
		
		    public String getType() {
		        return type;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\EmptyResult.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public class EmptyResult extends Result {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\GetPromptRequest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.Map;
		
		public class GetPromptRequest extends ClientRequest {
		    private final String method = "prompts/get";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * Arguments to use for templating the prompt.
		         */
		        private Map<String, String> arguments;
		        /**
		         * The name of the prompt or prompt template.
		         */
		        private String name;
		
		        public Map<String, String> getArguments() {
		            return arguments;
		        }
		
		        public void setArguments(Map<String, String> arguments) {
		            this.arguments = arguments;
		        }
		
		        public String getName() {
		            return name;
		        }
		
		        public void setName(String name) {
		            this.name = name;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\GetPromptResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		import java.util.Map;
		
		/**
		 * The server's response to a prompts/get request from the client.
		 */
		public class GetPromptResult {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    /**
		     * An optional description for the prompt.
		     */
		    private String description;
		    private List<PromptMessage> messages;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public String getDescription() {
		        return description;
		    }
		
		    public void setDescription(String description) {
		        this.description = description;
		    }
		
		    public List<PromptMessage> getMessages() {
		        return messages;
		    }
		
		    public void setMessages(List<PromptMessage> messages) {
		        this.messages = messages;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ImageContent.java'>
		package io.github.vishalmysore.mcp.domain;
		/**
		 * An image provided to or from an LLM.
		 */
		public class ImageContent implements Content {
		    /**
		     * Optional annotations for the client.
		     */
		    private Annotations annotations;
		    /**
		     * The base64-encoded image data.
		     */
		    private String data;
		    /**
		     * The MIME type of the image. Different providers may support different image types.
		     */
		    private String mimeType;
		    private final String type = "image";
		
		    public Annotations getAnnotations() {
		        return annotations;
		    }
		
		    public void setAnnotations(Annotations annotations) {
		        this.annotations = annotations;
		    }
		
		    public String getData() {
		        return data;
		    }
		
		    public void setData(String data) {
		        this.data = data;
		    }
		
		    public String getMimeType() {
		        return mimeType;
		    }
		
		    public void setMimeType(String mimeType) {
		        this.mimeType = mimeType;
		    }
		
		    public String getType() {
		        return type;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Implementation.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * Describes the name and version of an MCP implementation.
		 */
		public class Implementation {
		    private String name;
		    private String version;
		
		    public String getName() {
		        return name;
		    }
		
		    public void setName(String name) {
		        this.name = name;
		    }
		
		    public String getVersion() {
		        return version;
		    }
		
		    public void setVersion(String version) {
		        this.version = version;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\InitializedNotification.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.Map;
		
		/**
		 * This notification is sent from the client to the server after initialization has finished.
		 */
		public class InitializedNotification extends ClientNotification {
		    private final String method = "notifications/initialized";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
		         */
		        private Map<String, Object> _meta;
		
		        public Map<String, Object> getMeta() {
		            return _meta;
		        }
		
		        public void setMeta(Map<String, Object> meta) {
		            this._meta = meta;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\InitializeRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * This request is sent from the client to the server when it first connects, asking it to begin initialization.
		 */
		public class InitializeRequest extends ClientRequest {
		    private final String method = "initialize";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        private ClientCapabilities capabilities;
		        private Implementation clientInfo;
		        /**
		         * The latest version of the Model Context Protocol that the client supports.
		         * The client MAY decide to support older versions as well.
		         */
		        private String protocolVersion;
		
		        public ClientCapabilities getCapabilities() {
		            return capabilities;
		        }
		
		        public void setCapabilities(ClientCapabilities capabilities) {
		            this.capabilities = capabilities;
		        }
		
		        public Implementation getClientInfo() {
		            return clientInfo;
		        }
		
		        public void setClientInfo(Implementation clientInfo) {
		            this.clientInfo = clientInfo;
		        }
		
		        public String getProtocolVersion() {
		            return protocolVersion;
		        }
		
		        public void setProtocolVersion(String protocolVersion) {
		            this.protocolVersion = protocolVersion;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\InitializeResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.Map;
		
		/**
		 * After receiving an initialize request from the client, the server sends this response.
		 */
		public class InitializeResult extends ClientResult {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    private ServerCapabilities capabilities;
		    /**
		     * Instructions describing how to use the server and its features.
		     * <p>
		     * This can be used by clients to improve the LLM's understanding of available tools, resources, etc.
		     * It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
		     */
		    private String instructions;
		    /**
		     * The version of the Model Context Protocol that the server wants to use.
		     * This may not match the version that the client requested.
		     * If the client cannot support this version, it MUST disconnect.
		     */
		    private String protocolVersion;
		    private Implementation serverInfo;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public ServerCapabilities getCapabilities() {
		        return capabilities;
		    }
		
		    public void setCapabilities(ServerCapabilities capabilities) {
		        this.capabilities = capabilities;
		    }
		
		    public String getInstructions() {
		        return instructions;
		    }
		
		    public void setInstructions(String instructions) {
		        this.instructions = instructions;
		    }
		
		    public String getProtocolVersion() {
		        return protocolVersion;
		    }
		
		    public void setProtocolVersion(String protocolVersion) {
		        this.protocolVersion = protocolVersion;
		    }
		
		    public Implementation getServerInfo() {
		        return serverInfo;
		    }
		
		    public void setServerInfo(Implementation serverInfo) {
		        this.serverInfo = serverInfo;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\JSONRPCBatchRequest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		
		/**
		 * A JSON-RPC batch request, as described in https://www.jsonrpc.org/specification#batch.
		 */
		public class JSONRPCBatchRequest {
		    private List<Object> jsonRpcRequests;  // Can be JSONRPCRequest or JSONRPCNotification. Use Object
		
		    public List<Object> getJsonRpcRequests() {
		        return jsonRpcRequests;
		    }
		
		    public void setJsonRpcRequests(List<Object> jsonRpcRequests) {
		        this.jsonRpcRequests = jsonRpcRequests;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\JSONRPCBatchResponse.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		
		/**
		 * A JSON-RPC batch response, as described in https://www.jsonrpc.org/specification#batch.
		 */
		public class JSONRPCBatchResponse {
		    private List<Object> jsonRpcResponses; // Can be JSONRPCResponse or JSONRPCError. Use Object
		
		    public List<Object> getJsonRpcResponses() {
		        return jsonRpcResponses;
		    }
		
		    public void setJsonRpcResponses(List<Object> jsonRpcResponses) {
		        this.jsonRpcResponses = jsonRpcResponses;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\JSONRPCError.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * A response to a request that indicates an error occurred.
		 */
		public class JSONRPCError {
		    private Error error;
		    private String id;
		    private final String jsonrpc = "2.0";
		
		    public Error getError() {
		        return error;
		    }
		
		    public void setError(Error error) {
		        this.error = error;
		    }
		
		    public String getId() {
		        return id;
		    }
		
		    public void setId(String id) {
		        this.id = id;
		    }
		
		    public String getJsonrpc() {
		        return jsonrpc;
		    }
		
		    public static class Error {
		        /**
		         * The error type that occurred.
		         */
		        private Integer code;
		        /**
		         * Additional information about the error.
		         * The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
		         */
		        private Object data;
		        /**
		         * A short description of the error. The message SHOULD be limited to a concise single sentence.
		         */
		        private String message;
		
		        public Integer getCode() {
		            return code;
		        }
		
		        public void setCode(Integer code) {
		            this.code = code;
		        }
		
		        public Object getData() {
		            return data;
		        }
		
		        public void setData(Object data) {
		            this.data = data;
		        }
		
		        public String getMessage() {
		            return message;
		        }
		
		        public void setMessage(String message) {
		            this.message = message;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\JSONRPCMessage.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public abstract class JSONRPCMessage {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\JSONRPCNotification.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.Map;
		
		/**
		 * A notification which does not expect a response.
		 */
		public class JSONRPCNotification extends JSONRPCMessage {
		    private final String jsonrpc = "2.0";
		    private String method;
		    private Params params;
		
		    public String getJsonrpc() {
		        return jsonrpc;
		    }
		
		    public String getMethod() {
		        return method;
		    }
		
		    public void setMethod(String method) {
		        this.method = method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their notifications.
		         */
		        private Map<String, Object> _meta;
		
		        public Map<String, Object> getMeta() {
		            return _meta;
		        }
		
		        public void setMeta(Map<String, Object> meta) {
		            this._meta = meta;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\JSONRPCRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * A request that expects a response.
		 */
		public class JSONRPCRequest extends JSONRPCMessage {
		    private String id;
		    private final String jsonrpc = "2.0";
		    private String method;
		    private Params params;
		
		    public String getId() {
		        return id;
		    }
		
		    public void setId(String id) {
		        this.id = id;
		    }
		
		    public String getJsonrpc() {
		        return jsonrpc;
		    }
		
		    public String getMethod() {
		        return method;
		    }
		
		    public void setMethod(String method) {
		        this.method = method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * This parameter name is reserved by MCP to allow clients and servers to attach additional metadata to their requests.
		         */
		        private Meta _meta;
		
		        public Meta getMeta() {
		            return _meta;
		        }
		
		        public void setMeta(Meta meta) {
		            this._meta = meta;
		        }
		
		        public static class Meta {
		            /**
		             * If specified, the caller is requesting out-of-band progress notifications for this request
		             * (as represented by notifications/progress). The value of this parameter is an opaque token
		             * that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
		             */
		            private String progressToken;  // Changed from ProgressToken to String
		
		            public String getProgressToken() {
		                return progressToken;
		            }
		
		            public void setProgressToken(String progressToken) {
		                this.progressToken = progressToken;
		            }
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\JSONRPCResponse.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.AllArgsConstructor;
		import lombok.Data;
		import lombok.NoArgsConstructor;
		
		/**
		 * A successful (non-error) response to a request.
		 */
		@Data
		@AllArgsConstructor
		@NoArgsConstructor
		public class JSONRPCResponse extends JSONRPCMessage {
		    private String id;
		    private final String jsonrpc = "2.0";
		    private Result result;
		
		    public String getId() {
		        return id;
		    }
		
		    public void setId(String id) {
		        this.id = id;
		    }
		
		    public String getJsonrpc() {
		        return jsonrpc;
		    }
		
		    public Result getResult() {
		        return result;
		    }
		
		    public void setResult(Result result) {
		        this.result = result;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListPromptsRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Getter;
		import lombok.Setter;
		
		/**
		 * Sent from the client to request a list of prompts and prompt templates the server has.
		 */
		public class ListPromptsRequest extends ClientRequest {
		    @Getter
		    @Setter
		    private String id;
		    @Getter
		    @Setter
		    private String jsonrpc;
		    private final String method = "prompts/list";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * An opaque token representing the current pagination position.
		         * If provided, the server should return results starting after this cursor.
		         */
		        private String cursor;  // Changed from Cursor to String
		
		        public String getCursor() {
		            return cursor;
		        }
		
		        public void setCursor(String cursor) {
		            this.cursor = cursor;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListPromptsResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		import java.util.Map;
		
		/**
		 * The server's response to a prompts/list request from the client.
		 */
		public class ListPromptsResult {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    /**
		     * An opaque token representing the pagination position after the last returned result.
		     * If present, there may be more results available.
		     */
		    private String nextCursor;  // Changed from Cursor to String
		    private List<Prompt> prompts;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public String getNextCursor() {
		        return nextCursor;
		    }
		
		    public void setNextCursor(String nextCursor) {
		        this.nextCursor = nextCursor;
		    }
		
		    public List<Prompt> getPrompts() {
		        return prompts;
		    }
		
		    public void setPrompts(List<Prompt> prompts) {
		        this.prompts = prompts;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListResourcesRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Getter;
		import lombok.Setter;
		
		/**
		 * Sent from the client to request a list of resources.
		 */
		public class ListResourcesRequest extends ClientRequest {
		    private final String method = "resources/list";
		
		    @Getter
		    @Setter
		    private String id;
		    @Getter
		    @Setter
		    private String jsonrpc;
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * An opaque token representing the current pagination position.
		         * If provided, the server should return results starting after this cursor.
		         */
		        private String cursor; // Changed from Cursor to String
		        /**
		         * A string used to filter resources by matching against their names and/or descriptions.
		         */
		        private String filter;
		
		        public String getCursor() {
		            return cursor;
		        }
		
		        public void setCursor(String cursor) {
		            this.cursor = cursor;
		        }
		
		        public String getFilter() {
		            return filter;
		        }
		
		        public void setFilter(String filter) {
		            this.filter = filter;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListResourcesResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		import java.util.List;
		import java.util.Map;
		import java.util.Map;
		
		/**
		 * The server's response to a resources/list request from the client.
		 */
		public class ListResourcesResult extends ClientResult {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    /**
		     * An opaque token representing the pagination position after the last returned result.
		     * If present, there may be more results available.
		     */
		    private String nextCursor; // Changed from Cursor to String
		    private List<Resource> resources;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public String getNextCursor() {
		        return nextCursor;
		    }
		
		    public void setNextCursor(String nextCursor) {
		        this.nextCursor = nextCursor;
		    }
		
		    public List<Resource> getResources() {
		        return resources;
		    }
		
		    public void setResources(List<Resource> resources) {
		        this.resources = resources;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListResourceTemplatesRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * Sent from the client to request a list of resource templates the server has.
		 */
		public class ListResourceTemplatesRequest extends ClientRequest {
		    private final String method = "resourceTemplates/list";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * An opaque token representing the current pagination position.
		         * If provided, the server should return results starting after this cursor.
		         */
		        private String cursor;  // Changed from Cursor to String
		
		        public String getCursor() {
		            return cursor;
		        }
		
		        public void setCursor(String cursor) {
		            this.cursor = cursor;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListResourceTemplatesResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		import java.util.List;
		import java.util.Map;
		import java.util.Map;
		
		/**
		 * The server's response to a resourceTemplates/list request from the client.
		 */
		public class ListResourceTemplatesResult {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    /**
		     * An opaque token representing the pagination position after the last returned result.
		     * If present, there may be more results available.
		     */
		    private String nextCursor;  // Changed from Cursor to String
		    private List<ResourceTemplate> resourceTemplates;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public String getNextCursor() {
		        return nextCursor;
		    }
		
		    public void setNextCursor(String nextCursor) {
		        this.nextCursor = nextCursor;
		    }
		
		    public List<ResourceTemplate> getResourceTemplates() {
		        return resourceTemplates;
		    }
		
		    public void setResourceTemplates(List<ResourceTemplate> resourceTemplates) {
		        this.resourceTemplates = resourceTemplates;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListRootsRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * Sent from the client to request a list of roots.
		 */
		public class ListRootsRequest extends ClientRequest {
		    private final String method = "roots/list";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * Whether to subscribe to notifications for changes to the roots list.
		         */
		        private Boolean subscribe;
		
		        public Boolean getSubscribe() {
		            return subscribe;
		        }
		
		        public void setSubscribe(Boolean subscribe) {
		            this.subscribe = subscribe;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListRootsResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		import java.util.List;
		import java.util.Map;
		import java.util.Map;
		
		/**
		 * The server's response to a roots/list request from the client.
		 */
		public class ListRootsResult extends ClientResult {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    private List<Root> roots;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public List<Root> getRoots() {
		        return roots;
		    }
		
		    public void setRoots(List<Root> roots) {
		        this.roots = roots;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListToolsRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.AllArgsConstructor;
		import lombok.Getter;
		import lombok.NoArgsConstructor;
		import lombok.Setter;
		
		/**
		 * Sent from the client to request a list of tools the server provides.
		 */
		@Setter
		@Getter
		@NoArgsConstructor
		@AllArgsConstructor
		public class ListToolsRequest extends ClientRequest {
		    private final String method = "tools/list";
		    private String jsonrpc ="2.0";
		    private Object params;
		    private Object id;
		
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ListToolsResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		
		import io.github.vishalmysore.common.AgentInfo;
		import lombok.EqualsAndHashCode;
		import lombok.ToString;
		import org.springframework.stereotype.Component;
		
		import java.util.List;
		import java.util.Map;
		
		/**
		 * The server's response to a tools/list request from the client.
		 */
		@Component
		@ToString
		@EqualsAndHashCode
		public class ListToolsResult implements AgentInfo {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    private List<Tool> tools;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public List<Tool> getTools() {
		        return tools;
		    }
		
		    public void setTools(List<Tool> tools) {
		        this.tools = tools;
		    }
		
		    public String retrieveToolList() {
		        if (tools == null || tools.isEmpty()) {
		            return "[]";
		        }
		        StringBuilder jsonBuilder = new StringBuilder("[\n");
		        for (int i = 0; i < tools.size(); i++) {
		            Tool tool = tools.get(i);
		            jsonBuilder.append("  {\n")
		                    .append("    \"toolName\": \"").append(tool.getName().replace("\"", "\\\"")).append("\",\n")
		                    .append("    \"toolDescription\": \"").append(tool.getDescription().replace("\"", "\\\"")).append("\"\n")
		                    .append("  }");
		            if (i < tools.size() - 1) {
		                jsonBuilder.append(",");
		            }
		            jsonBuilder.append("\n");
		        }
		        jsonBuilder.append("]");
		        return jsonBuilder.toString();
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\MCPGenericResponse.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Getter;
		import lombok.Setter;
		
		@Getter
		@Setter
		public class MCPGenericResponse<T> {
		    private String jsonrpc;
		    private Object id;
		    private T result;
		
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ModelPreferences.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * The server's preferences for which model to select.
		 * The client MAY ignore these preferences.
		 */
		public class ModelPreferences {
		    /**
		     * The name of the model that the server prefers.
		     */
		    private String modelName;
		
		    public String getModelName() {
		        return modelName;
		    }
		
		    public void setModelName(String modelName) {
		        this.modelName = modelName;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Notification.java'>
		package io.github.vishalmysore.mcp.domain;
		/**
		 * A notification that is sent outside the normal request-response flow.
		 */
		public abstract class Notification extends JSONRPCNotification {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Progress.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * The actual progress data.
		 */
		public class Progress {
		    /**
		     * An optional string describing the progress.
		     */
		    private String message;
		    /**
		     * A number between 0 and 1 (inclusive) indicating the fraction of work that has been completed.
		     */
		    private Double value;
		
		    public String getMessage() {
		        return message;
		    }
		
		    public void setMessage(String message) {
		        this.message = message;
		    }
		
		    public Double getValue() {
		        return value;
		    }
		
		    public void setValue(Double value) {
		        this.value = value;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ProgressNotification.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import ai.djl.util.Progress;
		
		/**
		 * A notification that carries progress information about a long-running operation.
		 */
		public class ProgressNotification extends Notification {
		    private final String method = "notifications/progress";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public JSONRPCNotification.Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Prompt.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		
		/**
		 * A prompt or prompt template.
		 */
		public class Prompt {
		    /**
		     * Optional annotations for the client.
		     */
		    private Annotations annotations;
		    /**
		     * An optional description for the prompt.
		     */
		    private String description;
		    /**
		     * The messages in the prompt.
		     */
		    private List<PromptMessage> messages;
		    /**
		     * The name of the prompt or prompt template.
		     */
		    private String name;
		
		    public Annotations getAnnotations() {
		        return annotations;
		    }
		
		    public void setAnnotations(Annotations annotations) {
		        this.annotations = annotations;
		    }
		
		    public String getDescription() {
		        return description;
		    }
		
		    public void setDescription(String description) {
		        this.description = description;
		    }
		
		    public List<PromptMessage> getMessages() {
		        return messages;
		    }
		
		    public void setMessages(List<PromptMessage> messages) {
		        this.messages = messages;
		    }
		
		    public String getName() {
		        return name;
		    }
		
		    public void setName(String name) {
		        this.name = name;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\PromptMessage.java'>
		package io.github.vishalmysore.mcp.domain;
		
		/**
		 * A message in a prompt.
		 */
		public class PromptMessage {
		    private Content content;
		    private Role role;
		
		    public Content getContent() {
		        return content;
		    }
		
		    public void setContent(Content content) {
		        this.content = content;
		    }
		
		    public Role getRole() {
		        return role;
		    }
		
		    public void setRole(Role role) {
		        this.role = role;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ReadResourceRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		
		/**
		 * Sent from the client to ask the server to read a resource.
		 */
		public class ReadResourceRequest extends ClientRequest {
		    private final String method = "resources/read";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * The URI of the resource to read.
		         */
		        private String uri;  // Changed from URI to String
		
		        public String getUri() {
		            return uri;
		        }
		
		        public void setUri(String uri) {
		            this.uri = uri;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ReadResourceResult.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.Map;
		
		/**
		 * The server's response to a resources/read request from the client.
		 */
		public class ReadResourceResult extends Result {
		    /**
		     * This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses.
		     */
		    private Map<String, Object> _meta;
		    private Resource resource;
		
		    public Map<String, Object> getMeta() {
		        return _meta;
		    }
		
		    public void setMeta(Map<String, Object> meta) {
		        this._meta = meta;
		    }
		
		    public Resource getResource() {
		        return resource;
		    }
		
		    public void setResource(Resource resource) {
		        this.resource = resource;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Resource.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import com.fasterxml.jackson.annotation.JsonSubTypes;
		import com.fasterxml.jackson.annotation.JsonTypeInfo;
		
		/**
		 * A resource, which may be text or binary data.
		 */
		public class Resource {    /**
		     * Optional annotations for the client.
		     */
		    private Annotations annotations;
		    
		    /**
		     * The contents of the resource.
		     */
		    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")
		    @JsonSubTypes({
		        @JsonSubTypes.Type(value = TextResourceContents.class, name = "text"),
		        @JsonSubTypes.Type(value = BlobResourceContents.class, name = "blob")
		    })
		    private Object contents;
		    
		    /**
		     * The URI of the resource.
		     */
		    private String uri;  // Changed from URI to String
		
		    public Annotations getAnnotations() {
		        return annotations;
		    }
		
		    public void setAnnotations(Annotations annotations) {
		        this.annotations = annotations;
		    }
		
		    public Object getContents() {
		        return contents;
		    }
		
		    public void setContents(Object contents) {
		        this.contents = contents;
		    }
		
		    public String getUri() {
		        return uri;
		    }
		
		    public void setUri(String uri) {
		        this.uri = uri;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ResourceReference.java'>
		package io.github.vishalmysore.mcp.domain;
		
		
		/**
		 * A resource, or a reference to a resource.
		 */
		public class ResourceReference {
		    /**
		     * The URI of the resource.
		     */
		    private String uri; // Changed from URI to String
		
		    public String getUri() {
		        return uri;
		    }
		
		    public void setUri(String uri) {
		        this.uri = uri;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ResourceTemplate.java'>
		package io.github.vishalmysore.mcp.domain;
		
		
		/**
		 * A resource template, which can be used to generate resources.
		 */
		public class ResourceTemplate {
		    /**
		     * Optional annotations for the client.
		     */
		    private Annotations annotations;
		    /**
		     * The name of the resource template.
		     */
		    private String name;
		    /**
		     * The URI of the resource template.
		     */
		    private String uri;  // Changed from URI to String
		
		    public Annotations getAnnotations() {
		        return annotations;
		    }
		
		    public void setAnnotations(Annotations annotations) {
		        this.annotations = annotations;
		    }
		
		    public String getName() {
		        return name;
		    }
		
		    public void setName(String name) {
		        this.name = name;
		    }
		
		    public String getUri() {
		        return uri;
		    }
		
		    public void setUri(String uri) {
		        this.uri = uri;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Result.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import com.fasterxml.jackson.annotation.JsonSubTypes;
		import com.fasterxml.jackson.annotation.JsonTypeInfo;
		import io.github.vishalmysore.common.CommonClientResponse;
		
		@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type", defaultImpl = CallToolResult.class)
		@JsonSubTypes({
		        @JsonSubTypes.Type(value = CallToolResult.class, name = "callTool"),
		        @JsonSubTypes.Type(value = EmptyResult.class, name = "empty")
		})
		/**
		 * The base type for all result types.
		 */
		public abstract class Result implements CommonClientResponse {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Role.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public enum Role {
		    USER,
		    ASSISTANT,
		    SYSTEM
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Root.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public interface Root {
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\SamplingContext.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		
		public class SamplingContext {
		    /**
		     * The messages in the prompt.
		     */
		    private List<PromptMessage> messages;
		    /**
		     * The URI of the resource.
		     */
		    private String uri;  // Changed from URI to String
		
		    public List<PromptMessage> getMessages() {
		        return messages;
		    }
		
		    public void setMessages(List<PromptMessage> messages) {
		        this.messages = messages;
		    }
		
		    public String getUri() {
		        return uri;
		    }
		
		    public void setUri(String uri) {
		        this.uri = uri;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\SamplingMessage.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public class SamplingMessage {
		    private Content content;
		    private Role role;
		
		    public Content getContent() {
		        return content;
		    }
		
		    public void setContent(Content content) {
		        this.content = content;
		    }
		
		    public Role getRole() {
		        return role;
		    }
		
		    public void setRole(Role role) {
		        this.role = role;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ServerCapabilities.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import java.util.List;
		
		public class ServerCapabilities {
		    /**
		     * The content types the server supports.
		     */
		    private List<String> contentTypes;
		    /**
		     * The roles the server supports in prompts.
		     */
		    private List<String> roles;
		    /**
		     * The sampling methods the server supports.
		     */
		    private List<String> samplingMethods;
		    /**
		     * The tool types the server supports.
		     */
		    private List<String> toolTypes;
		
		    public List<String> getContentTypes() {
		        return contentTypes;
		    }
		
		    public void setContentTypes(List<String> contentTypes) {
		        this.contentTypes = contentTypes;
		    }
		
		    public List<String> getRoles() {
		        return roles;
		    }
		
		    public void setRoles(List<String> roles) {
		        this.roles = roles;
		    }
		
		    public List<String> getSamplingMethods() {
		        return samplingMethods;
		    }
		
		    public void setSamplingMethods(List<String> samplingMethods) {
		        this.samplingMethods = samplingMethods;
		    }
		
		    public List<String> getToolTypes() {
		        return toolTypes;
		    }
		
		    public void setToolTypes(List<String> toolTypes) {
		        this.toolTypes = toolTypes;
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\SetLevelRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public class SetLevelRequest {
		    private final String method = "server/setLevel";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * The new level.
		         */
		        private String level;
		
		        public String getLevel() {
		            return level;
		        }
		
		        public void setLevel(String level) {
		            this.level = level;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\SubscribeRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public class SubscribeRequest extends ClientRequest {
		    private final String method = "resources/subscribe";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * The URI of the resource to subscribe to.
		         */
		        private String uri;  // Changed from URI to String
		
		        public String getUri() {
		            return uri;
		        }
		
		        public void setUri(String uri) {
		            this.uri = uri;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\TextContent.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@ToString
		public class TextContent implements Content {
		    /**
		     * Optional annotations for the client.
		     */
		    private Annotations annotations;
		    /**
		     * The text string.
		     */
		    private String text;
		    /**
		     * The media type of the text, e.g. "text/plain" or "text/html".
		     */
		    private String type;
		
		    public Annotations getAnnotations() {
		        return annotations;
		    }
		
		    public void setAnnotations(Annotations annotations) {
		        this.annotations = annotations;
		    }
		
		    public String getText() {
		        return text;
		    }
		
		    public void setText(String text) {
		        this.text = text;
		    }
		
		    public String getType() {
		        return type;
		    }
		
		    public void setType(String type) {
		        this.type = type;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\TextResourceContents.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public class TextResourceContents {
		    /**
		     * Optional annotations for the client.
		     */
		    private Annotations annotations;
		    /**
		     * The text string.
		     */
		    private String text;
		    /**
		     * The MIME type of the text.
		     */
		    private String mimeType;
		
		    public Annotations getAnnotations() {
		        return annotations;
		    }
		
		    public void setAnnotations(Annotations annotations) {
		        this.annotations = annotations;
		    }
		
		    public String getText() {
		        return text;
		    }
		
		    public void setText(String text) {
		        this.text = text;
		    }
		
		    public String getMimeType() {
		        return mimeType;
		    }
		
		    public void setMimeType(String mimeType) {
		        this.mimeType = mimeType;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\Tool.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		import javax.validation.constraints.NotNull;
		
		@Data
		@ToString
		public class Tool {
		    private ToolParameters parameters;
		
		
		
		    private ToolInputSchema inputSchema;
		
		    private ToolAnnotations annotations;
		    /**
		     * Optional annotations for the client.
		     */
		
		    /**
		     * A description of what the tool does.
		     */
		    private String description;
		    /**
		     * The name of the tool.
		     */
		    private String name;
		    /**
		     * The type of the tool.
		     */
		    private String type;
		
		
		
		    public String getDescription() {
		        return description;
		    }
		
		    public void setDescription(String description) {
		        this.description = description;
		    }
		
		    public String getName() {
		        return name;
		    }
		
		    public void setName(String name) {
		        this.name = name;
		    }
		
		    public String getType() {
		        return type;
		    }
		
		    public void setType(String type) {
		        this.type = type;
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ToolAnnotations.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		
		import java.util.HashMap;
		import java.util.Map;
		
		@Data
		public class ToolAnnotations {
		    private Map<String, Object> properties = new HashMap<>();
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ToolCallRequest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		import java.util.HashMap;
		import java.util.Map;
		
		@Data
		@ToString
		public class ToolCallRequest {
		
		        private String name;
		        private Map<String, Object> arguments = new HashMap<>();
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ToolInputSchema.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		
		import javax.validation.constraints.NotNull;
		import java.util.List;
		import java.util.Map;
		
		@Data
		public class ToolInputSchema {
		    @NotNull
		    private final String type = "object";
		
		    private Map<String, ToolPropertySchema> properties;
		
		    private List<String> required;
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ToolParameter.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		@Data
		@ToString
		public class ToolParameter {
		    private String type;
		    private String description;
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ToolParameters.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		import lombok.ToString;
		
		import java.util.ArrayList;
		import java.util.HashMap;
		import java.util.List;
		import java.util.Map;
		
		@Data
		@ToString
		public class ToolParameters {
		    private String $schema = "http://json-schema.org/draft-07/schema#";
		    private String type = "object";
		    private Map<String, ToolParameter> properties = new HashMap<>();
		    private List<String> required = new ArrayList<>();
		    private boolean additionalProperties = false;
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\ToolPropertySchema.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import lombok.Data;
		
		import java.util.Map;
		
		@Data
		public class ToolPropertySchema {
		    private String type;
		    private String description;
		    private Map<String, Object> additionalProperties;
		    private boolean items;
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mcp\domain\UnsubscribeRequest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		public class UnsubscribeRequest extends ClientRequest {
		    private final String method = "resources/unsubscribe";
		    private Params params;
		
		    public String getMethod() {
		        return method;
		    }
		
		    public Params getParams() {
		        return params;
		    }
		
		    public void setParams(Params params) {
		        this.params = params;
		    }
		
		    public static class Params {
		        /**
		         * The URI of the resource to unsubscribe from.
		         */
		        private String uri;  // Changed from URI to String
		
		        public String getUri() {
		            return uri;
		        }
		
		        public void setUri(String uri) {
		            this.uri = uri;
		        }
		    }
		}</file>
	<file path='src\main\java\io\github\vishalmysore\mcp\server\MCPToolsController.java'><![CDATA[
		package io.github.vishalmysore.mcp.server;
		
		import com.fasterxml.jackson.databind.JsonNode;
		import com.fasterxml.jackson.databind.ObjectMapper;
		import com.t4a.JsonUtils;
		import com.t4a.api.AIAction;
		import com.t4a.api.GenericJavaMethodAction;
		import com.t4a.api.GroupInfo;
		import com.t4a.detect.ActionCallback;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.processor.*;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.common.MCPActionCallback;
		import io.github.vishalmysore.mcp.domain.*;
		import jakarta.annotation.PostConstruct;
		import lombok.Getter;
		import lombok.Setter;
		import lombok.extern.java.Log;
		import org.springframework.http.ResponseEntity;
		import org.springframework.stereotype.Service;
		import org.springframework.web.bind.annotation.*;
		
		import javax.annotation.Nullable;
		import java.io.IOException;
		import java.io.InputStream;
		import java.io.PrintWriter;
		import java.io.StringWriter;
		import java.lang.reflect.Method;
		import java.lang.reflect.Parameter;
		import java.util.*;
		
		//@//RestController
		//@RequestMapping("/mcp")
		@Log
		
		public class MCPToolsController  {
		
		    @Getter
		    private ListToolsResult toolsResult;
		
		    @Getter
		    private ListResourcesResult resourcesResult;
		
		    @Getter
		    private ListPromptsResult promptsResult;
		
		    private List<Prompt> prompts;
		
		    @Getter
		    private List<Resource> resources;
		    private AIProcessor baseProcessor = new GeminiV2ActionProcessor();
		    private PromptTransformer promptTransformer;
		
		    private JsonUtils utils = new JsonUtils();
		    public AIProcessor getBaseProcessor() {
		        return baseProcessor;
		    }
		
		    @Getter
		    @Setter
		    private String serverName = "MCP Tools Server";
		
		    @Getter
		    @Setter
		    private String version = "1.0.0";
		
		    @Getter
		    @Setter
		    private String protocolVersion ="2024-11-05";
		
		    public MCPToolsController(){
		
		    }
		    @PostConstruct
		    public void init() {
		
		        baseProcessor = PredictionLoader.getInstance().createOrGetAIProcessor();
		        promptTransformer = PredictionLoader.getInstance().createOrGetPromptTransformer();
		        Map<GroupInfo, String> groupActions = PredictionLoader.getInstance().getActionGroupList().getGroupActions();
		        List<Tool> tools = convertGroupActionsToTools(groupActions);
		
		        ListToolsResult newToolsResult = new ListToolsResult();
		        newToolsResult.setTools(tools);
		        storeListToolsResult(newToolsResult);
		        storeListReources(resources);
		        storeListPrompts(prompts);
		        setProperties();
		    }
		
		    public void setProperties() {
		        Map<Object, Object> tools4AIProperties = PredictionLoader.getInstance().getTools4AIProperties();
		
		        // Set serverName if the property is not null or empty
		        String serverName = (String) tools4AIProperties.get("mcp.tools.servername");
		        if (serverName != null && !serverName.trim().isEmpty()) {
		            setServerName(serverName);
		        }
		
		        // Set version if the property is not null or empty
		        String version = (String) tools4AIProperties.get("mcp.tools.version");
		        if (version != null && !version.trim().isEmpty()) {
		            setVersion(version);
		        }
		
		        // Set protocolVersion if the property is not null or empty
		        String protocolVersion = (String) tools4AIProperties.get("mcp.tools.protocolversion");
		        if (protocolVersion != null && !protocolVersion.trim().isEmpty()) {
		            setProtocolVersion(protocolVersion);
		        }
		    }
		
		    public void storeListReources(List<Resource> resources){
		        resourcesResult = new ListResourcesResult();
		        resourcesResult.setResources(resources);
		
		    }
		
		    public void storeListPrompts(List<Prompt> prompts){
		        promptsResult= new ListPromptsResult();
		        promptsResult.setPrompts(prompts);
		
		    }
		
		    public void storeListToolsResult(ListToolsResult toolsResult) {
		        this.toolsResult = toolsResult;
		    }
		
		    /**
		     * This will be used to add resources to the tools in subclasses
		     * @param result
		     */
		    public void addResources(ListResourcesResult result) {
		
		    }
		
		    public void addPrompts(ListPromptsResult result) {
		
		    }
		    public ResponseEntity<Map<String, String>> getServerConfig() {
		        return ResponseEntity.ok(Map.of(
		                "name", getServerName(),
		                "version", getVersion()
		        ));
		    }
		
		    private boolean validateSchema(ToolInputSchema schema) {
		        // Example validation logic (replace with actual JSON schema validation if needed)
		        if (schema.getProperties() == null || schema.getRequired() == null) {
		            log.severe("Schema validation failed: Missing properties or required fields.");
		            return false;
		        }
		        return true;
		    }
		
		    public void addResource(Method method) {
		       Class clazz = method.getReturnType();
		       if (Resource.class.isAssignableFrom(clazz)) {
		           Resource r = new Resource();
		           resources.add(r);
		       }
		
		    }
		
		    public void addPrompt(Tool tool) {
		        Prompt prompt = new Prompt();
		       // prompt.setAnnotations(tool.getAnnotations());
		
		    }
		
		    /**
		     * This can be implmented by subclasses to restrict the methods that can be used
		     * @param method
		     * @return
		     */
		    public boolean isMethodAllowed(Method method)    {
		        return true;
		    }
		    private List<Tool> convertGroupActionsToTools(Map<GroupInfo, String> groupActions) {
		        List<Tool> tools = new ArrayList<>();
		
		        Map<String, AIAction> predictions = PredictionLoader.getInstance().getPredictions();
		
		        for (Map.Entry<GroupInfo, String> entry : groupActions.entrySet()) {
		            GroupInfo group = entry.getKey();
		            String[] actionNames = entry.getValue().split(",");
		
		            for (String actionName : actionNames) {
		                AIAction action = predictions.get(actionName.trim());
		                if (action instanceof GenericJavaMethodAction) {
		                    GenericJavaMethodAction methodAction = (GenericJavaMethodAction) action;
		                    Method m = methodAction.getActionMethod();
		
		                    if(!isMethodAllowed(m))
		                        continue;
		                    addResource(m);
		
		                    log.info("Processing action: " + actionName);
		                    Tool tool = new Tool();
		                    tool.setName(action.getActionName());
		                    tool.setDescription(action.getDescription());
		
		                    // Create MCP-compatible parameters object
		                    ToolParameters parameters = new ToolParameters();
		                    Map<String, ToolPropertySchema> schemaProperties = new HashMap<>();
		                    List<String> requiredFields = new ArrayList<>();
		
		                    String jsonStr = methodAction.getActionParameters();
		                    AIProcessor processor = getBaseProcessor();
		                    String aiResponse = null;
		                    try {
		                        aiResponse = processor.query("I am giving you a json string check the parameters section and return the required fields including subfields as simple json, do not include any other commentary, control or special characters " + jsonStr);
		                        aiResponse = utils.extractJson(aiResponse);
		                        log.info(aiResponse);
		                    } catch (AIProcessingException e) {
		                        throw new RuntimeException(e);
		                    }
		
		                    String customParam = "provideAllValuesInPlainEnglish";
		
		                    // ToolParameters (for Claude/LLM)
		                    ToolParameter toolParam = new ToolParameter();
		                    toolParam.setType("string");
		                    toolParam.setDescription(aiResponse);
		                    parameters.getProperties().put(customParam, toolParam);
		
		                    // InputSchema (for MCP)
		                    ToolPropertySchema schema = new ToolPropertySchema();
		                    schema.setType("string");
		                    schema.setDescription(aiResponse);
		                    schema.setAdditionalProperties(new HashMap<>()); // Setting it to an empty map as required
		                    schemaProperties.put(customParam, schema);
		
		                    parameters.getRequired().add(customParam);
		                    requiredFields.add(customParam);
		                    ToolInputSchema inputSchema = new ToolInputSchema();
		                    inputSchema.setProperties(schemaProperties);
		                    inputSchema.setRequired(requiredFields);
		
		                    // Validate schema
		                    if (!validateSchema(inputSchema)) {
		                        log.severe("Invalid schema for tool: " + tool.getName());
		                        continue;
		                    }
		
		                    tool.setInputSchema(inputSchema);
		
		                    ToolAnnotations toolAnnotations = null;
		                    try {
		                        toolAnnotations = (ToolAnnotations)promptTransformer.transformIntoPojo("this is the tool name "+actionName+" and here are the parameterts it takes "+ jsonStr +"  I want you to give name name value pair describing what this tool does so that people can indentify this tool better", ToolAnnotations.class);
		                    } catch (AIProcessingException e) {
		                        log.warning(e.getMessage());
		                    }
		
		                    tool.setAnnotations(toolAnnotations);
		                    tools.add(tool);
		                    addPrompt(tool);
		                }
		            }
		        }
		        return tools;
		    }
		
		    private String getJsonType(Class<?> type) {
		        if (type == String.class) return "string";
		        if (type == Integer.class || type == int.class
		                || type == Double.class || type == double.class
		                || type == Float.class || type == float.class) return "number";
		        if (type == Boolean.class || type == boolean.class) return "boolean";
		        if (type.isArray() || Collection.class.isAssignableFrom(type)) return "array";
		        return "object";
		    }
		
		
		    public ResponseEntity<Map<String, List<Tool>>> listTools() {
		        Map<String, List<Tool>> response = new HashMap<>();
		        response.put("tools", toolsResult.getTools());
		        return ResponseEntity.ok(response);
		    }
		
		
		    public ResponseEntity<JSONRPCResponse> callTool(@RequestBody ToolCallRequest request) {
		        CallToolResult result = callToolWithCallback(request, new MCPActionCallback());
		        log.info("Received result: " + result);
		        JSONRPCResponse response = new JSONRPCResponse();
		        response.setId(UUID.randomUUID().toString());
		        response.setResult(result);
		        return ResponseEntity.ok(response);
		    }
		
		    public ResponseEntity<JSONRPCResponse> callTool(@RequestBody ToolCallRequest request,ActionCallback callback) {
		        CallToolResult result = callToolWithCallback(request, callback);
		        log.info("Received result: " + result);
		        JSONRPCResponse response = new JSONRPCResponse();
		        response.setId(UUID.randomUUID().toString());
		        response.setResult(result);
		        return ResponseEntity.ok(response);
		    }
		    public CallToolResult callToolWithCallback(@RequestBody ToolCallRequest request, ActionCallback callback) {
		        Map<String, AIAction> predictions = PredictionLoader.getInstance().getPredictions();
		        AIAction action = predictions.get(request.getName());
		        AIProcessor processor = getBaseProcessor();
		        CallToolResult callToolResult = new CallToolResult();
		        List<Content> content = new ArrayList<>();
		
		        try {
		            callback.setContext(callToolResult);
		            Object result = processAction(request, callback, processor, action);
		
		            if (result != null) {
		                if(result instanceof  Content) {
		                    content.add((Content) result);
		                } else {
		                    String resultStr = result.toString();
		                    // Check if result is Base64 encoded
		                        TextContent textContent = new TextContent();
		                        textContent.setType("text");
		                        textContent.setText(resultStr);
		                        content.add(textContent);
		
		                }
		            } else {
		                TextContent textContent = new TextContent();
		                textContent.setType("text");
		                textContent.setText("No result available");
		                content.add(textContent);
		            }
		        } catch (AIProcessingException e) {
		            TextContent textContent = new TextContent();
		            textContent.setType("text");
		            content.add(textContent);
		            StringWriter sw = new StringWriter();
		            PrintWriter pw = new PrintWriter(sw);
		            e.printStackTrace(pw);
		            textContent.setText("Technical issue occurred while processing the request: " + sw.toString());
		            log.severe(sw.toString());
		        }
		
		        callToolResult.setContent(content);
		        return callToolResult;
		    }
		
		    private boolean isBase64(String str) {
		        try {
		            Base64.getDecoder().decode(str);
		            return true;
		        } catch (IllegalArgumentException e) {
		            return false;
		        }
		    }
		    protected Object processAction(ToolCallRequest request, ActionCallback callback, AIProcessor processor, AIAction action) throws AIProcessingException {
		        Object result = processor.processSingleAction(request.toString(), action, new LoggingHumanDecision(), new LogginggExplainDecision(), callback);
		        return result;
		    }
		
		    private Object[] buildMethodArguments(Method method, String jsonStr) throws Exception {
		        Parameter[] parameters = method.getParameters();
		        Object[] args = new Object[parameters.length];
		        ObjectMapper objectMapper = new ObjectMapper();
		        JsonNode root = objectMapper.readTree(jsonStr);
		
		        for (int i = 0; i < parameters.length; i++) {
		            Parameter param = parameters[i];
		            JsonNode paramJson = root.get(param.getName());
		
		            if (paramJson != null) {
		                args[i] = objectMapper.treeToValue(paramJson, param.getType());
		            } else {
		                args[i] = null;
		            }
		        }
		
		        return args;
		    }
		
		
		
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mesh\AgentCatalog.java'><![CDATA[
		package io.github.vishalmysore.mesh;
		
		
		import com.t4a.JsonUtils;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.a2a.client.A2AAgent;
		import io.github.vishalmysore.common.Agent;
		import io.github.vishalmysore.common.AgentIdentity;
		import io.github.vishalmysore.common.AgentInfo;
		import io.github.vishalmysore.common.CommonClientResponse;
		import io.github.vishalmysore.mcp.client.MCPAgent;
		import lombok.Getter;
		import lombok.Setter;
		import lombok.extern.java.Log;
		
		import java.util.HashMap;
		import java.util.Map;
		import java.util.stream.Collectors;
		
		/**
		 * AgentCatalog is a class that manages a collection of agents, allowing for adding, retrieving, and processing queries through these agents.
		 * It supports both A2A and MCP agents, providing a unified interface for interacting with them.
		 */
		@Getter
		@Setter
		@Log
		public class AgentCatalog {
		    private Map<AgentIdentity,Agent> agents;
		    private PromptTransformer promptTransformer;
		    JsonUtils jsonUtils = new JsonUtils();
		
		    public AgentCatalog(){
		        log.info("Initializing AgentCatalog");
		        agents = new HashMap<>();
		        promptTransformer = PredictionLoader.getInstance().createOrGetPromptTransformer();
		    }
		
		    public Agent addAgent(String url) {
		        Agent a2agent = null;
		        try {
		            a2agent = new A2AAgent();
		            a2agent.connect(url);
		        } catch (Exception e) {
		            log.warning("Failed to connect to A2A agent at " + url + ": " + e.getMessage()+" will add as mcp agent");
		        }
		        if((a2agent ==null)||(!a2agent.isConnected())){
		            try {
		                a2agent = new MCPAgent();
		                a2agent.connect(url);
		            } catch (Exception e) {
		                log.warning("Failed to connect to MCP agent at " + url + ": " + e.getMessage());
		            }
		        }
		        if((a2agent ==null)||(!a2agent.isConnected())) {
		            log.warning("Not able to Connect to agent at " + url);
		        } else {
		            AgentIdentity a2agentIdentity = AgentIdentity.builder().info(a2agent.getInfo()).url(url).build();
		            agents.put(a2agentIdentity, a2agent);
		            log.info("Connected to agent at " + url + " with info: " + a2agent.getInfo());
		        }
		        return a2agent;
		    }
		
		    /**
		     * Get a comma-separated list of all agent info
		     * @return String containing agent information, empty string if no agents
		     */
		    public String getAgentsInfo() {
		        if (agents.isEmpty()) {
		            return "";
		        }
		        return agents.keySet().stream()
		                .map(AgentIdentity::toString)
		                .collect(Collectors.joining(", "));
		    }
		
		    /**
		     * Add an agent directly to the catalog
		     * @param agent The agent to add
		     * @return true if added successfully, false if agent was null or couldn't be added
		     */
		    public boolean addAgent(Agent agent) {
		        if (agent == null) {
		            log.warning("Attempted to add null agent");
		            return false;
		        }
		
		        AgentInfo info = agent.getInfo();
		        if (info == null) {
		            log.warning("Agent has null info, cannot add to catalog");
		            return false;
		        }
		        AgentIdentity a2agentIdentity = AgentIdentity.builder().info(agent.getInfo()).build();
		        agents.put(a2agentIdentity, agent);
		        log.info("Added agent with info: " + info);
		        return true;
		    }
		
		    /**
		     * Retrieve an agent by its info
		     * @param info The AgentInfo to look up
		     * @return The agent if found, null otherwise
		     */
		    public Agent retrieveAgent(AgentInfo info) {
		        if (info == null) {
		            log.warning("Attempted to retrieve agent with null info");
		            return null;
		        }
		        
		        // Find agent by matching info
		        return agents.entrySet().stream()
		            .filter(entry -> info.equals(entry.getKey().getAllTheCapabilitiesOfTheAgent()))
		            .map(Map.Entry::getValue)
		            .findFirst()
		            .orElse(null);
		    }
		
		    public Agent retrieveAgentByIdentity(AgentIdentity identity) {
		        if (identity == null) {
		            log.warning("Attempted to retrieve agent with null identity");
		            return null;
		        }
		
		        // Find agent by matching identity
		        return agents.get(identity);
		    }
		
		    public CommonClientResponse processQuery(String query) {
		        if (query == null || query.trim().isEmpty()) {
		            log.warning("Empty or null query provided");
		            return null;
		        }
		
		        // Process the query using the prompt transformer
		        String identiy = null;
		        String uniqueIdStr = "agentUniqueIDTobeUsedToIdentifyTheAgent";
		        try {
		            identiy = promptTransformer.transformIntoJson(jsonUtils.createJson(uniqueIdStr).toString()," this is user prompt { "+query+"}  I am trying to find which agent can handle it from this info {"+getAgentsInfo()+"}");
		        } catch (AIProcessingException e) {
		            log.severe("Error transforming query into JSON: " + e.getMessage());
		        }
		        log.info("Agent Identity: " + identiy);
		        Agent agent = retrieveAgentByID(jsonUtils.getFieldValue(identiy, uniqueIdStr));
		        log.info("Retrieved Agent: " + agent.getType());
		        CommonClientResponse response = agent.remoteMethodCall(query);
		        return response;
		    }
		
		
		    public Agent retrieveAgentByID(String agentId) {
		
		        try {
		
		            log.info("Retrieving agent by ID: " + agentId);
		            // Create an AgentIdentity to use as map key
		            return agents.entrySet().stream()
		                .filter(entry -> agentId.equals(entry.getKey().getAgentUniqueIDTobeUsedToIdentifyTheAgent()))
		                .map(Map.Entry::getValue)
		                .findFirst()
		                .orElse(null);
		                
		        } catch (Exception e) {
		            log.warning("Error parsing JSON or retrieving agent: " + e.getMessage());
		            return null;
		        }
		    }
		}]]></file>
	<file path='src\main\java\io\github\vishalmysore\mesh\AgenticMesh.java'><![CDATA[
		package io.github.vishalmysore.mesh;
		
		
		import com.t4a.JsonUtils;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.processor.AIProcessor;
		import com.t4a.transform.PromptTransformer;
		
		import io.github.vishalmysore.common.CommonClientResponse;
		import lombok.extern.slf4j.Slf4j;
		
		/**
		 * AgenticMesh is a class that implements various AI processing patterns such as Pipeline Mesh, Hub and Spoke, and Blackboard.
		 * It uses an AgentCatalog to process queries and an AIProcessor to handle AI-related tasks.
		 * The class also utilizes a PromptTransformer for transforming prompts into JSON format.
		 */
		@Slf4j
		public class AgenticMesh {
		    private final AgentCatalog agentCatalog;
		    private final AIProcessor aiProcessor;
		    private final PromptTransformer promptTransformer;
		    private final JsonUtils jsonUtils = new JsonUtils();
		
		    public AgenticMesh(AgentCatalog agentCatalog) {
		        this.agentCatalog = agentCatalog;
		        this.aiProcessor = PredictionLoader.getInstance().createOrGetAIProcessor();
		        this.promptTransformer = PredictionLoader.getInstance().createOrGetPromptTransformer();
		
		    }
		
		    public CommonClientResponse pipeLineMesh(String query){
		        return pipeLineMesh(query, null);
		    }
		
		    /**
		     * Processes a query using the Pipeline Mesh pattern.
		     * in this method the agents process data in sequence, each handling a specific part of the workflow.
		     * The method recursively processes the query until a complete response is obtained or no further processing is needed.
		     * @param query The initial query to be processed.
		     * @param previousResponse
		     * @return
		     */
		     public CommonClientResponse pipeLineMesh(String query, CommonClientResponse previousResponse) {
		        CommonClientResponse response = agentCatalog.processQuery(query);
		        String jsonYesOrNo = null;
		        String yesOrNoField = "is_User_Query_Answered_Fully_Yes_Or_No_Only";
		         String pendingQuery = "if_No_Then_What_Is_Pending_Query";
		        if(response ==null) {
		             return previousResponse;
		        } else {
		            try {
		                jsonYesOrNo= promptTransformer.transformIntoJson(jsonUtils.createJson(yesOrNoField,pendingQuery).toString(),"Original query "+query+ " response "+response +" ");
		
		                String yesOrNo = jsonUtils.getFieldValueFromMultipleFields(jsonYesOrNo, yesOrNoField);
		                if(yesOrNo.contains("Yes")) {
		                    return response;
		                } else {
		                    String pendingQueryValue = jsonUtils.getFieldValueFromMultipleFields(jsonYesOrNo, pendingQuery);
		                    response = pipeLineMesh("Pending query "+pendingQueryValue+ " response "+response.getTextResult() ,response);
		                }
		
		            } catch (AIProcessingException e) {
		               log.warn(e.getMessage());
		            }
		
		        }
		
		        return response;
		     }
		
		    /**
		     * Processes a query using the Hub and Spoke pattern.
		     * In this method, the main agent processes the query and identifies sub-queries needed to complete the answer.
		     * @param query
		     * @return
		     */
		    public CommonClientResponse hubAndSpoke(String query) {
		        CommonClientResponse mainResponse = agentCatalog.processQuery(query);
		        String jsonQueries = null;
		        String subQueriesField = "list_of_sub_queries_needed_to_complete_the_answer";
		
		        if (mainResponse == null) {
		            return null;
		        }
		
		        try {
		            // Get list of sub-queries needed
		            jsonQueries = promptTransformer.transformIntoJson(
		                    jsonUtils.createJson(subQueriesField).toString(),
		                    "Original query: " + query + " Initial response: " + mainResponse.getTextResult()
		            );
		
		            String subQueriesString = jsonUtils.getFieldValueFromMultipleFields(jsonQueries, subQueriesField);
		            if (subQueriesString == null || subQueriesString.isEmpty()) {
		                return mainResponse;
		            }
		
		            // Convert comma-separated queries to list
		            String[] subQueries = subQueriesString.split(",");
		            StringBuilder aggregatedResponse = new StringBuilder(mainResponse.getTextResult());
		
		            // Process each sub-query and aggregate responses
		            for (String subQuery : subQueries) {
		                CommonClientResponse subResponse = agentCatalog.processQuery(subQuery.trim());
		                if (subResponse != null) {
		                    aggregatedResponse.append("\n").append(subResponse.getTextResult());
		                }
		            }
		
		            // Final processing to combine all responses
		            return agentCatalog.processQuery("Combine and summarize: " + aggregatedResponse);
		
		        } catch (AIProcessingException e) {
		            return mainResponse;
		        }
		    }
		
		    /**
		     * Processes a query using the Blackboard pattern.
		     * In this method, the initial knowledge is processed, and then expert agents are queried to fill knowledge gaps.
		     * The contributions from each expert are aggregated into a blackboard for final synthesis.
		     * @param query
		     * @return
		     */
		
		    public CommonClientResponse blackboard(String query) {
		        CommonClientResponse initialKnowledge = agentCatalog.processQuery(query);
		        String jsonAnalysis = null;
		        String knowledgeGapsField = "knowledge_gaps_to_investigate";
		        String expertAgentsField = "required_expert_agents";
		
		        if (initialKnowledge == null) {
		            return null;
		        }
		
		        try {
		            // Identify knowledge gaps and required expert agents
		            jsonAnalysis = promptTransformer.transformIntoJson(
		                    jsonUtils.createJson(knowledgeGapsField, expertAgentsField).toString(),
		                    "Analyze knowledge gaps and required experts for: " + initialKnowledge.getTextResult()
		            );
		
		            String gaps = jsonUtils.getFieldValueFromMultipleFields(jsonAnalysis, knowledgeGapsField);
		            String experts = jsonUtils.getFieldValueFromMultipleFields(jsonAnalysis, expertAgentsField);
		
		            if (gaps == null || experts == null) {
		                return initialKnowledge;
		            }
		
		            // Knowledge base to store all contributions
		            StringBuilder blackboard = new StringBuilder(initialKnowledge.getTextResult());
		            String[] requiredExperts = experts.split(",");
		            String[] knowledgeGaps = gaps.split(",");
		
		            // Each expert contributes their specialized knowledge
		            for (int i = 0; i < requiredExperts.length && i < knowledgeGaps.length; i++) {
		                String expertQuery = String.format("As a %s expert, address: %s\nCurrent knowledge: %s",
		                        requiredExperts[i].trim(),
		                        knowledgeGaps[i].trim(),
		                        blackboard.toString());
		
		                CommonClientResponse expertResponse = agentCatalog.processQuery(expertQuery);
		                if (expertResponse != null) {
		                    blackboard.append("\n\nExpert ").append(requiredExperts[i].trim())
		                            .append(" contribution:\n").append(expertResponse.getTextResult());
		                }
		            }
		
		            // Final synthesis of all contributions
		            return agentCatalog.processQuery(
		                    "Synthesize all expert contributions into a coherent response:\n" + blackboard.toString()
		            );
		
		        } catch (AIProcessingException e) {
		
		            return initialKnowledge;
		        }
		    }
		
		}]]></file>
	<file path='src\main\resources\a2a.json'>
		{
		    "$schema": "http://json-schema.org/draft-07/schema#",
		    "title": "A2A Protocol Schema",
		    "description": "JSON Schema for A2A Protocol",
		    "$defs": {
		      "AgentAuthentication": {
		        "properties": {
		          "schemes": {
		            "items": {
		              "type": "string"
		            },
		            "title": "Schemes",
		            "type": "array"
		          },
		          "credentials": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Credentials"
		          }
		        },
		        "required": [
		          "schemes"
		        ],
		        "title": "AgentAuthentication",
		        "type": "object"
		      },
		      "AgentCapabilities": {
		        "properties": {
		          "streaming": {
		            "default": false,
		            "title": "Streaming",
		            "type": "boolean"
		          },
		          "pushNotifications": {
		            "default": false,
		            "title": "PushNotifications",
		            "type": "boolean"
		          },
		          "stateTransitionHistory": {
		            "default": false,
		            "title": "Statetransitionhistory",
		            "type": "boolean"
		          }
		        },
		        "title": "AgentCapabilities",
		        "type": "object"
		      },
		      "AgentCard": {
		        "properties": {
		          "name": {
		            "title": "Name",
		            "type": "string"
		          },
		          "description": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Description"
		          },
		          "url": {
		            "title": "Url",
		            "type": "string"            
		          },
		          "provider": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/AgentProvider"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "version": {
		            "title": "Version",
		            "type": "string"
		          },
		          "documentationUrl": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Documentationurl"
		          },
		          "capabilities": {
		            "$ref": "#/$defs/AgentCapabilities"
		          },
		          "authentication": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/AgentAuthentication"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "defaultInputModes": {
		            "default": [
		              "text"
		            ],
		            "items": {
		              "type": "string"
		            },
		            "title": "Defaultinputmodes",
		            "type": "array"
		          },
		          "defaultOutputModes": {
		            "default": [
		              "text"
		            ],
		            "items": {
		              "type": "string"
		            },
		            "title": "Defaultoutputmodes",
		            "type": "array"
		          },
		          "skills": {
		            "items": {
		              "$ref": "#/$defs/AgentSkill"
		            },
		            "title": "Skills",
		            "type": "array"
		          }
		        },
		        "required": [
		          "name",
		          "url",
		          "version",
		          "capabilities",
		          "skills"
		        ],
		        "title": "AgentCard",
		        "type": "object"
		      },
		      "AgentProvider": {
		        "properties": {
		          "organization": {
		            "title": "Organization",
		            "type": "string"
		          },
		          "url": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Url"
		          }
		        },
		        "required": [
		          "organization"
		        ],
		        "title": "AgentProvider",
		        "type": "object"
		      },
		      "AgentSkill": {
		        "properties": {
		          "id": {
		            "title": "Id",
		            "type": "string"
		          },
		          "name": {
		            "title": "Name",
		            "type": "string"
		          },
		          "description": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Description"
		          },
		          "tags": {
		            "anyOf": [
		              {
		                "items": {
		                  "type": "string"
		                },
		                "type": "array"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Tags"
		          },
		          "examples": {
		            "anyOf": [
		              {
		                "items": {
		                  "type": "string"
		                },
		                "type": "array"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Examples"
		          },
		          "inputModes": {
		            "anyOf": [
		              {
		                "items": {
		                  "type": "string"
		                },
		                "type": "array"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Inputmodes"
		          },
		          "outputModes": {
		            "anyOf": [
		              {
		                "items": {
		                  "type": "string"
		                },
		                "type": "array"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Outputmodes"
		          }
		        },
		        "required": [
		          "id",
		          "name"
		        ],
		        "title": "AgentSkill",
		        "type": "object"
		      },
		      "Artifact": {
		        "properties": {
		          "name": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Name"
		          },
		          "description": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Description"
		          },
		          "parts": {
		            "items": {
		              "$ref": "#/$defs/Part"
		            },
		            "title": "Parts",
		            "type": "array"
		          },
		          "index": {
		            "type": "integer",
		            "default": 0,
		            "title": "Index"
		          },
		          "append": {
		            "anyOf": [
		              {
		                "type": "boolean"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Append"
		          },
		          "lastChunk": {
		            "anyOf": [
		              {
		                "type": "boolean"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "LastChunk"
		          },
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "parts"
		        ],
		        "title": "Artifact",
		        "type": "object"
		      },
		      "AuthenticationInfo": {
		        "additionalProperties": {},
		        "properties": {
		          "schemes": {
		            "items": {
		              "type": "string"
		            },
		            "title": "Schemes",
		            "type": "array"
		          },
		          "credentials": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Credentials"
		          }
		        },
		        "required": [
		          "schemes"
		        ],
		        "title": "AuthenticationInfo",
		        "type": "object"
		      },
		      "PushNotificationNotSupportedError": {
		        "properties": {
		          "code": {
		            "const": -32003,
		            "default": -32003,
		            "description": "Error code",
		            "examples": [
		              -32003
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "Push Notification is not supported",
		            "default": "Push Notification is not supported",
		            "description": "A short description of the error",
		            "examples": [
		              "Push Notification is not supported"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "const": null,
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message",
		          "data"
		        ],
		        "title": "PushNotificationNotSupportedError",
		        "type": "object"
		      },
		      "CancelTaskRequest": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "method": {
		            "const": "tasks/cancel",
		            "default": "tasks/cancel",
		            "title": "Method",
		            "type": "string"
		          },
		          "params": {
		            "$ref": "#/$defs/TaskIdParams"
		          }
		        },
		        "required": [
		          "method",
		          "params"
		        ],
		        "title": "CancelTaskRequest",
		        "type": "object"
		      },
		      "CancelTaskResponse": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "result": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/Task"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "error": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/JSONRPCError"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          }
		        },
		        "title": "CancelTaskResponse",
		        "type": "object"
		      },
		      "DataPart": {
		        "properties": {
		          "type": {
		            "const": "data",
		            "default": "data",
		            "description": "Type of the part",
		            "examples": [
		              "data"
		            ],
		            "title": "Type",
		            "type": "string"
		          },
		          "data": {
		            "additionalProperties": {},
		            "title": "Data",
		            "type": "object"
		          },
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "type",
		          "data"
		        ],
		        "title": "DataPart",
		        "type": "object"
		      },
		      "FileContent": {
		        "properties": {
		          "name": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Name"
		          },
		          "mimeType": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Mimetype"
		          },
		          "bytes": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Bytes"
		          },
		          "uri": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Uri"
		          }
		        },
		        "title": "FileContent",
		        "type": "object",
		        "description": "Represents the content of a file, either as base64 encoded bytes or a URI.\n\nEnsures that either 'bytes' or 'uri' is provided, but not both."
		      },
		      "FilePart": {
		        "properties": {
		          "type": {
		            "const": "file",
		            "default": "file",
		            "description": "Type of the part",
		            "examples": [
		              "file"
		            ],
		            "title": "Type",
		            "type": "string"
		          },
		          "file": {
		            "$ref": "#/$defs/FileContent"
		          },
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "type",
		          "file"
		        ],
		        "title": "FilePart",
		        "type": "object"
		      },
		      "GetTaskPushNotificationRequest": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "method": {
		            "const": "tasks/pushNotification/get",
		            "default": "tasks/pushNotification/get",
		            "title": "Method",
		            "type": "string"
		          },
		          "params": {
		            "$ref": "#/$defs/TaskIdParams"
		          }
		        },
		        "required": [
		          "method",
		          "params"
		        ],
		        "title": "GetTaskPushNotificationRequest",
		        "type": "object"
		      },
		      "GetTaskPushNotificationResponse": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "result": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/TaskPushNotificationConfig"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "error": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/JSONRPCError"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          }
		        },
		        "title": "GetTaskPushNotificationResponse",
		        "type": "object"
		      },      
		      "GetTaskRequest": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "method": {
		            "const": "tasks/get",
		            "default": "tasks/get",
		            "title": "Method",
		            "type": "string"
		          },
		          "params": {
		            "$ref": "#/$defs/TaskQueryParams"
		          }
		        },
		        "required": [
		          "method",
		          "params"
		        ],
		        "title": "GetTaskRequest",
		        "type": "object"
		      },
		      "GetTaskResponse": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "result": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/Task"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "error": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/JSONRPCError"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          }
		        },
		        "title": "GetTaskResponse",
		        "type": "object"
		      },
		      "InternalError": {
		        "properties": {
		          "code": {
		            "const": -32603,
		            "default": -32603,
		            "description": "Error code",
		            "examples": [
		              -32603
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "Internal error",
		            "default": "Internal error",
		            "description": "A short description of the error",
		            "examples": [
		              "Internal error"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message"
		        ],
		        "title": "InternalError",
		        "type": "object"
		      },
		      "InvalidParamsError": {
		        "properties": {
		          "code": {
		            "const": -32602,
		            "default": -32602,
		            "description": "Error code",
		            "examples": [
		              -32602
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "Invalid parameters",
		            "default": "Invalid parameters",
		            "description": "A short description of the error",
		            "examples": [
		              "Invalid parameters"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message"
		        ],
		        "title": "InvalidParamsError",
		        "type": "object"
		      },
		      "InvalidRequestError": {
		        "properties": {
		          "code": {
		            "const": -32600,
		            "default": -32600,
		            "description": "Error code",
		            "examples": [
		              -32600
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "Request payload validation error",
		            "default": "Request payload validation error",
		            "description": "A short description of the error",
		            "examples": [
		              "Request payload validation error"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message"
		        ],
		        "title": "InvalidRequestError",
		        "type": "object"
		      },
		      "JSONParseError": {
		        "properties": {
		          "code": {
		            "const": -32700,
		            "default": -32700,
		            "description": "Error code",
		            "examples": [
		              -32700
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "Invalid JSON payload",
		            "default": "Invalid JSON payload",
		            "description": "A short description of the error",
		            "examples": [
		              "Invalid JSON payload"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message"
		        ],
		        "title": "JSONParseError",
		        "type": "object"
		      },
		      "JSONRPCError": {
		        "properties": {
		          "code": {
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message"
		        ],
		        "title": "JSONRPCError",
		        "type": "object"
		      },
		      "JSONRPCMessage": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          }
		        },
		        "title": "JSONRPCMessage",
		        "type": "object"
		      },
		      "JSONRPCRequest": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "method": {
		            "title": "Method",
		            "type": "string"
		          },
		          "params": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Params"
		          }
		        },
		        "required": [
		          "method"
		        ],
		        "title": "JSONRPCRequest",
		        "type": "object"
		      },
		      "JSONRPCResponse": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "result": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Result"
		          },
		          "error": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/JSONRPCError"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          }
		        },
		        "title": "JSONRPCResponse",
		        "type": "object"
		      },
		      "Message": {
		        "properties": {
		          "role": {
		            "enum": [
		              "user",
		              "agent"
		            ],
		            "title": "Role",
		            "type": "string"
		          },
		          "parts": {
		            "items": {
		              "$ref": "#/$defs/Part"
		            },
		            "title": "Parts",
		            "type": "array"
		          },          
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "role",
		          "parts"
		        ],
		        "title": "Message",
		        "type": "object"
		      },
		      "MethodNotFoundError": {
		        "properties": {
		          "code": {
		            "const": -32601,
		            "default": -32601,
		            "description": "Error code",
		            "examples": [
		              -32601
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "Method not found",
		            "default": "Method not found",
		            "description": "A short description of the error",
		            "examples": [
		              "Method not found"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "const": null,
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message",
		          "data"
		        ],
		        "title": "MethodNotFoundError",
		        "type": "object"
		      },
		      "PushNotificationConfig": {
		        "properties": {
		          "url": {
		            "title": "Url",
		            "type": "string"
		          },
		          "token": {
		            "title": "Token",
		            "anyOf": [              
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ]
		          },
		          "authentication": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/AuthenticationInfo"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          }
		        },
		        "required": [
		          "url"
		        ],
		        "title": "PushNotificationConfig",
		        "type": "object"
		      },
		      "Part": {
		        "anyOf": [
		          {
		            "$ref": "#/$defs/TextPart"
		          },
		          {
		            "$ref": "#/$defs/FilePart"
		          },
		          {
		            "$ref": "#/$defs/DataPart"
		          }
		        ],
		        "title": "Part"
		      },
		      "SendTaskRequest": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "method": {
		            "const": "tasks/send",
		            "default": "tasks/send",
		            "title": "Method",
		            "type": "string"
		          },
		          "params": {
		            "$ref": "#/$defs/TaskSendParams"
		          }
		        },
		        "required": [
		          "method",
		          "params"
		        ],
		        "title": "SendTaskRequest",
		        "type": "object"
		      },      
		      "SendTaskResponse": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "result": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/Task"
		              },              
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "error": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/JSONRPCError"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          }
		        },
		        "title": "SendTaskResponse",
		        "type": "object"
		      },
		      "SendTaskStreamingRequest": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "method": {
		            "const": "tasks/sendSubscribe",
		            "default": "tasks/sendSubscribe",
		            "title": "Method",
		            "type": "string"
		          },
		          "params": {
		            "$ref": "#/$defs/TaskSendParams"
		          }
		        },
		        "required": [
		          "method",
		          "params"
		        ],
		        "title": "SendTaskStreamingRequest",
		        "type": "object"
		      },
		      "SendTaskStreamingResponse": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "result": {
		            "anyOf": [              
		              {
		                "$ref": "#/$defs/TaskStatusUpdateEvent"
		              },
		              {
		                "$ref": "#/$defs/TaskArtifactUpdateEvent"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "error": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/JSONRPCError"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          }
		        },
		        "title": "SendTaskStreamingResponse",
		        "type": "object"
		      },
		      "SetTaskPushNotificationRequest": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "method": {
		            "const": "tasks/pushNotification/set",
		            "default": "tasks/pushNotification/set",
		            "title": "Method",
		            "type": "string"
		          },
		          "params": {
		            "$ref": "#/$defs/TaskPushNotificationConfig"
		          }
		        },
		        "required": [
		          "method",
		          "params"
		        ],
		        "title": "SetTaskPushNotificationRequest",
		        "type": "object"
		      },
		      "SetTaskPushNotificationResponse": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "result": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/TaskPushNotificationConfig"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "error": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/JSONRPCError"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          }
		        },
		        "title": "SetTaskPushNotificationResponse",
		        "type": "object"
		      },
		      "Task": {
		        "properties": {
		          "id": {
		            "title": "Id",
		            "type": "string"
		          },
		          "sessionId": {
		            "anyOf": [
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Sessionid"
		          },
		          "status": {
		            "$ref": "#/$defs/TaskStatus"
		          },
		          "artifacts": {
		            "anyOf": [
		              {
		                "items": {
		                  "$ref": "#/$defs/Artifact"
		                },
		                "type": "array"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Artifacts"
		          },
		          "history": {
		            "anyOf": [
		              {
		                "items": {
		                  "$ref": "#/$defs/Message"
		                },
		                "type": "array"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "History"
		          },
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "id",
		          "status"
		        ],
		        "title": "Task",
		        "type": "object"
		      },
		      "TaskPushNotificationConfig": {
		        "properties": {
		          "id": {
		            "title": "Id",
		            "type": "string"
		          },
		          "pushNotificationConfig": {
		            "$ref": "#/$defs/PushNotificationConfig"
		          }
		        },
		        "required": [
		          "id",
		          "pushNotificationConfig"
		        ],
		        "title": "TaskPushNotificationConfig",
		        "type": "object"
		      },      
		      "TaskNotCancelableError": {
		        "properties": {
		          "code": {
		            "const": -32002,
		            "default": -32002,
		            "description": "Error code",
		            "examples": [
		              -32002
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "Task cannot be canceled",
		            "default": "Task cannot be canceled",
		            "description": "A short description of the error",
		            "examples": [
		              "Task cannot be canceled"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "const": null,
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message",
		          "data"
		        ],
		        "title": "TaskNotCancelableError",
		        "type": "object"
		      },
		      "TaskNotFoundError": {
		        "properties": {
		          "code": {
		            "const": -32001,
		            "default": -32001,
		            "description": "Error code",
		            "examples": [
		              -32001
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "Task not found",
		            "default": "Task not found",
		            "description": "A short description of the error",
		            "examples": [
		              "Task not found"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "const": null,
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message",
		          "data"
		        ],
		        "title": "TaskNotFoundError",
		        "type": "object"
		      },
		      "TaskIdParams": {
		        "properties": {
		          "id": {
		            "title": "Id",
		            "type": "string"
		          },
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "id"
		        ],
		        "title": "TaskIdParams",
		        "type": "object"
		      },
		      "TaskQueryParams": {
		        "properties": {
		          "id": {
		            "title": "Id",
		            "type": "string"
		          },
		          "historyLength": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },              
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "HistoryLength"
		          },          
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "id"
		        ],
		        "title": "TaskQueryParams",
		        "type": "object"
		      },
		      "TaskSendParams": {
		        "properties": {
		          "id": {
		            "title": "Id",
		            "type": "string"
		          },
		          "sessionId": {
		            "title": "Sessionid",
		            "type": "string"
		          },
		          "message": {
		            "$ref": "#/$defs/Message"
		          },          
		          "pushNotification": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/PushNotificationConfig"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "historyLength": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },              
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "HistoryLength"
		          },   
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "id",
		          "message"
		        ],
		        "title": "TaskSendParams",
		        "type": "object"
		      },
		      "TaskState": {
		        "description": "An enumeration.",
		        "enum": [
		          "submitted",
		          "working",
		          "input-required",
		          "completed",
		          "canceled",
		          "failed",
		          "unknown"
		        ],
		        "title": "TaskState",
		        "type": "string"
		      },
		      "TaskStatus": {
		        "properties": {
		          "state": {
		            "$ref": "#/$defs/TaskState"
		          },
		          "message": {
		            "anyOf": [
		              {
		                "$ref": "#/$defs/Message"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null
		          },
		          "timestamp": {
		            "format": "date-time",
		            "title": "Timestamp",
		            "type": "string"
		          }
		        },
		        "required": [
		          "state"
		        ],
		        "title": "TaskStatus",
		        "type": "object"
		      },
		      "TaskResubscriptionRequest": {
		        "properties": {
		          "jsonrpc": {
		            "const": "2.0",
		            "default": "2.0",
		            "title": "Jsonrpc",
		            "type": "string"
		          },
		          "id": {
		            "anyOf": [
		              {
		                "type": "integer"
		              },
		              {
		                "type": "string"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "title": "Id"
		          },
		          "method": {
		            "const": "tasks/resubscribe",
		            "default": "tasks/resubscribe",
		            "title": "Method",
		            "type": "string"
		          },
		          "params": {
		            "$ref": "#/$defs/TaskQueryParams"
		          }
		        },
		        "required": [
		          "method",
		          "params"
		        ],
		        "title": "TaskResubscriptionRequest",
		        "type": "object"
		      },
		      "TaskStatusUpdateEvent": {
		        "properties": {
		          "id": {
		            "title": "Id",
		            "type": "string"
		          },
		          "status": {
		            "$ref": "#/$defs/TaskStatus"
		          },
		          "final": {
		            "default": false,
		            "title": "Final",
		            "type": "boolean"
		          },
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "id",
		          "status"
		        ],
		        "title": "TaskStatusUpdateEvent",
		        "type": "object"
		      },
		      "TaskArtifactUpdateEvent": {
		        "properties": {
		          "id": {
		            "title": "Id",
		            "type": "string"
		          },
		          "artifact": {
		            "$ref": "#/$defs/Artifact"
		          },
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "id",
		          "artifact"
		        ],
		        "title": "TaskArtifactUpdateEvent",
		        "type": "object"
		      },
		      "TextPart": {
		        "properties": {
		          "type": {
		            "const": "text",
		            "default": "text",
		            "description": "Type of the part",
		            "examples": [
		              "text"
		            ],
		            "title": "Type",
		            "type": "string"
		          },
		          "text": {
		            "title": "Text",
		            "type": "string"
		          },
		          "metadata": {
		            "anyOf": [
		              {
		                "additionalProperties": {},
		                "type": "object"
		              },
		              {
		                "type": "null"
		              }
		            ],
		            "default": null,
		            "title": "Metadata"
		          }
		        },
		        "required": [
		          "type",
		          "text"
		        ],
		        "title": "TextPart",
		        "type": "object"
		      },
		      "UnsupportedOperationError": {
		        "properties": {
		          "code": {
		            "const": -32004,
		            "default": -32004,
		            "description": "Error code",
		            "examples": [
		              -32004
		            ],
		            "title": "Code",
		            "type": "integer"
		          },
		          "message": {
		            "const": "This operation is not supported",
		            "default": "This operation is not supported",
		            "description": "A short description of the error",
		            "examples": [
		              "This operation is not supported"
		            ],
		            "title": "Message",
		            "type": "string"
		          },
		          "data": {
		            "const": null,
		            "default": null,
		            "title": "Data"
		          }
		        },
		        "required": [
		          "code",
		          "message",
		          "data"
		        ],
		        "title": "UnsupportedOperationError",
		        "type": "object"
		      },
		      "A2ARequest": {
		        "oneOf": [
		          {
		            "$ref": "#/$defs/SendTaskRequest"
		          },
		          {
		            "$ref": "#/$defs/GetTaskRequest"
		          },
		          {
		            "$ref": "#/$defs/CancelTaskRequest"
		          },          
		          {
		            "$ref": "#/$defs/SetTaskPushNotificationRequest"
		          },
		          {
		            "$ref": "#/$defs/GetTaskPushNotificationRequest"
		          },
		          {
		            "$ref": "#/$defs/TaskResubscriptionRequest"
		          }
		        ],
		        "title": "A2ARequest"
		      }
		    }
		  }</file>
	<file path='src\main\resources\a2ajava.cjs'>
		const http = require("http");
		
		const targetUrl = process.argv[2] || "http://localhost:7860"; // Get URL from arguments
		const { hostname, port, pathname } = new URL(targetUrl);
		
		process.stdin.setEncoding("utf8");
		
		let buffer = "";
		
		// More robust keep-alive mechanism
		const keepAliveInterval = setInterval(() => {
		  console.error("💓 Keep-alive ping...");
		}, 10000);
		
		// Handle termination signals properly
		process.on('SIGINT', () => {
		  console.error("Received SIGINT. Shutting down gracefully...");
		  clearInterval(keepAliveInterval);
		  process.exit(0);
		});
		
		process.on('uncaughtException', (err) => {
		  console.error("❌ Uncaught exception:", err);
		  // Don't exit, try to keep the process alive
		});
		
		process.stdin.on("data", (chunk) => {
		  buffer += chunk;
		  let boundary;
		  while ((boundary = buffer.indexOf("\n")) >= 0) {
		    const line = buffer.slice(0, boundary);
		    buffer = buffer.slice(boundary + 1);
		    if (line.trim()) {
		      traceAndForward(line);
		    }
		  }
		});
		
		function traceAndForward(line) {
		  try {
		    console.error("\n⬅️ Incoming from client:\n" + line);
		
		    const json = JSON.parse(line);
		    const postData = JSON.stringify(json);
		
		    const options = {
		      hostname,
		      port,
		      path: pathname || "/invoke",
		      method: "POST",
		      headers: {
		        "Content-Type": "application/json",
		        "Content-Length": Buffer.byteLength(postData),
		        "Connection": "keep-alive" // Explicitly keep the connection alive
		      },
		    };
		
		    const req = http.request(options, (res) => {
		      let responseBody = "";
		      res.setEncoding("utf8");
		      res.on("data", (chunk) => (responseBody += chunk));
		      res.on("end", () => {
		            if (responseBody.trim() === "") {
		                console.warn("⚠️ Empty response body received (likely a JSON-RPC notification).");
		                return; // Do nothing for empty body
		              }
		        try {
		          console.error("➡️ Response from Spring server:\n" + responseBody);
		          const response = JSON.parse(responseBody);
		          const finalResponse = JSON.stringify(response);
		          process.stdout.write(finalResponse + "\n");
		        } catch (e) {
		          console.error("❌ Failed to parse response from backend:", e.message);
		          // Send an error response to client instead of failing silently
		          const errorResponse = {
		            jsonrpc: "2.0",
		            id: json.id || null,
		            error: {
		              code: -32603,
		              message: "Internal error processing response: " + e.message
		            }
		          };
		          process.stdout.write(JSON.stringify(errorResponse) + "\n");
		        }
		      });
		    });
		
		    req.on("error", (e) => {
		      console.error("❌ Request error to Spring server:", e.message);
		      // Send error back to client
		      const errorResponse = {
		        jsonrpc: "2.0",
		        id: json.id || null,
		        error: {
		          code: -32603,
		          message: "Failed to connect to backend: " + e.message
		        }
		      };
		    //  process.stdout.write(JSON.stringify(errorResponse) + "\n");
		    });
		
		    req.write(postData);
		    req.end();
		  } catch (e) {
		    console.error("❌ Invalid JSON from client:", e.message);
		    // Send error back to client
		    try {
		      const errorResponse = {
		        jsonrpc: "2.0",
		        id: null,
		        error: {
		          code: -32700,
		          message: "Parse error: " + e.message
		        }
		      };
		      process.stdout.write(JSON.stringify(errorResponse) + "\n");
		    } catch (writeErr) {
		      console.error("❌ Failed to write error response:", writeErr);
		    }
		  }
		}
		
		// Log startup information
		console.error(`🚀 MCP passthrough server started, forwarding to ${targetUrl}`);</file>
	<file path='src\main\resources\mcpserver.js'>
		import { Server } from "@modelcontextprotocol/sdk/server/index.js";
		import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
		import { CallToolRequestSchema, ListResourcesRequestSchema, ListToolsRequestSchema, ReadResourceRequestSchema, } from "@modelcontextprotocol/sdk/types.js";
		import fs from 'node:fs/promises';
		
		const logFilePath = '/temp/proxy_server.log';
		
		const SERVER_BASE_URL = process.env.SERVER_BASE_URL || "http://localhost:7860";
		
		// Create server
		const server = new Server({
		  name: "springboot-proxy",
		  version: "1.0.0",
		}, {
		  capabilities: {
		    tools: {},  // We'll load tools dynamically from Spring Boot
		  },
		});
		
		// Handler: List tools from Spring Boot
		server.setRequestHandler(ListToolsRequestSchema, async () => {
		  try {
		    const response = await fetch("http://localhost:7860/v1/tools", {
		      method: "GET",
		      headers: { "Content-Type": "application/json" }
		    });
		
		    if (!response.ok) {
		      const errorMessage = `Failed to fetch tools: ${response.statusText}`;
		     // await logToFile(errorMessage);
		      throw new Error(errorMessage);
		    }
		
		    const data = await response.json();
		   // await logToFile(`Available tools from Spring Boot: ${JSON.stringify(data, null, 2)}`);
		    return {
		      tools: data.tools,
		    };
		  } catch (error) {
		    console.error("Error listing tools:", error);
		    throw error;
		  }
		});
		// Handler: Call a tool by proxying to Spring Boot
		server.setRequestHandler(CallToolRequestSchema, async (request) => {
		  try {
		  fs.appendFile(logFilePath, "receivedResponseLog", 'utf8');
		    // 🔍 Log the outgoing request
		    const outgoingRequestLog = "➡️ Sending request to Spring Boot:\n" + JSON.stringify({
		      name: request.params.name,
		      arguments: request.params.arguments ?? {},
		    }, null, 2);
		  //  await logToFile(outgoingRequestLog);
		
		    const response = await fetch("http://localhost:7860/v1/tools/call", {
		      method: "POST",
		      headers: { "Content-Type": "application/json" },
		      body: JSON.stringify({
		        name: request.params.name,
		        arguments: request.params.arguments ?? {},
		      }),
		    });
		
		    // ❌ Log failure if not OK
		    if (!response.ok) {
		      const errorText = await response.text();  // Read error body
		      const errorMessage = `❌ Tool call failed: ${response.statusText}\n🔻 Error response body: ${errorText}`;
		      await logToFile(errorMessage);
		      throw new Error(`Tool call failed: ${response.statusText}`);
		    }
		
		    // console.log(response.json());
		    // ✅ Log the response data
		    const data = await response.json();
		    fs.appendFile(logFilePath, "-----------------------------", 'utf8');
		    fs.appendFile(logFilePath, JSON.stringify(data["result"]), 'utf8');
		    fs.appendFile(logFilePath, "-----------------------------", 'utf8');
		
		    // Log the received response
		    // console.log("------------------------------------------");
		    // console.log("Received response from Spring Boot:", data);
		    // console.log("------------------------------------------");
		    // const receivedResponseLog = "✅ Received response from Spring Boot:\n" + JSON.stringify(data, null, 2);
		    //   fs.appendFile(logFilePath, receivedResponseLog, 'utf8');
		    // let res =  {"content":[{"annotations":null,"text":"Temprature for toronto is 18.0","type":"text"}],"isError":false,"_meta":null};
		    // json remove attribute _meta
		
		    const res = data.result;
		   // delete res._meta;
		   // delete res.isError;
		    // console.log("Received response from Spring Boot:", res);
		    return res; // Must match CallToolResponseSchema
		  } catch (error) {
		    console.error("Error calling tool:", error);
		    throw error;
		  }
		});
		
		
		
		// Launch server over stdio
		async function runServer() {
		  const transport = new StdioServerTransport();
		  await server.connect(transport);
		 // await logToFile("Proxy server is running on stdio...");
		}
		
		runServer().catch(console.error);</file>
	<file path='src\main\resources\package.json'>
		{
		  "name": "mcp-a2ajava-server",
		  "version": "0.1.1",
		  "description": "MCP server for interacting with SQL databases.",
		  "license": "MIT",
		  "author": "Vishal Mysore",
		  "homepage": "https://github.com/vishalmysore/a2ajava",
		  "bugs": "https://github.com/vishalmysore/a2ajava",
		  "type": "module",
		  "bin": {
		    "mcp-server-browserbase": "mcpserver.js"
		  },
		  "files": [
		    "dist"
		  ],
		
		  "dependencies": {
		    "@modelcontextprotocol/sdk": "^1.0.3",
		    "puppeteer-core": "^23.9.0"
		  },
		  "devDependencies": {
		    "shx": "^0.3.4",
		    "typescript": "^5.6.2"
		  }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\client\A2ATaskClientTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.client;
		
		import io.github.vishalmysore.a2a.domain.Task;
		import io.github.vishalmysore.a2a.domain.TaskState;
		import io.github.vishalmysore.a2a.domain.TaskStatus;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.springframework.http.HttpStatus;
		import org.springframework.web.client.HttpClientErrorException;
		import org.springframework.web.client.RestTemplate;
		import static org.junit.jupiter.api.Assertions.*;
		import static org.mockito.Mockito.*;
		
		public class A2ATaskClientTest {
		
		    private LocalA2ATaskClient client;
		   // private RestTemplate mockRestTemplate;
		   // private static final String CUSTOM_BASE_URL = "http://custom.api.com/rpc";
		
		    @BeforeEach
		    public void setUp() {
		     //   mockRestTemplate = mock(RestTemplate.class);
		        client = new LocalA2ATaskClient();
		    }
		
		
		
		  //  @Test
		    public void testSendTask() {
		        // Arrange
		        String prompt = "Book a flight from New York to Los Angeles";
		
		        // Act
		        Task task = client.sendTask(prompt);
		
		        // Assert
		        assertNotNull(task, "Task should not be null");
		        assertNotNull(task.getId(), "Task ID should not be null");
		        assertEquals(TaskState.SUBMITTED, task.getStatus().getState(), "Task should be in SUBMITTED state");
		      //  assertEquals(1, client.getPendingTasks().size(), "Should have one pending task");
		      //  assertEquals(0, client.getCompletedTasks().size(), "Should have no completed tasks");
		    }
		
		    @Test
		    public void testTaskCompletionFlow() {
		        // Arrange
		        String prompt = "Check flight status";
		        Task task = client.sendTask(prompt);
		        String taskId = task.getId();
		
		        // Act & Assert - Initial state
		        //assertEquals(1, client.getPendingTasks().size(), "Should have one pending task initially");
		        //assertEquals(0, client.getCompletedTasks().size(), "Should have no completed tasks initially");
		
		        // Simulate task completion by retrieving a completed task
		        Task completedTask = new Task();
		        completedTask.setId(taskId);
		        TaskStatus completedStatus = new TaskStatus(TaskState.COMPLETED);
		        completedTask.setStatus(completedStatus);
		        
		        // Update internal state by retrieving the "completed" task
		        client.getTask(taskId, 0);
		
		        // Assert final state
		       // assertEquals(0, client.getPendingTasks().size(), "Should have no pending tasks after completion");
		      //  assertEquals(1, client.getCompletedTasks().size(), "Should have one completed task");
		       // assertTrue(client.getCompletedTasks().stream()
		        //        .anyMatch(t -> t.getId().equals(taskId)),
		          //      "Completed tasks should contain the task ID");
		    }
		
		    @Test
		    public void testCancelTask() {
		        // Arrange
		        String prompt = "Book a hotel room";
		        Task task = client.sendTask(prompt);
		        String taskId = task.getId();
		       // assertEquals(1, client.getPendingTasks().size(), "Should have one pending task");
		
		        // Act
		       // boolean cancelled = client.cancelTask(taskId);
		
		        // Assert
		    //    assertTrue(cancelled, "Task should be successfully cancelled");
		      //  assertEquals(0, client.getPendingTasks().size(), "Should have no pending tasks after cancellation");
		     //   assertTrue(client.getPendingTasks().stream()
		       //         .noneMatch(t -> t.getId().equals(taskId)),
		       //         "Pending tasks should not contain the cancelled task");
		    }
		
		   /* @Test
		    public void testCustomBaseUrl() {
		        TaskClient customClient = new TaskClient(CUSTOM_BASE_URL);
		        assertNotNull(customClient, "Client should be initialized with custom URL");
		        
		        // Test sending task to custom URL
		        String prompt = "Test task";
		        Task task = customClient.sendTask(prompt);
		        assertNotNull(task, "Should create task with custom URL");
		    }
		    */
		
		    //@Test
		    public void testGetTaskWithHistory() {
		        // Arrange
		        String taskId = "test-task-123";
		        Integer historyLength = 5;
		        Task task = client.sendTask("Initial task");
		        
		        // Act
		        Task retrievedTask = client.getTask(taskId, historyLength);
		        
		        // Assert
		        assertNotNull(retrievedTask, "Retrieved task should not be null");
		        // Verify history length was respected - implementation specific assertions
		    }
		
		  //  @Test
		    public void testTaskStateTransitions() {
		        // Arrange
		        Task task = client.sendTask("Test state transitions");
		        String taskId = task.getId();
		        
		        // Assert initial state
		        assertEquals(TaskState.SUBMITTED, task.getStatus().getState());
		        
		        // Simulate processing state
		        task.setStatus(new TaskStatus(TaskState.SUBMITTED));
		        assertEquals(TaskState.SUBMITTED, task.getStatus().getState());
		        
		        // Simulate completion
		        task.setStatus(new TaskStatus(TaskState.COMPLETED));
		        assertEquals(TaskState.COMPLETED, task.getStatus().getState());
		    }
		
		
		//    @Test
		//    public void testTaskListManagement() {
		//        // Test empty lists initially
		//        assertTrue(client.getPendingTasks().isEmpty(), "Pending tasks should be empty initially");
		//        assertTrue(client.getCompletedTasks().isEmpty(), "Completed tasks should be empty initially");
		//
		//        // Add tasks and verify management
		//        Task task1 = client.sendTask("Task 1").getResult();
		//        Task task2 = client.sendTask("Task 2").getResult();
		//
		//        assertEquals(2, client.getPendingTasks().size(), "Should have two pending tasks");
		//
		//        // Complete one task
		//        task1.setStatus(new TaskStatus(TaskState.COMPLETED));
		//        client.getTask(task1.getId(), 0); // This should move task1 to completed
		//
		//        assertEquals(1, client.getPendingTasks().size(), "Should have one pending task");
		//        assertEquals(1, client.getCompletedTasks().size(), "Should have one completed task");
		//    }
		
		//    @Test
		//    public void testConcurrentTaskOperations() {
		//        // Test thread safety of task lists
		//        Task[] tasks = new Task[5];
		//        Thread[] threads = new Thread[5];
		//
		//        for (int i = 0; i < 5; i++) {
		//            final int index = i;
		//            threads[i] = new Thread(() -> {
		//                tasks[index] = client.sendTask("Concurrent task " + index).getResult();
		//            });
		//            threads[i].start();
		//        }
		//
		//        // Wait for all threads to complete
		//        for (Thread thread : threads) {
		//            try {
		//                thread.join();
		//            } catch (InterruptedException e) {
		//                fail("Thread interrupted");
		//            }
		//        }
		//
		//        assertEquals(5, client.getPendingTasks().size(), "Should have all tasks in pending list");
		//
		//        // Verify no duplicate tasks
		//        assertEquals(5, client.getPendingTasks().stream().map(Task::getId).distinct().count(),
		//                "Should have no duplicate tasks");
		//    }
		
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\A2ATaskTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class A2ATaskTest {
		
		    @Test
		    public void testA2ATaskInterface() {
		        // Since A2ATask is an interface, we can only test its implementation.
		        // Placeholder test to ensure the interface is accessible.
		        assertTrue(true, "A2ATask interface is accessible");
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\AgentCardTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class AgentCardTest {
		    
		    private AgentCard agentCard;
		    
		    @BeforeEach
		    public void setUp() {
		        agentCard = new AgentCard();
		    }
		
		    @Test
		    public void testAgentCardInitialization() {
		        assertNotNull(agentCard, "AgentCard should be initialized successfully");
		    }
		    
		    @Test
		    public void testBasicProperties() {
		        // Set properties
		        agentCard.setName("Test Agent");
		        agentCard.setDescription("A test agent for unit tests");
		        agentCard.setUrl("https://test-agent.example.com");
		        agentCard.setVersion("1.0.0");
		        agentCard.setDocumentationUrl("https://test-agent.example.com/docs");
		        
		        // Verify properties
		        assertEquals("Test Agent", agentCard.getName());
		        assertEquals("A test agent for unit tests", agentCard.getDescription());
		        assertEquals("https://test-agent.example.com", agentCard.getUrl());
		        assertEquals("1.0.0", agentCard.getVersion());
		        assertEquals("https://test-agent.example.com/docs", agentCard.getDocumentationUrl());
		    }
		    
		    @Test
		    public void testProviderProperty() {
		        Provider provider = new Provider();
		        provider.setOrganization("Test Organization");
		        provider.setUrl("https://provider.example.com");
		        
		        agentCard.setProvider(provider);
		        
		        assertNotNull(agentCard.getProvider());
		        assertEquals("Test Organization", agentCard.getProvider().getOrganization());
		        assertEquals("https://provider.example.com", agentCard.getProvider().getUrl());
		    }
		    
		    @Test
		    public void testCapabilitiesProperty() {
		        Capabilities capabilities = new Capabilities();
		        capabilities.setStreaming(true);
		        capabilities.setPushNotifications(false);
		        capabilities.setStateTransitionHistory(true);
		        
		        agentCard.setCapabilities(capabilities);
		        
		        assertNotNull(agentCard.getCapabilities());
		        assertTrue(agentCard.getCapabilities().isStreaming());
		        assertFalse(agentCard.getCapabilities().isPushNotifications());
		        assertTrue(agentCard.getCapabilities().isStateTransitionHistory());
		    }
		    
		    @Test
		    public void testAuthenticationProperty() {
		        Authentication authentication = new Authentication();
		        String[] schemes = {"Bearer"};
		        authentication.setSchemes(schemes);
		        authentication.setCredentials("test-token");
		        
		        agentCard.setAuthentication(authentication);
		        
		        assertNotNull(agentCard.getAuthentication());
		        assertArrayEquals(schemes, agentCard.getAuthentication().getSchemes());
		        assertEquals("test-token", agentCard.getAuthentication().getCredentials());
		    }
		    
		    @Test
		    public void testAuthenticationMethods() {
		        Authentication authentication = new Authentication();
		        
		        // Test Basic Auth
		        authentication.setBasicAuth("username", "password");
		        assertTrue(authentication.isBasicAuth());
		        assertFalse(authentication.isBearerAuth());
		        assertArrayEquals(new String[]{"Basic"}, authentication.getSchemes());
		        assertNotNull(authentication.getCredentials());
		        
		        // Test Bearer Auth
		        authentication.setBearerAuth("bearer-token");
		        assertTrue(authentication.isBearerAuth());
		        assertFalse(authentication.isBasicAuth());
		        assertArrayEquals(new String[]{"Bearer"}, authentication.getSchemes());
		        assertEquals("bearer-token", authentication.getCredentials());
		        
		        // Test API Key Auth
		        authentication.setApiKeyAuth("api-key");
		        assertArrayEquals(new String[]{"ApiKey"}, authentication.getSchemes());
		        assertEquals("api-key", authentication.getCredentials());
		        
		        agentCard.setAuthentication(authentication);
		        assertEquals(authentication, agentCard.getAuthentication());
		    }
		    
		    @Test
		    public void testDefaultModes() {
		        String[] inputModes = {"text"};
		        String[] outputModes = {"text", "json"};
		        
		        agentCard.setDefaultInputModes(inputModes);
		        agentCard.setDefaultOutputModes(outputModes);
		        
		        assertArrayEquals(inputModes, agentCard.getDefaultInputModes());
		        assertArrayEquals(outputModes, agentCard.getDefaultOutputModes());
		    }
		    
		    @Test
		    public void testAddSkill_WithNameAndDescription() {
		        agentCard.addSkill("Test Skill", "A test skill");
		        
		        assertNotNull(agentCard.getSkills());
		        assertEquals(1, agentCard.getSkills().size());
		        assertEquals("Test Skill", agentCard.getSkills().get(0).getName());
		        assertEquals("A test skill", agentCard.getSkills().get(0).getDescription());
		        assertNotNull(agentCard.getSkills().get(0).getId(), "Skill ID should be auto-generated");
		    }
		    
		    @Test
		    public void testAddSkill_WithNameDescriptionAndTags() {
		        String[] tags = {"tag1", "tag2"};
		        agentCard.addSkill("Test Skill", "A test skill", tags);
		        
		        assertNotNull(agentCard.getSkills());
		        assertEquals(1, agentCard.getSkills().size());
		        assertEquals("Test Skill", agentCard.getSkills().get(0).getName());
		        assertEquals("A test skill", agentCard.getSkills().get(0).getDescription());
		        assertArrayEquals(tags, agentCard.getSkills().get(0).getTags());
		    }
		    
		    @Test
		    public void testAddMultipleSkills() {
		        agentCard.addSkill("Skill 1", "First skill");
		        agentCard.addSkill("Skill 2", "Second skill");
		        
		        assertNotNull(agentCard.getSkills());
		        assertEquals(2, agentCard.getSkills().size());
		        assertEquals("Skill 1", agentCard.getSkills().get(0).getName());
		        assertEquals("Skill 2", agentCard.getSkills().get(1).getName());
		    }
		    
		    @Test
		    public void testEqualsAndHashCode() {
		        AgentCard card1 = new AgentCard();
		        card1.setName("Test Card");
		        card1.setVersion("1.0");
		        
		        AgentCard card2 = new AgentCard();
		        card2.setName("Test Card");
		        card2.setVersion("1.0");
		        
		        AgentCard card3 = new AgentCard();
		        card3.setName("Different Card");
		        card3.setVersion("1.0");
		        
		        // Test equals
		        assertEquals(card1, card2);
		        assertNotEquals(card1, card3);
		        
		        // Test hashCode
		        assertEquals(card1.hashCode(), card2.hashCode());
		        assertNotEquals(card1.hashCode(), card3.hashCode());
		    }
		    
		    @Test
		    public void testToString() {
		        agentCard.setName("Test Agent");
		        agentCard.setVersion("1.0.0");
		        
		        String toString = agentCard.toString();
		        
		        assertNotNull(toString);
		        assertTrue(toString.contains("name=Test Agent"));
		        assertTrue(toString.contains("version=1.0.0"));
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\ArtifactTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.ArrayList;
		import java.util.HashMap;
		import java.util.List;
		import java.util.Map;
		
		/**
		 * Test class for Artifact domain object
		 */
		public class ArtifactTest {
		
		    @Test
		    void testDefaultConstructor() {
		        Artifact artifact = new Artifact();
		        
		        assertNull(artifact.getId());
		        assertNull(artifact.getName());
		        assertNull(artifact.getDescription());
		        assertNull(artifact.getParts());
		        assertNotNull(artifact.getMetadata());
		        assertEquals(0, artifact.getIndex());
		        assertFalse(artifact.isAppend());
		        assertFalse(artifact.isLastChunk());
		    }
		
		    @Test
		    void testSettersAndGetters() {
		        Artifact artifact = new Artifact();
		        
		        // Test ID
		        String id = "artifact-123";
		        artifact.setId(id);
		        assertEquals(id, artifact.getId());
		        
		        // Test name
		        String name = "Test Artifact";
		        artifact.setName(name);
		        assertEquals(name, artifact.getName());
		        
		        // Test description
		        String description = "This is a test artifact";
		        artifact.setDescription(description);
		        assertEquals(description, artifact.getDescription());
		        
		        // Test parts
		        List<Part> parts = new ArrayList<>();
		        TextPart textPart = new TextPart();
		        textPart.setText("Hello world");
		        parts.add(textPart);
		        artifact.setParts(parts);
		        assertEquals(parts, artifact.getParts());
		        
		        // Test metadata
		        Map<String, String> metadata = new HashMap<>();
		        metadata.put("key1", "value1");
		        metadata.put("key2", "value2");
		        artifact.setMetadata(metadata);
		        assertEquals(metadata, artifact.getMetadata());
		        
		        // Test index
		        int index = 5;
		        artifact.setIndex(index);
		        assertEquals(index, artifact.getIndex());
		        
		        // Test append
		        artifact.setAppend(true);
		        assertTrue(artifact.isAppend());
		        
		        // Test lastChunk
		        artifact.setLastChunk(true);
		        assertTrue(artifact.isLastChunk());
		    }
		
		    @Test
		    void testMetadataInitialization() {
		        Artifact artifact = new Artifact();
		        
		        assertNotNull(artifact.getMetadata());
		        assertTrue(artifact.getMetadata().isEmpty());
		        
		        // Add metadata entries
		        artifact.getMetadata().put("created", "2023-01-01");
		        artifact.getMetadata().put("creator", "test-user");
		        
		        assertEquals(2, artifact.getMetadata().size());
		        assertEquals("2023-01-01", artifact.getMetadata().get("created"));
		        assertEquals("test-user", artifact.getMetadata().get("creator"));
		    }
		
		    @Test
		    void testToString() {
		        Artifact artifact = new Artifact();
		        artifact.setId("artifact-123");
		        artifact.setName("Test Artifact");
		        artifact.setDescription("Test Description");
		        artifact.setIndex(1);
		        artifact.setAppend(true);
		        artifact.setLastChunk(false);
		        
		        String toStringResult = artifact.toString();
		        
		        // Check all fields are included in toString
		        assertTrue(toStringResult.contains("id=artifact-123"));
		        assertTrue(toStringResult.contains("name=Test Artifact"));
		        assertTrue(toStringResult.contains("description=Test Description"));
		        assertTrue(toStringResult.contains("index=1"));
		        assertTrue(toStringResult.contains("append=true"));
		        assertTrue(toStringResult.contains("lastChunk=false"));
		        assertTrue(toStringResult.contains("metadata={}"));
		    }
		
		    @Test
		    void testEquals() {
		        Artifact artifact1 = new Artifact();
		        artifact1.setId("artifact-123");
		        artifact1.setName("Test Artifact");
		        
		        Artifact artifact2 = new Artifact();
		        artifact2.setId("artifact-123");
		        artifact2.setName("Test Artifact");
		        
		        Artifact artifact3 = new Artifact();
		        artifact3.setId("artifact-456");
		        artifact3.setName("Different Artifact");
		        
		        assertEquals(artifact1, artifact2);
		        assertNotEquals(artifact1, artifact3);
		    }
		
		    @Test
		    void testHashCode() {
		        Artifact artifact1 = new Artifact();
		        artifact1.setId("artifact-123");
		        artifact1.setName("Test Artifact");
		        
		        Artifact artifact2 = new Artifact();
		        artifact2.setId("artifact-123");
		        artifact2.setName("Test Artifact");
		        
		        assertEquals(artifact1.hashCode(), artifact2.hashCode());
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\AuthenticationTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		import java.util.Base64;
		
		/**
		 * Test class for Authentication domain object
		 */
		public class AuthenticationTest {
		
		    @Test
		    void testDefaultConstructor() {
		        Authentication auth = new Authentication();
		        assertNull(auth.getSchemes());
		        assertNull(auth.getCredentials());
		    }
		
		    @Test
		    void testConstructorWithSchemes() {
		        String[] schemes = new String[]{"Basic", "Bearer"};
		        Authentication auth = new Authentication(schemes);
		        assertArrayEquals(schemes, auth.getSchemes());
		        assertNull(auth.getCredentials());
		    }
		
		    @Test
		    void testSetBasicAuth() {
		        Authentication auth = new Authentication();
		        auth.setBasicAuth("username", "password");
		        
		        assertNotNull(auth.getSchemes());
		        assertEquals(1, auth.getSchemes().length);
		        assertEquals("Basic", auth.getSchemes()[0]);
		        
		        String expectedCredentials = Base64.getEncoder().encodeToString("username:password".getBytes());
		        assertEquals(expectedCredentials, auth.getCredentials());
		        assertTrue(auth.isBasicAuth());
		        assertFalse(auth.isBearerAuth());
		    }
		
		    @Test
		    void testSetBearerAuth() {
		        Authentication auth = new Authentication();
		        auth.setBearerAuth("my-token");
		        
		        assertNotNull(auth.getSchemes());
		        assertEquals(1, auth.getSchemes().length);
		        assertEquals("Bearer", auth.getSchemes()[0]);
		        
		        assertEquals("my-token", auth.getCredentials());
		        assertTrue(auth.isBearerAuth());
		        assertFalse(auth.isBasicAuth());
		    }
		
		    @Test
		    void testSetApiKeyAuth() {
		        Authentication auth = new Authentication();
		        auth.setApiKeyAuth("api-key-12345");
		        
		        assertNotNull(auth.getSchemes());
		        assertEquals(1, auth.getSchemes().length);
		        assertEquals("ApiKey", auth.getSchemes()[0]);
		        
		        assertEquals("api-key-12345", auth.getCredentials());
		        assertFalse(auth.isBasicAuth());
		        assertFalse(auth.isBearerAuth());
		    }
		
		    @Test
		    void testIsBasicAuth() {
		        Authentication auth = new Authentication();
		        
		        // Null schemes
		        assertFalse(auth.isBasicAuth());
		        
		        // Empty schemes
		        auth.setSchemes(new String[]{});
		        assertFalse(auth.isBasicAuth());
		        
		        // Non-Basic scheme
		        auth.setSchemes(new String[]{"Bearer"});
		        assertFalse(auth.isBasicAuth());
		        
		        // Basic scheme
		        auth.setSchemes(new String[]{"Basic"});
		        assertTrue(auth.isBasicAuth());
		    }
		
		    @Test
		    void testIsBearerAuth() {
		        Authentication auth = new Authentication();
		        
		        // Null schemes
		        assertFalse(auth.isBearerAuth());
		        
		        // Empty schemes
		        auth.setSchemes(new String[]{});
		        assertFalse(auth.isBearerAuth());
		        
		        // Non-Bearer scheme
		        auth.setSchemes(new String[]{"Basic"});
		        assertFalse(auth.isBearerAuth());
		        
		        // Bearer scheme
		        auth.setSchemes(new String[]{"Bearer"});
		        assertTrue(auth.isBearerAuth());
		    }
		
		    @Test
		    void testToStringExcludesCredentials() {
		        Authentication auth = new Authentication();
		        auth.setBasicAuth("username", "password");
		        
		        String toStringResult = auth.toString();
		        
		        // Should include schemes
		        assertTrue(toStringResult.contains("schemes"));
		        
		        // Should not include credential values
		        assertFalse(toStringResult.contains(auth.getCredentials()));
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\CancelTaskResponseTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.HashMap;
		import java.util.Map;
		
		/**
		 * Test class for CancelTaskResponse domain object
		 */
		public class CancelTaskResponseTest {
		
		    @Test
		    void testDefaultConstructor() {
		        CancelTaskResponse response = new CancelTaskResponse();
		        
		        assertEquals("2.0", response.getJsonrpc());
		        assertNull(response.getId());
		        assertNull(response.getResult());
		        assertNull(response.getError());
		    }
		
		    @Test
		    void testConstructorWithResult() {
		        String id = "request-123";
		        Task task = new Task();
		        task.setId("task-123");
		        
		        CancelTaskResponse response = new CancelTaskResponse(id, task);
		        
		        assertEquals("2.0", response.getJsonrpc());
		        assertEquals(id, response.getId());
		        assertEquals(task, response.getResult());
		        assertNull(response.getError());
		    }
		
		    @Test
		    void testConstructorWithError() {
		        String id = "request-123";
		        JSONRPCError error = new JSONRPCError(500, "Internal Server Error");
		        
		        CancelTaskResponse response = new CancelTaskResponse(id, error);
		        
		        assertEquals("2.0", response.getJsonrpc());
		        assertEquals(id, response.getId());
		        assertNull(response.getResult());
		        assertEquals(error, response.getError());
		    }
		
		    @Test
		    void testSettersAndGetters() {
		        CancelTaskResponse response = new CancelTaskResponse();
		        
		        // Test ID
		        String id = "request-123";
		        response.setId(id);
		        assertEquals(id, response.getId());
		        
		        // Test Result
		        Task task = new Task();
		        task.setId("task-123");
		        response.setResult(task);
		        assertEquals(task, response.getResult());
		        
		        // Test Error
		        JSONRPCError error = new JSONRPCError(400, "Bad Request");
		        response.setError(error);
		        assertEquals(error, response.getError());
		    }
		
		    @Test
		    void testJsonRpcVersion() {
		        CancelTaskResponse response = new CancelTaskResponse();
		        assertEquals("2.0", response.getJsonrpc());
		        
		        // Make sure jsonrpc is always 2.0 and can't be changed (final field)
		        // This is more of a compilation check, but the assertion confirms the value
		        assertEquals("2.0", response.getJsonrpc());
		    }
		
		    @Test
		    void testToString() {
		        String id = "request-123";
		        Task task = new Task();
		        task.setId("task-123");
		        
		        CancelTaskResponse response = new CancelTaskResponse(id, task);
		        String toStringResult = response.toString();
		        
		        assertTrue(toStringResult.contains("jsonrpc=2.0"));
		        assertTrue(toStringResult.contains("id=request-123"));
		        assertTrue(toStringResult.contains("result="));
		        assertTrue(toStringResult.contains("task-123"));
		    }
		
		    @Test
		    void testEquals() {
		        String id = "request-123";
		        Task task = new Task();
		        task.setId("task-123");
		        
		        CancelTaskResponse response1 = new CancelTaskResponse(id, task);
		        CancelTaskResponse response2 = new CancelTaskResponse(id, task);
		        CancelTaskResponse response3 = new CancelTaskResponse("different-id", task);
		        
		        assertEquals(response1, response2);
		        assertNotEquals(response1, response3);
		    }
		
		    @Test
		    void testHashCode() {
		        String id = "request-123";
		        Task task = new Task();
		        task.setId("task-123");
		        
		        CancelTaskResponse response1 = new CancelTaskResponse(id, task);
		        CancelTaskResponse response2 = new CancelTaskResponse(id, task);
		        
		        assertEquals(response1.hashCode(), response2.hashCode());
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\CapabilitiesTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		/**
		 * Test class for Capabilities domain object
		 */
		public class CapabilitiesTest {
		
		    @Test
		    void testDefaultConstructor() {
		        Capabilities capabilities = new Capabilities();
		        
		        assertFalse(capabilities.isStreaming());
		        assertFalse(capabilities.isPushNotifications());
		        assertFalse(capabilities.isStateTransitionHistory());
		    }
		
		    @Test
		    void testAllArgsConstructor() {
		        Capabilities capabilities = new Capabilities(true, true, true);
		        
		        assertTrue(capabilities.isStreaming());
		        assertTrue(capabilities.isPushNotifications());
		        assertTrue(capabilities.isStateTransitionHistory());
		    }
		
		    @Test
		    void testMixedCapabilitiesConstructor() {
		        Capabilities capabilities = new Capabilities(true, false, true);
		        
		        assertTrue(capabilities.isStreaming());
		        assertFalse(capabilities.isPushNotifications());
		        assertTrue(capabilities.isStateTransitionHistory());
		    }
		
		    @Test
		    void testSetters() {
		        Capabilities capabilities = new Capabilities();
		        
		        capabilities.setStreaming(true);
		        assertTrue(capabilities.isStreaming());
		        assertFalse(capabilities.isPushNotifications());
		        assertFalse(capabilities.isStateTransitionHistory());
		        
		        capabilities.setPushNotifications(true);
		        assertTrue(capabilities.isStreaming());
		        assertTrue(capabilities.isPushNotifications());
		        assertFalse(capabilities.isStateTransitionHistory());
		        
		        capabilities.setStateTransitionHistory(true);
		        assertTrue(capabilities.isStreaming());
		        assertTrue(capabilities.isPushNotifications());
		        assertTrue(capabilities.isStateTransitionHistory());
		    }
		
		    @Test
		    void testToString() {
		        Capabilities capabilities = new Capabilities(true, false, true);
		        String toStringResult = capabilities.toString();
		        
		        assertTrue(toStringResult.contains("streaming=true"));
		        assertTrue(toStringResult.contains("pushNotifications=false"));
		        assertTrue(toStringResult.contains("stateTransitionHistory=true"));
		    }
		
		    @Test
		    void testEquals() {
		        Capabilities capabilities1 = new Capabilities(true, false, true);
		        Capabilities capabilities2 = new Capabilities(true, false, true);
		        Capabilities capabilities3 = new Capabilities(false, false, true);
		        
		        assertEquals(capabilities1, capabilities2);
		        assertNotEquals(capabilities1, capabilities3);
		    }
		
		    @Test
		    void testHashCode() {
		        Capabilities capabilities1 = new Capabilities(true, false, true);
		        Capabilities capabilities2 = new Capabilities(true, false, true);
		        
		        assertEquals(capabilities1.hashCode(), capabilities2.hashCode());
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\DataPartTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import java.util.HashMap;
		import java.util.Map;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class DataPartTest {
		    
		    private DataPart dataPart;
		
		    @BeforeEach
		    void setUp() {
		        dataPart = new DataPart();
		    }
		
		    @Test
		    void testBasicDataPartCreation() {
		        assertNotNull(dataPart, "DataPart should be created successfully");
		        assertEquals("data", dataPart.getType(), "Default type should be 'data'");
		    }
		
		    @Test
		    void testDataOperations() {
		        // Create test data
		        Map<String, Object> data = new HashMap<>();
		        data.put("stringValue", "test");
		        data.put("intValue", 42);
		        data.put("boolValue", true);
		        
		        dataPart.setData(data);
		        assertEquals(data, dataPart.getData(), "Data should match set value");
		        assertEquals("test", dataPart.getData().get("stringValue"), "String value should match");
		        assertEquals(42, dataPart.getData().get("intValue"), "Integer value should match");
		        assertEquals(true, dataPart.getData().get("boolValue"), "Boolean value should match");
		    }
		
		    @Test
		    void testMetadataOperations() {
		        Map<String, String> metadata = new HashMap<>();
		        metadata.put("key1", "value1");
		        metadata.put("key2", "value2");
		        
		        dataPart.setMetadata(metadata);
		        assertEquals(metadata, dataPart.getMetadata(), "Metadata should match set value");
		        assertEquals("value1", dataPart.getMetadata().get("key1"), "Metadata value 1 should match");
		        assertEquals("value2", dataPart.getMetadata().get("key2"), "Metadata value 2 should match");
		    }
		
		    @Test
		    void testTypeOperations() {
		        assertEquals("data", dataPart.getType(), "Initial type should be 'data'");
		        
		        dataPart.setType("custom_data");
		        assertEquals("custom_data", dataPart.getType(), "Type should be updated");
		    }
		
		    @Test
		    void testNullValues() {
		        dataPart.setData(null);
		        assertNull(dataPart.getData(), "Data should allow null value");
		        
		        dataPart.setMetadata(null);
		        assertNull(dataPart.getMetadata(), "Metadata should allow null value");
		        
		        dataPart.setType(null);
		        assertNull(dataPart.getType(), "Type should allow null value");
		    }
		
		    @Test
		    void testComplexDataStructures() {
		        Map<String, Object> complexData = new HashMap<>();
		        
		        // Add nested map
		        Map<String, Object> nestedMap = new HashMap<>();
		        nestedMap.put("nestedKey", "nestedValue");
		        complexData.put("mapValue", nestedMap);
		        
		        // Add array/list values
		        complexData.put("arrayValue", new String[]{"one", "two", "three"});
		        
		        // Add null value
		        complexData.put("nullValue", null);
		        
		        dataPart.setData(complexData);
		        assertEquals(complexData, dataPart.getData(), "Complex data structure should be preserved");
		        assertNotNull(dataPart.getData().get("mapValue"), "Nested map should be preserved");
		        assertNull(dataPart.getData().get("nullValue"), "Null values should be preserved");
		    }
		
		    @Test
		    void testToString() {
		        Map<String, Object> data = new HashMap<>();
		        data.put("key", "value");
		        dataPart.setData(data);
		        
		        Map<String, String> metadata = new HashMap<>();
		        metadata.put("metaKey", "metaValue");
		        dataPart.setMetadata(metadata);
		        
		        String toString = dataPart.toString();
		        assertNotNull(toString, "toString should not be null");
		        assertTrue(toString.contains("data"), "toString should contain type");
		        assertTrue(toString.contains("key"), "toString should contain data key");
		        assertTrue(toString.contains("value"), "toString should contain data value");
		        assertTrue(toString.contains("metaKey"), "toString should contain metadata key");
		        assertTrue(toString.contains("metaValue"), "toString should contain metadata value");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\FileContentTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class FileContentTest {
		    
		    private FileContent fileContent;
		    private static final String TEST_NAME = "test.txt";
		    private static final String TEST_MIME_TYPE = "text/plain";
		    private static final String TEST_BYTES = "VGVzdCBjb250ZW50"; // base64 encoded "Test content"
		    private static final String TEST_URI = "http://example.com/test.txt";
		
		    @BeforeEach
		    void setUp() {
		        fileContent = new FileContent();
		    }
		
		    @Test
		    void testBasicFileContentCreation() {
		        assertNotNull(fileContent, "FileContent should be created successfully");
		    }
		
		    @Test
		    void testNameHandling() {
		        fileContent.setName(TEST_NAME);
		        assertEquals(TEST_NAME, fileContent.getName(), "Name should match set value");
		    }
		
		    @Test
		    void testMimeTypeHandling() {
		        fileContent.setMimeType(TEST_MIME_TYPE);
		        assertEquals(TEST_MIME_TYPE, fileContent.getMimeType(), "MIME type should match set value");
		    }
		
		    @Test
		    void testBytesHandling() {
		        fileContent.setBytes(TEST_BYTES);
		        assertEquals(TEST_BYTES, fileContent.getBytes(), "Bytes should match set value");
		    }
		
		    @Test
		    void testUriHandling() {
		        fileContent.setUri(TEST_URI);
		        assertEquals(TEST_URI, fileContent.getUri(), "URI should match set value");
		    }
		
		    @Test
		    void testNullValues() {
		        fileContent.setName(null);
		        fileContent.setMimeType(null);
		        fileContent.setBytes(null);
		        fileContent.setUri(null);
		        
		        assertNull(fileContent.getName(), "Name should allow null value");
		        assertNull(fileContent.getMimeType(), "MIME type should allow null value");
		        assertNull(fileContent.getBytes(), "Bytes should allow null value");
		        assertNull(fileContent.getUri(), "URI should allow null value");
		    }
		
		    @Test
		    void testEmptyValues() {
		        fileContent.setName("");
		        fileContent.setMimeType("");
		        fileContent.setBytes("");
		        fileContent.setUri("");
		        
		        assertEquals("", fileContent.getName(), "Name should allow empty string");
		        assertEquals("", fileContent.getMimeType(), "MIME type should allow empty string");
		        assertEquals("", fileContent.getBytes(), "Bytes should allow empty string");
		        assertEquals("", fileContent.getUri(), "URI should allow empty string");
		    }
		
		    @Test
		    void testToString() {
		        fileContent.setName(TEST_NAME);
		        fileContent.setMimeType(TEST_MIME_TYPE);
		        fileContent.setBytes(TEST_BYTES);
		        
		        String toString = fileContent.toString();
		        assertNotNull(toString, "toString should not be null");
		        assertTrue(toString.contains(TEST_NAME), "toString should contain name");
		        assertTrue(toString.contains(TEST_MIME_TYPE), "toString should contain MIME type");
		        assertTrue(toString.contains(TEST_BYTES), "toString should contain bytes");
		    }
		
		    @Test
		    void testCompleteFileContent() {
		        fileContent.setName(TEST_NAME);
		        fileContent.setMimeType(TEST_MIME_TYPE);
		        fileContent.setBytes(TEST_BYTES);
		        fileContent.setUri(TEST_URI);
		        
		        assertEquals(TEST_NAME, fileContent.getName(), "Name should match");
		        assertEquals(TEST_MIME_TYPE, fileContent.getMimeType(), "MIME type should match");
		        assertEquals(TEST_BYTES, fileContent.getBytes(), "Bytes should match");
		        assertEquals(TEST_URI, fileContent.getUri(), "URI should match");
		    }
		    
		    @Test
		    void testId() {
		        String testId = "test-id-123";
		        fileContent.setId(testId);
		        assertEquals(testId, fileContent.getId(), "ID should match set value");
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\FilePartTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import java.util.HashMap;
		import java.util.Map;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class FilePartTest {
		    
		    private FilePart filePart;
		    private static final String TEST_TYPE = "file";
		
		    @BeforeEach
		    void setUp() {
		        filePart = new FilePart();
		    }
		
		    @Test
		    void testBasicFilePartCreation() {
		        assertNotNull(filePart, "FilePart should be created successfully");
		        assertEquals(TEST_TYPE, filePart.getType(), "Default type should be 'file'");
		    }
		
		    @Test
		    void testFileContentOperations() {
		        FileContent fileContent = new FileContent();
		        fileContent.setName("test.txt");
		        fileContent.setBytes("VGVzdCBjb250ZW50"); // base64 encoded "Test content"
		        fileContent.setMimeType("text/plain");
		        
		        filePart.setFile(fileContent);
		        assertNotNull(filePart.getFile(), "File content should not be null");
		        assertEquals("test.txt", filePart.getFile().getName(), "File name should match");
		        assertEquals("VGVzdCBjb250ZW50", filePart.getFile().getBytes(), "File bytes should match");
		        assertEquals("text/plain", filePart.getFile().getMimeType(), "MIME type should match");
		    }
		
		    @Test
		    void testFileContentWithUri() {
		        FileContent fileContent = new FileContent();
		        fileContent.setName("test.txt");
		        fileContent.setUri("http://example.com/test.txt");
		        fileContent.setMimeType("text/plain");
		        
		        filePart.setFile(fileContent);
		        assertNotNull(filePart.getFile(), "File content should not be null");
		        assertEquals("test.txt", filePart.getFile().getName(), "File name should match");
		        assertEquals("http://example.com/test.txt", filePart.getFile().getUri(), "File URI should match");
		        assertEquals("text/plain", filePart.getFile().getMimeType(), "MIME type should match");
		    }
		
		    @Test
		    void testMetadataOperations() {
		        Map<String, String> metadata = new HashMap<>();
		        metadata.put("key1", "value1");
		        metadata.put("key2", "value2");
		        
		        filePart.setMetadata(metadata);
		        assertEquals(metadata, filePart.getMetadata(), "Metadata should match set value");
		        assertEquals("value1", filePart.getMetadata().get("key1"), "Should retrieve correct metadata value");
		    }
		
		    @Test
		    void testTypeOperations() {
		        assertEquals(TEST_TYPE, filePart.getType(), "Initial type should be 'file'");
		        
		        filePart.setType("custom_file");
		        assertEquals("custom_file", filePart.getType(), "Type should be updated");
		    }
		
		    @Test
		    void testNullValues() {
		        filePart.setFile(null);
		        assertNull(filePart.getFile(), "File content should allow null value");
		        
		        filePart.setMetadata(null);
		        assertNull(filePart.getMetadata(), "Metadata should allow null value");
		        
		        filePart.setType(null);
		        assertNull(filePart.getType(), "Type should allow null value");
		    }
		
		    @Test
		    void testFileContentWithEmptyValues() {
		        FileContent fileContent = new FileContent();
		        fileContent.setName("");
		        fileContent.setBytes("");
		        fileContent.setUri("");
		        fileContent.setMimeType("");
		        
		        filePart.setFile(fileContent);
		        assertNotNull(filePart.getFile(), "File content should not be null with empty values");
		        assertEquals("", filePart.getFile().getName(), "Empty file name should be preserved");
		        assertEquals("", filePart.getFile().getBytes(), "Empty bytes should be preserved");
		        assertEquals("", filePart.getFile().getUri(), "Empty URI should be preserved");
		        assertEquals("", filePart.getFile().getMimeType(), "Empty MIME type should be preserved");
		    }
		
		
		
		    @Test
		    void testWithVariousMimeTypes() {
		        FileContent fileContent = new FileContent();
		        
		        // Test common MIME types
		        String[][] mimeTests = {
		            {"text.txt", "text/plain"},
		            {"doc.pdf", "application/pdf"},
		            {"image.jpg", "image/jpeg"},
		            {"doc.json", "application/json"},
		            {"file.xml", "application/xml"}
		        };
		        
		        for (String[] test : mimeTests) {
		            fileContent.setName(test[0]);
		            fileContent.setMimeType(test[1]);
		            filePart.setFile(fileContent);
		            
		            assertEquals(test[1], filePart.getFile().getMimeType(), 
		                "Should handle " + test[1] + " MIME type");
		        }
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\JSONRPCErrorTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.HashMap;
		import java.util.Map;
		
		/**
		 * Test class for JSONRPCError domain object
		 */
		public class JSONRPCErrorTest {
		
		    @Test
		    void testDefaultConstructor() {
		        JSONRPCError error = new JSONRPCError();
		        
		        assertEquals(0, error.getCode());
		        assertNull(error.getMessage());
		        assertNull(error.getData());
		    }
		
		    @Test
		    void testConstructorWithCodeAndMessage() {
		        int code = 404;
		        String message = "Not Found";
		        
		        JSONRPCError error = new JSONRPCError(code, message);
		        
		        assertEquals(code, error.getCode());
		        assertEquals(message, error.getMessage());
		        assertNull(error.getData());
		    }
		
		    @Test
		    void testConstructorWithCodeMessageAndData() {
		        int code = 500;
		        String message = "Internal Server Error";
		        Map<String, Object> data = new HashMap<>();
		        data.put("stackTrace", "java.lang.Exception: Something went wrong");
		        data.put("timestamp", System.currentTimeMillis());
		        
		        JSONRPCError error = new JSONRPCError(code, message, data);
		        
		        assertEquals(code, error.getCode());
		        assertEquals(message, error.getMessage());
		        assertEquals(data, error.getData());
		    }
		
		    @Test
		    void testSettersAndGetters() {
		        JSONRPCError error = new JSONRPCError();
		        
		        // Test code
		        int code = 400;
		        error.setCode(code);
		        assertEquals(code, error.getCode());
		        
		        // Test message
		        String message = "Bad Request";
		        error.setMessage(message);
		        assertEquals(message, error.getMessage());
		        
		        // Test data
		        Map<String, Object> data = new HashMap<>();
		        data.put("field", "username");
		        data.put("issue", "Required field missing");
		        error.setData(data);
		        assertEquals(data, error.getData());
		    }
		
		    @Test
		    void testToString() {
		        int code = 403;
		        String message = "Forbidden";
		        Map<String, Object> data = new HashMap<>();
		        data.put("reason", "Insufficient permissions");
		        
		        JSONRPCError error = new JSONRPCError(code, message, data);
		        String toStringResult = error.toString();
		        
		        assertTrue(toStringResult.contains("code=403"));
		        assertTrue(toStringResult.contains("message=Forbidden"));
		        assertTrue(toStringResult.contains("data={reason=Insufficient permissions}"));
		    }
		
		    @Test
		    void testEquals() {
		        JSONRPCError error1 = new JSONRPCError(429, "Too Many Requests");
		        JSONRPCError error2 = new JSONRPCError(429, "Too Many Requests");
		        JSONRPCError error3 = new JSONRPCError(503, "Service Unavailable");
		        
		        assertEquals(error1, error2);
		        assertNotEquals(error1, error3);
		    }
		
		    @Test
		    void testHashCode() {
		        JSONRPCError error1 = new JSONRPCError(429, "Too Many Requests");
		        JSONRPCError error2 = new JSONRPCError(429, "Too Many Requests");
		        
		        assertEquals(error1.hashCode(), error2.hashCode());
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\MessageTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.ArrayList;
		import java.util.Arrays;
		import java.util.List;
		
		public class MessageTest {
		    private Message message;
		
		    @BeforeEach
		    public void setUp() {
		        message = new Message();
		    }
		
		    @Test
		    public void testMessageCreation() {
		        assertNotNull(message);
		        assertNull(message.getRole());
		        assertNull(message.getParts());
		    }
		
		    @Test
		    public void testRoleAssignment() {
		        message.setRole("user");
		        assertEquals("user", message.getRole());
		
		        message.setRole("agent");
		        assertEquals("agent", message.getRole());
		    }
		
		    @Test
		    public void testPartManagement() {
		        List<Part> parts = new ArrayList<>();
		        
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText("Hello world");
		        parts.add(textPart);
		
		        FilePart filePart = new FilePart();
		        filePart.setType("file");
		        FileContent fileContent = new FileContent();
		        fileContent.setName("test.txt");
		        fileContent.setBytes("file content");
		        filePart.setFile(fileContent);
		        parts.add(filePart);
		
		        message.setParts(parts);
		        
		        assertEquals(2, message.getParts().size());
		        assertTrue(message.getParts().get(0) instanceof TextPart);
		        assertTrue(message.getParts().get(1) instanceof FilePart);
		        
		        TextPart retrievedTextPart = (TextPart) message.getParts().get(0);
		        assertEquals("text", retrievedTextPart.getType());
		        assertEquals("Hello world", retrievedTextPart.getText());
		        
		        FilePart retrievedFilePart = (FilePart) message.getParts().get(1);
		        assertEquals("file", retrievedFilePart.getType());
		        assertEquals("test.txt", retrievedFilePart.getFile().getName());
		        assertEquals("file content", retrievedFilePart.getFile().getBytes());
		    }
		
		    @Test
		    public void testMultipleTextParts() {
		        TextPart part1 = new TextPart();
		        part1.setType("text");
		        part1.setText("First message");
		
		        TextPart part2 = new TextPart();
		        part2.setType("text");
		        part2.setText("Second message");
		
		        message.setParts(Arrays.asList(part1, part2));
		        message.setRole("user");
		
		        assertEquals(2, message.getParts().size());
		        assertEquals("First message", ((TextPart)message.getParts().get(0)).getText());
		        assertEquals("Second message", ((TextPart)message.getParts().get(1)).getText());
		        assertEquals("user", message.getRole());
		    }
		
		    @Test
		    public void testEmptyParts() {
		        message.setParts(new ArrayList<>());
		        assertNotNull(message.getParts());
		        assertTrue(message.getParts().isEmpty());
		    }
		
		    @Test
		    public void testPartTypeConsistency() {
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText("Test message");
		
		        FilePart filePart = new FilePart();
		        filePart.setType("file");
		        FileContent fileContent = new FileContent();
		        fileContent.setName("test.txt");
		        filePart.setFile(fileContent);
		
		        message.setParts(Arrays.asList(textPart, filePart));
		
		        for (Part part : message.getParts()) {
		            if (part instanceof TextPart) {
		                assertEquals("text", part.getType());
		            } else if (part instanceof FilePart) {
		                assertEquals("file", part.getType());
		            }
		        }
		    }
		
		
		
		    @Test
		    public void testToString() {
		        message.setRole("user");
		        TextPart part = new TextPart();
		        part.setType("text");
		        part.setText("Test message");
		        message.setParts(Arrays.asList(part));
		
		        String toString = message.toString();
		        assertTrue(toString.contains("role=user"));
		        assertTrue(toString.contains("parts="));
		        assertTrue(toString.contains("Test message"));
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\PartTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import java.util.HashMap;
		import java.util.Map;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class PartTest {
		    
		    class TestPart extends Part {
		        private String type;
		        private Map<String, String> metadata = new HashMap<>();
		
		        @Override
		        public String getType() {
		            return type;
		        }
		
		        @Override
		        public Map<String, String> getMetadata() {
		            return metadata;
		        }
		
		        @Override
		        public void setType(String type) {
		            this.type = type;
		        }
		    }
		
		    @Test
		    void testPartImplementation() {
		        Part part = new TestPart();
		
		        // Test type handling
		        part.setType("custom_type");
		        assertEquals("custom_type", part.getType(), "Type should be updated");
		
		        // Test metadata handling
		        assertNotNull(part.getMetadata(), "Metadata should not be null by default");
		        assertTrue(part.getMetadata().isEmpty(), "Metadata should be empty by default");
		    }
		
		    @Test
		    void testMetadataHandling() {
		        Part part = new TestPart();
		
		        // Test metadata map operations
		        part.getMetadata().put("key1", "value1");
		        assertEquals("value1", part.getMetadata().get("key1"), "Should store and retrieve metadata values");
		
		        // Test multiple entries
		        part.getMetadata().put("key2", "value2");
		        assertEquals(2, part.getMetadata().size(), "Should track multiple metadata entries");
		    }
		
		    @Test
		    void testTypeHandling() {
		        Part part = new TestPart();
		
		        // Test different type values
		        part.setType("custom_type");
		        assertEquals("custom_type", part.getType(), "Type should be updated");
		
		        part.setType(null);
		        assertNull(part.getType(), "Type should allow null value");
		
		        part.setType("");
		        assertEquals("", part.getType(), "Type should allow empty string");
		    }
		
		    @Test
		    void testSubclassSpecificBehavior() {
		        // TextPart specific test
		        TextPart textPart = new TextPart();
		        assertEquals("text", textPart.getType(), "TextPart should have default type 'text'");
		
		        // FilePart specific test
		        FilePart filePart = new FilePart();
		        assertEquals("file", filePart.getType(), "FilePart should have default type 'file'");
		
		        // DataPart specific test
		        DataPart dataPart = new DataPart();
		        assertEquals("data", dataPart.getType(), "DataPart should have default type 'data'");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\PushNotificationNotSupportedErrorTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		/**
		 * Test class for PushNotificationNotSupportedError domain object
		 */
		public class PushNotificationNotSupportedErrorTest {
		
		    @Test
		    void testDefaultConstructor() {
		        PushNotificationNotSupportedError error = new PushNotificationNotSupportedError();
		        
		        // Check error code is correctly set
		        assertEquals(-32003, error.getCode());
		        
		        // Check error message is correctly set
		        assertEquals("Push Notification is not supported", error.getMessage());
		        
		        // Check data is null
		        assertNull(error.getData());
		    }
		
		    @Test
		    void testInheritance() {
		        PushNotificationNotSupportedError error = new PushNotificationNotSupportedError();
		        
		        assertTrue(error instanceof JSONRPCError, "Should inherit from JSONRPCError");
		    }
		
		    @Test
		    void testToString() {
		        PushNotificationNotSupportedError error = new PushNotificationNotSupportedError();
		        String toStringResult = error.toString();
		        
		        assertTrue(toStringResult.contains("code=-32003"));
		        assertTrue(toStringResult.contains("message=Push Notification is not supported"));
		    }
		
		    @Test
		    void testEquals() {
		        PushNotificationNotSupportedError error1 = new PushNotificationNotSupportedError();
		        PushNotificationNotSupportedError error2 = new PushNotificationNotSupportedError();
		        
		        assertEquals(error1, error2, "Two instances should be equal");
		    }
		
		    @Test
		    void testHashCode() {
		        PushNotificationNotSupportedError error1 = new PushNotificationNotSupportedError();
		        PushNotificationNotSupportedError error2 = new PushNotificationNotSupportedError();
		        
		        assertEquals(error1.hashCode(), error2.hashCode(), "Hash codes should match");
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TaskPushNotificationConfigTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		/**
		 * Test class for TaskPushNotificationConfig domain object
		 */
		public class TaskPushNotificationConfigTest {
		
		    @Test
		    void testDefaultConstructor() {
		        TaskPushNotificationConfig config = new TaskPushNotificationConfig();
		        
		        assertNull(config.getId());
		        assertNull(config.getUrl());
		        assertNull(config.getToken());
		        assertNull(config.getAuthentication());
		    }
		
		    @Test
		    void testSettersAndGetters() {
		        TaskPushNotificationConfig config = new TaskPushNotificationConfig();
		        
		        // Test ID
		        String id = "config-123";
		        config.setId(id);
		        assertEquals(id, config.getId());
		        
		        // Test URL
		        String url = "https://example.com/webhook";
		        config.setUrl(url);
		        assertEquals(url, config.getUrl());
		        
		        // Test token
		        String token = "webhook-token-123";
		        config.setToken(token);
		        assertEquals(token, config.getToken());
		        
		        // Test authentication
		        Authentication auth = new Authentication();
		        auth.setBearerAuth("bearer-token-123");
		        config.setAuthentication(auth);
		        assertEquals(auth, config.getAuthentication());
		    }
		
		    @Test
		    void testToString() {
		        TaskPushNotificationConfig config = new TaskPushNotificationConfig();
		        config.setUrl("https://example.com/webhook");
		        config.setToken("webhook-token-123");
		        
		        String toStringResult = config.toString();
		        
		        // The ID should not be included in toString() because it's marked with @JsonIgnore
		        assertTrue(toStringResult.contains("url=https://example.com/webhook"));
		        assertTrue(toStringResult.contains("token=webhook-token-123"));
		    }
		
		    @Test
		    void testEquals() {
		        TaskPushNotificationConfig config1 = new TaskPushNotificationConfig();
		        config1.setUrl("https://example.com/webhook");
		        config1.setToken("webhook-token-123");
		        
		        TaskPushNotificationConfig config2 = new TaskPushNotificationConfig();
		        config2.setUrl("https://example.com/webhook");
		        config2.setToken("webhook-token-123");
		        
		        TaskPushNotificationConfig config3 = new TaskPushNotificationConfig();
		        config3.setUrl("https://other.com/webhook");
		        config3.setToken("webhook-token-123");
		        
		        assertEquals(config1, config2);
		        assertNotEquals(config1, config3);
		    }
		
		    @Test
		    void testHashCode() {
		        TaskPushNotificationConfig config1 = new TaskPushNotificationConfig();
		        config1.setUrl("https://example.com/webhook");
		        config1.setToken("webhook-token-123");
		        
		        TaskPushNotificationConfig config2 = new TaskPushNotificationConfig();
		        config2.setUrl("https://example.com/webhook");
		        config2.setToken("webhook-token-123");
		        
		        assertEquals(config1.hashCode(), config2.hashCode());
		    }
		    
		    @Test
		    void testWithAuthentication() {
		        TaskPushNotificationConfig config = new TaskPushNotificationConfig();
		        config.setUrl("https://example.com/webhook");
		        
		        // Create and add Basic authentication
		        Authentication auth = new Authentication();
		        auth.setBasicAuth("username", "password");
		        config.setAuthentication(auth);
		        
		        assertEquals(auth, config.getAuthentication());
		        assertTrue(config.getAuthentication().isBasicAuth());
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TaskQueryParamsTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class TaskQueryParamsTest {
		
		    @Test
		    public void testTaskQueryParamsInitialization() {
		        TaskQueryParams params = new TaskQueryParams();
		        params.setId("67890");
		        assertNotNull(params, "TaskQueryParams should be initialized successfully");
		        assertEquals("67890", params.getId(), "TaskQueryParams ID should be '67890'");
		    }
		
		    // Additional tests for TaskQueryParams methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TaskResubscriptionParamsTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class TaskResubscriptionParamsTest {
		
		    @Test
		    public void testTaskResubscriptionParamsInitialization() {
		        TaskResubscriptionParams params = new TaskResubscriptionParams();
		        params.setTaskId("98765");
		        assertNotNull(params, "TaskResubscriptionParams should be initialized successfully");
		        assertEquals("98765", params.getTaskId(), "TaskResubscriptionParams task ID should be '98765'");
		    }
		
		    // Additional tests for TaskResubscriptionParams methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TaskSendParamsTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class TaskSendParamsTest {
		
		    @Test
		    public void testTaskSendParamsInitialization() {
		        TaskSendParams params = new TaskSendParams();
		        params.setId("12345");
		        assertNotNull(params, "TaskSendParams should be initialized successfully");
		        assertEquals("12345", params.getId(), "TaskSendParams ID should be '12345'");
		    }
		
		    // Additional tests for TaskSendParams methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TaskStateManagementTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.List;
		import java.util.UUID;
		
		public class TaskStateManagementTest {
		
		    private Task task;
		    private String taskId;
		
		    @BeforeEach
		    public void setUp() {
		        taskId = UUID.randomUUID().toString();
		        task = new Task();
		        task.setId(taskId);
		    }
		
		    @Test
		    public void testInitialState() {
		        assertEquals(taskId, task.getId());
		        assertNull(task.getStatus());
		        assertNull(task.getHistory());
		        assertFalse(task.isCancelled());
		    }
		
		    @Test
		    public void testStateTransitions() {
		        // Set to SUBMITTED
		        TaskStatus submittedStatus = new TaskStatus(TaskState.SUBMITTED);
		        task.setStatus(submittedStatus);
		        assertEquals(TaskState.SUBMITTED, task.getStatus().getState());
		
		        // Set to WORKING
		        TaskStatus workingStatus = new TaskStatus(TaskState.WORKING);
		        task.setStatus(workingStatus);
		        assertEquals(TaskState.WORKING, task.getStatus().getState());
		
		        // Set to COMPLETED
		        TaskStatus completedStatus = new TaskStatus(TaskState.COMPLETED);
		        task.setStatus(completedStatus);
		        assertEquals(TaskState.COMPLETED, task.getStatus().getState());
		    }
		
		    @Test
		    public void testDetailedStateUpdate() {
		        String detailedMessage = "Processing task details...";
		        task.setDetailedAndMessage(TaskState.WORKING, detailedMessage);
		
		        assertEquals(TaskState.WORKING, task.getStatus().getState());
		        assertTrue(task.getStatus().getMessage().getParts().stream()
		            .filter(p -> p instanceof TextPart)
		            .map(p -> ((TextPart)p).getText())
		            .anyMatch(text -> text.equals(detailedMessage)));
		    }
		
		    @Test
		    public void testHistoryManagement() {
		        // Create initial message
		        Message msg1 = new Message();
		        TextPart part1 = new TextPart();
		        part1.setType("text");
		        part1.setText("First message");
		        msg1.setParts(List.of(part1));
		
		        // Create second message
		        Message msg2 = new Message();
		        TextPart part2 = new TextPart();
		        part2.setType("text");
		        part2.setText("Second message");
		        msg2.setParts(List.of(part2));
		
		        // Set history
		        task.setHistory(List.of(msg1, msg2));
		
		        // Verify history
		        List<Message> history = task.getHistory();
		        assertEquals(2, history.size());
		        
		        TextPart firstHistoryPart = (TextPart)history.get(0).getParts().get(0);
		        assertEquals("First message", firstHistoryPart.getText());
		        
		        TextPart secondHistoryPart = (TextPart)history.get(1).getParts().get(0);
		        assertEquals("Second message", secondHistoryPart.getText());
		    }
		
		    @Test
		    public void testArtifactManagement() {
		        // Create test artifact
		        Artifact artifact = new Artifact();
		        artifact.setName("Test Artifact");
		        artifact.setDescription("Test Description");
		
		        TextPart artifactContent = new TextPart();
		        artifactContent.setType("text");
		        artifactContent.setText("Artifact content");
		        artifact.setParts(List.of(artifactContent));
		
		        // Set artifacts
		        task.setArtifacts(List.of(artifact));
		
		        // Verify artifacts
		        List<Artifact> artifacts = task.getArtifacts();
		        assertEquals(1, artifacts.size());
		        assertEquals("Test Artifact", artifacts.get(0).getName());
		        assertEquals("Test Description", artifacts.get(0).getDescription());
		        
		        TextPart retrievedContent = (TextPart)artifacts.get(0).getParts().get(0);
		        assertEquals("Artifact content", retrievedContent.getText());
		    }
		
		    @Test
		    public void testCancellation() {
		        assertFalse(task.isCancelled());
		        task.setCancelled(true);
		        assertTrue(task.isCancelled());
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TaskStateTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class TaskStateTest {
		
		    @Test
		    public void testTaskStateInitialization() {
		        TaskState taskState = TaskState.SUBMITTED;
		        assertNotNull(taskState, "TaskState should be initialized successfully");
		    }
		
		    @Test
		    public void testTaskStateValues() {
		        TaskState[] states = TaskState.values();
		        assertTrue(states.length > 0, "TaskState should have defined values");
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TaskStatusTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class TaskStatusTest {
		
		    @Test
		    public void testTaskStatusInitialization() {
		        TaskStatus status = new TaskStatus("COMPLETED");
		        assertNotNull(status, "TaskStatus should be initialized successfully");
		        assertEquals(TaskState.COMPLETED, status.getState(), "TaskStatus state should be 'COMPLETED'");
		    }
		
		    // Additional tests for TaskStatus methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TaskTest.java'>
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class TaskTest {
		
		    @Test
		    public void testTaskInitialization() {
		        Task task = new Task();
		        assertNotNull(task, "Task should be initialized successfully");
		    }
		
		    // Additional tests for Task methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\domain\TextPartTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import java.util.HashMap;
		import java.util.Map;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class TextPartTest {
		    
		    private TextPart textPart;
		    private static final String TEST_TEXT = "Test text content";
		    private static final String TEST_TYPE = "text";
		
		    @BeforeEach
		    void setUp() {
		        textPart = new TextPart();
		    }
		
		    @Test
		    void testBasicTextPartCreation() {
		        assertNotNull(textPart, "TextPart should be created successfully");
		        assertEquals(TEST_TYPE, textPart.getType(), "Default type should be 'text'");
		    }
		
		    @Test
		    void testTextPartWithText() {
		        textPart.setText(TEST_TEXT);
		        assertEquals(TEST_TEXT, textPart.getText(), "Text should match set value");
		    }
		
		    @Test
		    void testTextPartWithType() {
		        String customType = "custom_text";
		        textPart.setType(customType);
		        assertEquals(customType, textPart.getType(), "Type should match set value");
		    }
		
		    @Test
		    void testTextPartWithTextAndType() {
		        textPart.setText(TEST_TEXT);
		        textPart.setType(TEST_TYPE);
		        assertEquals(TEST_TEXT, textPart.getText(), "Text should match set value");
		        assertEquals(TEST_TYPE, textPart.getType(), "Type should match set value");
		    }
		
		    @Test
		    void testNullValues() {
		        textPart.setText(null);
		        textPart.setType(null);
		        assertNull(textPart.getText(), "Text should be null");
		        assertNull(textPart.getType(), "Type should be null");
		    }
		
		    @Test
		    void testEmptyValues() {
		        textPart.setText("");
		        textPart.setType("");
		        assertEquals("", textPart.getText(), "Text should be empty string");
		        assertEquals("", textPart.getType(), "Type should be empty string");
		    }
		
		    @Test
		    void testMetadataOperations() {
		        // Test empty metadata
		        assertNotNull(textPart.getMetadata(), "Metadata should not be null by default");
		        assertTrue(textPart.getMetadata().isEmpty(), "Metadata should be empty by default");
		
		        // Test setting and getting metadata
		        Map<String, String> metadata = new HashMap<>();
		        metadata.put("key1", "value1");
		        metadata.put("key2", "value2");
		        textPart.setMetadata(metadata);
		
		        assertEquals(metadata, textPart.getMetadata(), "Metadata should match set value");
		        assertEquals("value1", textPart.getMetadata().get("key1"), "Should retrieve correct metadata value");
		        assertEquals("value2", textPart.getMetadata().get("key2"), "Should retrieve correct metadata value");
		    }
		
		    @Test
		    void testToString() {
		        textPart.setText(TEST_TEXT);
		        textPart.setType(TEST_TYPE);
		        Map<String, String> metadata = new HashMap<>();
		        metadata.put("key1", "value1");
		        textPart.setMetadata(metadata);
		
		        String toString = textPart.toString();
		        assertNotNull(toString, "toString should not be null");
		        assertTrue(toString.contains(TEST_TEXT), "toString should contain text");
		        assertTrue(toString.contains(TEST_TYPE), "toString should contain type");
		        assertTrue(toString.contains("key1"), "toString should contain metadata key");
		        assertTrue(toString.contains("value1"), "toString should contain metadata value");
		    }
		
		    @Test
		    void testLongText() {
		        StringBuilder longText = new StringBuilder();
		        for (int i = 0; i < 1000; i++) {
		            longText.append("Test text line ").append(i).append("\n");
		        }
		        String text = longText.toString();
		        textPart.setText(text);
		        assertEquals(text, textPart.getText(), "Long text should be handled correctly");
		    }
		
		    @Test
		    void testEquality() {
		        TextPart part1 = new TextPart();
		        TextPart part2 = new TextPart();
		
		        part1.setText(TEST_TEXT);
		        part2.setText(TEST_TEXT);
		
		        Map<String, String> metadata = new HashMap<>();
		        metadata.put("key", "value");
		        part1.setMetadata(metadata);
		        part2.setMetadata(new HashMap<>(metadata));
		
		        assertEquals(part1.getText(), part2.getText(), "Text should be equal");
		        assertEquals(part1.getType(), part2.getType(), "Type should be equal");
		        assertEquals(part1.getMetadata(), part2.getMetadata(), "Metadata should be equal");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\A2ATaskControllerTest.java'>
		package io.github.vishalmysore.a2a.server;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class A2ATaskControllerTest {
		
		    @Test
		    public void testA2ATaskControllerInterface() {
		        // Since A2ATaskController is an interface, we can only test its implementation.
		        // Placeholder test to ensure the interface is accessible.
		        assertTrue(true, "A2ATaskController interface is accessible");
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\AIProcessingTest.java'>
		package io.github.vishalmysore.a2a.server;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.processor.AIProcessor;
		import com.t4a.processor.AIProcessingException;
		import io.github.vishalmysore.a2a.domain.*;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		
		import java.util.List;
		import java.util.UUID;
		
		import static org.junit.jupiter.api.Assertions.*;
		import static org.mockito.ArgumentMatchers.any;
		import static org.mockito.Mockito.*;
		
		public class AIProcessingTest {
		
		    private DyanamicTaskContoller controller;
		
		    @Mock
		    private AIProcessor mockProcessor;
		
		    @Mock
		    private ActionCallback mockCallback;
		
		    @BeforeEach
		    public void setUp() {
		        MockitoAnnotations.openMocks(this);
		        controller = new DyanamicTaskContoller() {
		            @Override
		            public AIProcessor getBaseProcessor() {
		                return mockProcessor;
		            }
		        };
		    }
		
		
		    public void testSuccessfulAIProcessing() throws AIProcessingException {
		        // Setup mock response
		        when(mockProcessor.processSingleAction(any(String.class), any(ActionCallback.class)))
		            .thenReturn("AI Generated Response");
		
		        // Create task
		        TaskSendParams params = createTaskParams("Process this with AI");
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		
		        // Verify processing
		        verify(mockProcessor).processSingleAction(any(String.class), any(ActionCallback.class));
		        assertNotNull(response);
		        assertNotNull(response.getResult());
		    }
		
		
		    public void testAIProcessingFailure() throws AIProcessingException {
		        // Setup mock to throw exception
		        when(mockProcessor.processSingleAction(any(String.class), any(ActionCallback.class)))
		            .thenThrow(new AIProcessingException("AI processing failed"));
		
		        // Create task
		        TaskSendParams params = createTaskParams("This should fail");
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		
		        // Verify failure handling
		        assertNotNull(response);
		        Task result = response.getResult();
		        assertNotNull(result);
		        assertEquals(TaskState.FAILED, result.getStatus().getState());
		        assertTrue(((TextPart)result.getStatus().getMessage().getParts().get(0)).getText()
		            .contains("Processing failed"));
		    }
		
		    @Test
		    public void testAIProviderSwitch() {
		        // Test Gemini processor
		        //will move tihs to mock later
		        controller = new DyanamicTaskContoller(){
		            @Override
		            public SendTaskResponse sendTask(TaskSendParams taskSendParams,  ActionCallback callback) {
		                Task t = new   Task();
		                SendTaskResponse response = new SendTaskResponse();
		                response.setResult(t);
		                TaskStatus ts = new TaskStatus();
		                ts.setState(TaskState.SUBMITTED);
		                t.setStatus(ts);
		                response.setId(taskSendParams.getId());
		                return response;
		            }
		        };
		        AIProcessor processor = controller.getBaseProcessor();
		        assertNotNull(processor);
		        assertTrue(processor.getClass().getSimpleName().contains("OpenAi"));
		
		        // Test task processing with different providers
		        TaskSendParams params = createTaskParams("Test with different provider");
		        SendTaskResponse response = controller.sendTask(params, null);
		        assertNotNull(response);
		        assertEquals(TaskState.SUBMITTED, response.getResult().getStatus().getState());
		    }
		
		
		    public void testComplexAIProcessing() throws AIProcessingException {
		        // Setup mock for complex processing
		        when(mockProcessor.processSingleAction(any(String.class), any(ActionCallback.class)))
		            .thenAnswer(invocation -> {
		                String input = invocation.getArgument(0);
		                ActionCallback callback = invocation.getArgument(1);
		                
		                // Simulate processing stages
		                if (callback != null) {
		                    callback.sendtStatus("Processing stage 1", null);
		                    Thread.sleep(100);
		                    callback.sendtStatus("Processing stage 2", null);
		                    Thread.sleep(100);
		                    callback.sendtStatus("Processing complete", null);
		                }
		                
		                return "Complex AI processing result for: " + input;
		            });
		
		        // Create task with complex input
		        TaskSendParams params = createTaskParams("Complex AI task with multiple stages");
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		
		        // Verify complex processing
		        verify(mockProcessor).processSingleAction(any(String.class), any(ActionCallback.class));
		        verify(mockCallback, atLeast(3)).sendtStatus(any(), any());
		        
		        assertNotNull(response);
		        assertNotNull(response.getResult());
		    }
		
		
		    public void testAIProcessingTimeout() throws AIProcessingException {
		        // Setup mock to simulate timeout
		        when(mockProcessor.processSingleAction(any(String.class), any(ActionCallback.class)))
		            .thenAnswer(invocation -> {
		                Thread.sleep(5000); // Simulate long processing
		                return "Delayed response";
		            });
		
		        // Create task
		        TaskSendParams params = createTaskParams("Long running task");
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		
		        // Verify timeout handling
		        assertNotNull(response);
		        assertNotNull(response.getResult());
		    }
		
		    private TaskSendParams createTaskParams(String messageText) {
		        TaskSendParams params = new TaskSendParams();
		        params.setId(UUID.randomUUID().toString());
		        
		        Message message = new Message();
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText(messageText);
		        message.setParts(List.of(textPart));
		        params.setMessage(message);
		        
		        return params;
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\ConcurrencyTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		import io.github.vishalmysore.a2a.domain.*;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		
		import java.util.ArrayList;
		import java.util.List;
		import java.util.UUID;
		import java.util.concurrent.*;
		
		import static org.junit.jupiter.api.Assertions.*;
		
		public class ConcurrencyTest {
		
		    private DyanamicTaskContoller controller;
		    
		    @BeforeEach
		    public void setUp() {
		        MockitoAnnotations.openMocks(this);
		        controller = new DyanamicTaskContoller();
		    }
		
		    @Test
		    public void testConcurrentTaskSubmission() throws InterruptedException {
		        int numThreads = 10;
		        CountDownLatch startLatch = new CountDownLatch(1);
		        CountDownLatch completionLatch = new CountDownLatch(numThreads);
		        List<Future<SendTaskResponse>> futures = new ArrayList<>();
		        ExecutorService executorService = Executors.newFixedThreadPool(numThreads);
		
		        try {
		            // Submit tasks concurrently
		            for (int i = 0; i < numThreads; i++) {
		                final int taskNum = i;
		                Future<SendTaskResponse> future = executorService.submit(() -> {
		                    startLatch.await(); // Wait for all threads to be ready
		                    TaskSendParams params = createTaskParams("Concurrent task " + taskNum);
		                    SendTaskResponse response = controller.sendTask(params, null);
		                    completionLatch.countDown();
		                    return response;
		                });
		                futures.add(future);
		            }
		
		            // Start all threads simultaneously
		            startLatch.countDown();
		
		            // Wait for all tasks to complete
		            assertTrue(completionLatch.await(10, TimeUnit.SECONDS));            // Verify results
		            List<SendTaskResponse> responses = new ArrayList<>();
		            for (Future<SendTaskResponse> future : futures) {
		                try {
		                    responses.add(future.get(5, TimeUnit.SECONDS));
		                } catch (Exception e) {
		                    fail("Task execution failed: " + e.getMessage());
		                }
		            }
		
		            assertEquals(numThreads, responses.size());
		            assertEquals(numThreads, responses.stream().map(SendTaskResponse::getId).distinct().count());
		        } finally {
		            executorService.shutdown();
		        }
		    }
		
		
		    public void testConcurrentTaskUpdates() throws InterruptedException {
		        // Create initial task
		        TaskSendParams params = createTaskParams("Task for concurrent updates");
		        SendTaskResponse initialResponse = controller.sendTask(params, null);
		        String taskId = initialResponse.getId();
		
		        int numThreads = 5;
		        CountDownLatch startLatch = new CountDownLatch(1);
		        CountDownLatch completionLatch = new CountDownLatch(numThreads);
		        ExecutorService executorService = Executors.newFixedThreadPool(numThreads);
		
		        try {
		            // Update task concurrently
		            for (int i = 0; i < numThreads; i++) {
		                final int updateNum = i;
		                executorService.submit(() -> {
		                    try {
		                        startLatch.await();                        params.setId(taskId);
		                        ((TextPart)params.getMessage().getParts().get(0)).setText("Update " + updateNum);
		                        controller.sendTask(params, null);
		                        completionLatch.countDown();
		                    } catch (InterruptedException e) {
		                        Thread.currentThread().interrupt();
		                    }
		                });
		            }
		
		            // Start all threads simultaneously
		            startLatch.countDown();
		
		            // Wait for all updates to complete
		            assertTrue(completionLatch.await(10, TimeUnit.SECONDS));
		
		            // Verify task history
		            Task updatedTask = controller.getTask(taskId, numThreads + 1).getBody();
		            assertNotNull(updatedTask);
		            assertEquals(numThreads + 1, updatedTask.getHistory().size());
		        } finally {
		            executorService.shutdown();
		        }
		    }
		
		
		    public void testConcurrentTaskCancellation() throws InterruptedException {
		        // Create tasks to cancel
		        int numTasks = 5;
		        List<String> taskIds = new ArrayList<>();
		        for (int i = 0; i < numTasks; i++) {
		            TaskSendParams params = createTaskParams("Task " + i + " for cancellation");
		            SendTaskResponse response = controller.sendTask(params, null);
		            taskIds.add(response.getId());
		        }
		
		        CountDownLatch startLatch = new CountDownLatch(1);
		        CountDownLatch completionLatch = new CountDownLatch(numTasks);
		        ExecutorService executorService = Executors.newFixedThreadPool(numTasks);
		
		        try {
		            // Cancel tasks concurrently
		            for (String taskId : taskIds) {
		                executorService.submit(() -> {
		                    try {
		                        startLatch.await();
		                        controller.cancelTask(taskId);
		                        completionLatch.countDown();
		                    } catch (InterruptedException e) {
		                        Thread.currentThread().interrupt();
		                    }
		                });
		            }
		
		            // Start all threads simultaneously
		            startLatch.countDown();
		
		            // Wait for all cancellations to complete
		            assertTrue(completionLatch.await(10, TimeUnit.SECONDS));
		
		            // Verify all tasks are cancelled
		            for (String taskId : taskIds) {
		                Task task = controller.getTask(taskId, 0).getBody();
		                assertTrue(task.isCancelled());
		            }
		        } finally {
		            executorService.shutdown();
		        }
		    }
		
		    private TaskSendParams createTaskParams(String messageText) {
		        TaskSendParams params = new TaskSendParams();
		        params.setId(UUID.randomUUID().toString());
		        
		        Message message = new Message();
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText(messageText);
		        message.setParts(List.of(textPart));
		        params.setMessage(message);
		        
		        return params;
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\DyanamicTaskContollerTest.java'>
		package io.github.vishalmysore.a2a.server;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class DyanamicTaskContollerTest {
		
		    @Test
		    public void testDyanamicTaskContollerInitialization() {
		        DyanamicTaskContoller controller = new DyanamicTaskContoller();
		        assertNotNull(controller, "DyanamicTaskContoller should be initialized successfully");
		    }
		
		    // Additional tests for DyanamicTaskContoller methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\ErrorHandlingTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		import com.t4a.detect.ActionCallback;
		import io.github.vishalmysore.a2a.domain.*;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.junit.jupiter.api.extension.ExtendWith;
		import org.mockito.Mock;
		import org.mockito.junit.jupiter.MockitoExtension;
		import org.springframework.http.ResponseEntity;
		import org.springframework.web.server.ResponseStatusException;
		
		import java.util.ArrayList;
		import java.util.List;
		import java.util.UUID;
		import java.util.concurrent.TimeUnit;
		
		import static org.junit.jupiter.api.Assertions.*;
		import static org.mockito.Mockito.*;
		
		@ExtendWith(MockitoExtension.class)
		public class ErrorHandlingTest {
		
		    private DyanamicTaskContoller controller;
		
		    @Mock
		    private ActionCallback mockCallback;
		
		    @BeforeEach
		    public void setUp() {
		        controller = new DyanamicTaskContoller();
		    }
		
		
		    public void testNullParameterHandling() {
		        // Test null task parameters
		        assertThrows(NullPointerException.class, () -> {
		            controller.sendTask(null, mockCallback);
		        });
		
		        // Test null message in parameters
		        TaskSendParams params = new TaskSendParams();
		        params.setId(UUID.randomUUID().toString());
		        params.setMessage(null);
		        
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		        assertEquals(TaskState.FAILED, response.getResult().getStatus().getState());
		    }
		
		
		    public void testInvalidStateTransitions() {
		        // Create a task
		        TaskSendParams params = createTaskParams("Test invalid transitions");
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		        String taskId = response.getId();
		
		        // Try to cancel already completed task
		        Task task = controller.getTask(taskId, 0).getBody();
		        task.setStatus(new TaskStatus(TaskState.COMPLETED));
		        
		        String result = controller.cancelTask(taskId);
		        assertTrue(result.contains("cancelled"));
		        
		        // Verify final state
		        task = controller.getTask(taskId, 0).getBody();
		        assertTrue(task.isCancelled());
		    }
		
		
		    public void testMalformedRequestHandling() {
		        // Test empty message parts
		        TaskSendParams params = new TaskSendParams();
		        params.setId(UUID.randomUUID().toString());
		        Message message = new Message();
		        message.setParts(new ArrayList<>());
		        params.setMessage(message);
		        
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		        assertNotNull(response);
		        assertEquals(TaskState.FAILED, response.getResult().getStatus().getState());
		
		        // Test invalid message part type
		        params = createTaskParams("Test invalid part");
		        TextPart invalidPart = new TextPart();
		        invalidPart.setType("invalid_type");
		        params.getMessage().setParts(List.of(invalidPart));
		        
		        response = controller.sendTask(params, mockCallback);
		        assertEquals(TaskState.FAILED, response.getResult().getStatus().getState());
		    }
		
		
		    public void testResourceCleanup() {
		        // Create multiple tasks
		        List<String> taskIds = new ArrayList<>();
		        for (int i = 0; i < 5; i++) {
		            TaskSendParams params = createTaskParams("Task " + i);
		            SendTaskResponse response = controller.sendTask(params, mockCallback);
		            taskIds.add(response.getId());
		        }
		
		        // Cancel and verify cleanup
		        for (String taskId : taskIds) {
		            controller.cancelTask(taskId);
		            Task task = controller.getTask(taskId, 0).getBody();
		            assertTrue(task.isCancelled());
		        }
		    }
		
		
		    public void testRecoveryFromErrors() {
		        // Create task that will fail
		        TaskSendParams params = createTaskParams("This will fail");
		        params.getMessage().getParts().get(0).setType("invalid_type");
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		        String taskId = response.getId();
		
		        // Verify failed state
		        Task failedTask = controller.getTask(taskId, 0).getBody();
		        assertEquals(TaskState.FAILED, failedTask.getStatus().getState());
		
		        // Try to recover by sending new valid message
		        params = createTaskParams("Recovery message");
		        params.setId(taskId);
		        response = controller.sendTask(params, mockCallback);
		
		        // Verify recovery
		        Task recoveredTask = controller.getTask(taskId, 0).getBody();
		        assertNotEquals(TaskState.FAILED, recoveredTask.getStatus().getState());
		    }
		
		
		    public void testConcurrentErrorHandling() throws InterruptedException {
		        // Create tasks that will fail concurrently
		        int numTasks = 10;
		        List<Thread> threads = new ArrayList<>();
		        
		        for (int i = 0; i < numTasks; i++) {
		            Thread t = new Thread(() -> {
		                TaskSendParams params = createTaskParams("Concurrent failure test");
		                params.getMessage().getParts().get(0).setType("invalid_type");
		                controller.sendTask(params, mockCallback);
		            });
		            threads.add(t);
		            t.start();
		        }
		
		        // Wait for all threads to complete
		        for (Thread t : threads) {
		            t.join(TimeUnit.SECONDS.toMillis(5));
		        }
		    }
		
		    private TaskSendParams createTaskParams(String messageText) {
		        TaskSendParams params = new TaskSendParams();
		        params.setId(UUID.randomUUID().toString());
		        
		        Message message = new Message();
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText(messageText);
		        message.setParts(List.of(textPart));
		        params.setMessage(message);
		        
		        return params;
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\FileBasedTaskControllerTest.java'/>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\FileProcessingTest.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		import com.t4a.detect.ActionCallback;
		import io.github.vishalmysore.a2a.domain.*;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.junit.jupiter.api.io.TempDir;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		
		import java.io.IOException;
		import java.nio.file.Files;
		import java.nio.file.Path;
		import java.util.Base64;
		import java.util.List;
		import java.util.UUID;
		
		import static org.junit.jupiter.api.Assertions.*;
		
		public class FileProcessingTest {
		
		    private DyanamicTaskContoller controller;
		    
		    @Mock
		    private ActionCallback mockCallback;
		    
		    @TempDir
		    Path tempDir;
		
		    @BeforeEach
		    public void setUp() {
		        MockitoAnnotations.openMocks(this);
		        controller = new DyanamicTaskContoller();
		    }
		
		    @Test
		    public void testFileUploadAndProcessing() throws IOException {
		        // Create a test file
		        String fileContent = "Test file content\nLine 2\nLine 3";
		        Path testFile = tempDir.resolve("test.txt");
		        Files.write(testFile, fileContent.getBytes());
		
		        // Create task params with file
		        TaskSendParams params = new TaskSendParams();
		        params.setId(UUID.randomUUID().toString());
		
		        Message message = new Message();
		        FilePart filePart = new FilePart();
		        filePart.setType("file");
		        
		        FileContent fileInfo = new FileContent();
		        fileInfo.setBytes(Base64.getEncoder().encodeToString(fileContent.getBytes()));
		        filePart.setFile(fileInfo);
		        
		        message.setParts(List.of(filePart));
		        params.setMessage(message);
		
		        // Send task
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		
		        // Verify response
		        assertNotNull(response);
		        assertEquals(params.getId(), response.getId());
		        assertNotNull(response.getResult());
		    }
		
		    @Test
		    public void testLargeFileProcessing() throws IOException {
		        // Create a large test file (1MB)
		        StringBuilder largeContent = new StringBuilder();
		        for (int i = 0; i < 100000; i++) {
		            largeContent.append("Line ").append(i).append(" of test content\n");
		        }
		
		        Path largeFile = tempDir.resolve("large.txt");
		        Files.write(largeFile, largeContent.toString().getBytes());
		
		        // Create task params with large file
		        TaskSendParams params = new TaskSendParams();
		        params.setId(UUID.randomUUID().toString());
		
		        Message message = new Message();
		        FilePart filePart = new FilePart();
		        filePart.setType("file");
		        
		        FileContent fileInfo = new FileContent();
		        fileInfo.setBytes(Base64.getEncoder().encodeToString(Files.readAllBytes(largeFile)));
		        filePart.setFile(fileInfo);
		        
		        message.setParts(List.of(filePart));
		        params.setMessage(message);
		
		        // Send task
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		
		        // Verify response
		        assertNotNull(response);
		        assertEquals(params.getId(), response.getId());
		    }
		
		
		    public void testInvalidFileContent() {
		        TaskSendParams params = new TaskSendParams();
		        params.setId(UUID.randomUUID().toString());
		
		        Message message = new Message();
		        FilePart filePart = new FilePart();
		        filePart.setType("file");
		        
		        FileContent fileInfo = new FileContent();
		        fileInfo.setBytes("Invalid Base64 Content!");
		        filePart.setFile(fileInfo);
		        
		        message.setParts(List.of(filePart));
		        params.setMessage(message);
		
		        SendTaskResponse response = controller.sendTask(params, mockCallback);
		        
		        // The task should be created but marked as failed
		        Task result = response.getResult();
		        assertNotNull(result);
		        assertEquals(TaskState.FAILED, result.getStatus().getState());
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\SSEEmitterCallbackTest.java'>
		package io.github.vishalmysore.a2a.server;
		
		import static org.junit.jupiter.api.Assertions.*;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		import static org.mockito.Mockito.*;
		
		import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
		import com.t4a.detect.ActionCallback;
		import com.t4a.detect.ActionState;
		import io.github.vishalmysore.a2a.domain.*;
		import java.io.IOException;
		
		public class SSEEmitterCallbackTest {
		
		    private SSEEmitterCallback callback;
		    
		    @Mock
		    private SseEmitter mockEmitter;
		    
		    @BeforeEach
		    public void setUp() {
		        MockitoAnnotations.openMocks(this);
		        callback = new SSEEmitterCallback(null, mockEmitter);
		    }
		    
		
		    public void testStatusUpdateSent() throws IOException {
		        String status = "Processing";
		        ActionState state = ActionState.WORKING;
		        
		        callback.sendtStatus(status, state);
		        
		        verify(mockEmitter).send(any(TaskStatusUpdateEvent.class));
		    }
		    
		
		    public void testEmitterCompletionOnFinalState() throws IOException {
		        // Test completion state
		        callback.sendtStatus("Completed", ActionState.COMPLETED);
		        verify(mockEmitter).complete();
		        
		        // Test failure state
		        callback = new SSEEmitterCallback(null, mockEmitter);
		        callback.sendtStatus("Failed", ActionState.FAILED);
		        verify(mockEmitter, times(2)).complete();
		    }
		    
		  
		    
		
		    public void testContextHandling() {
		        Object context = new Object();
		        callback.setContext(context);
		        assertEquals(context, callback.getContext());
		    }
		
		    public void testTypeHandling() {
		        String type = "test-type";
		        String result = callback.setType(type);
		        assertEquals(type, result);
		        assertEquals(type, callback.getType());
		    }
		    
		
		    public void testNullStatusHandling() throws IOException {
		        // Should handle null values gracefully
		        callback.sendtStatus(null, null);
		       // verify(mockEmitter, never()).send(any());
		    }
		    
		
		    public void testEmitterCompletionOrder() throws IOException {
		        // Test proper completion order for a task
		        callback.sendtStatus("Starting", ActionState.SUBMITTED);
		        callback.sendtStatus("Working", ActionState.WORKING);
		        callback.sendtStatus("Almost done", ActionState.WORKING);
		        callback.sendtStatus("Completed", ActionState.COMPLETED);
		        
		        // Verify events were sent in order
		        verify(mockEmitter, times(4)).send(any(TaskStatusUpdateEvent.class));
		        verify(mockEmitter).complete();
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\a2a\server\SSETest.java'><![CDATA[
		package io.github.vishalmysore.a2a.server;
		
		import io.github.vishalmysore.a2a.domain.*;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
		
		import java.io.IOException;
		import java.util.List;
		import java.util.UUID;
		import java.util.concurrent.CountDownLatch;
		import java.util.concurrent.TimeUnit;
		import java.util.concurrent.atomic.AtomicReference;
		
		import static org.junit.jupiter.api.Assertions.*;
		import static org.mockito.Mockito.*;
		
		public class SSETest {
		
		    private DyanamicTaskContoller controller;
		    
		    @Mock
		    private SseEmitter mockEmitter;
		
		    @BeforeEach
		    public void setUp() {
		        MockitoAnnotations.openMocks(this);
		        controller = new DyanamicTaskContoller();
		    }
		
		
		    public void testSSESubscription() throws InterruptedException {
		        // Create a task first
		        String taskId = UUID.randomUUID().toString();
		        TaskSendSubscribeParams params = new TaskSendSubscribeParams();
		        params.setId(taskId);
		        
		        Message message = new Message();
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText("Test SSE subscription");
		        message.setParts(List.of(textPart));
		        params.setMessage(message);
		
		        // Create latch to wait for events
		        CountDownLatch latch = new CountDownLatch(1);
		        AtomicReference<String> receivedEvent = new AtomicReference<>();
		
		        // Get SSE emitter
		        SseEmitter emitter = controller.sendSubscribeTask(params);
		        assertNotNull(emitter);
		
		        // Wait for completion
		        assertTrue(latch.await(5, TimeUnit.SECONDS));
		    }
		
		
		    public void testSSEResubscription() {
		        // Create initial task
		        String taskId = UUID.randomUUID().toString();
		        TaskSendParams params = new TaskSendParams();
		        params.setId(taskId);
		        
		        Message message = new Message();
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText("Test resubscription");
		        message.setParts(List.of(textPart));
		        params.setMessage(message);
		
		        controller.sendTask(params, null);
		
		        // Test resubscription
		        SseEmitter emitter = controller.resubscribe(taskId);
		        assertNotNull(emitter);
		    }
		
		
		    public void testSSEErrorHandling() throws IOException {
		        // Test subscription to non-existent task
		        String nonExistentId = UUID.randomUUID().toString();
		        SseEmitter emitter = controller.resubscribe(nonExistentId);
		        
		        // Emitter should be created but complete quickly with error
		        assertNotNull(emitter);
		
		        // Test timeout handling
		        String taskId = UUID.randomUUID().toString();
		        TaskSendSubscribeParams params = new TaskSendSubscribeParams();
		        params.setId(taskId);
		        
		        Message message = new Message();
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText("Test timeout");
		        message.setParts(List.of(textPart));
		        params.setMessage(message);
		
		        SseEmitter timeoutEmitter = controller.sendSubscribeTask(params);
		        assertNotNull(timeoutEmitter);
		    }
		
		
		    public void testSSEMultipleSubscribers() {
		        // Create a task
		        String taskId = UUID.randomUUID().toString();
		        TaskSendParams params = new TaskSendParams();
		        params.setId(taskId);
		        
		        Message message = new Message();
		        TextPart textPart = new TextPart();
		        textPart.setType("text");
		        textPart.setText("Test multiple subscribers");
		        message.setParts(List.of(textPart));
		        params.setMessage(message);
		
		        controller.sendTask(params, null);
		
		        // Create multiple subscribers
		        SseEmitter emitter1 = controller.resubscribe(taskId);
		        SseEmitter emitter2 = controller.resubscribe(taskId);
		        SseEmitter emitter3 = controller.resubscribe(taskId);
		
		        assertNotNull(emitter1);
		        assertNotNull(emitter2);
		        assertNotNull(emitter3);
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\common\A2AActionCallBackTest.java'>
		package io.github.vishalmysore.common;
		
		import static org.junit.jupiter.api.Assertions.*;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.detect.ActionState;
		
		public class A2AActionCallBackTest {
		    
		    private A2AActionCallBack callback;
		    private Object testContext;
		    
		    @BeforeEach
		    public void setUp() {
		        callback = new A2AActionCallBack();
		        testContext = new Object();
		    }
		    
		    @Test
		    public void testContextHandling() {
		        callback.setContext(testContext);
		        assertEquals(testContext, callback.getContext(), "Context should be stored and retrieved correctly");
		        
		        callback.setContext(null);
		        assertNull(callback.getContext(), "Context should handle null values");
		    }
		    
		
		    public void testTypeHandling() {
		        String testType = "test-type";
		        assertEquals("", callback.getType(), "Initial type should be empty");
		        
		        String result = callback.setType(testType);
		        assertEquals(testType, result, "setType should return the type");
		        assertEquals(testType, callback.getType(), "Type should be stored correctly");
		    }
		    
		
		    public void testStatusUpdates() {
		        String status = "Processing";
		        ActionState state = ActionState.WORKING;
		        
		        callback.sendtStatus(status, state);
		        // Add verification if status is exposed through getters
		        
		        // Test null handling
		        callback.sendtStatus(null, null);
		        // Should not throw exception
		    }
		    
		
		    public void testMultipleStatusUpdates() {
		        callback.sendtStatus("Started", ActionState.SUBMITTED);
		        callback.sendtStatus("Working", ActionState.WORKING);
		        callback.sendtStatus("Completed", ActionState.COMPLETED);
		        // Verify status history if maintained
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\common\AgentIdentityTest.java'/>
	<file path='src\test\java\io\github\vishalmysore\common\AgentInfoTest.java'/>
	<file path='src\test\java\io\github\vishalmysore\common\CommonClientResponseTest.java'/>
	<file path='src\test\java\io\github\vishalmysore\common\MCPResultsCallBackTest.java'>
		package io.github.vishalmysore.common;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class MCPResultsCallBackTest {
		
		    @Test
		    public void testMCPResultsCallBackInitialization() {
		        MCPResultsCallBack callback = new MCPResultsCallBack();
		        assertNotNull(callback, "MCPResultsCallBack should be initialized successfully");
		    }
		
		    // Additional tests for MCPResultsCallBack methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\common\test\TestAgentInfo.java'>
		package io.github.vishalmysore.common.test;
		
		import io.github.vishalmysore.common.AgentInfo;
		
		public class TestAgentInfo implements AgentInfo {
		    private String capabilities;
		    private String description;
		
		    public void setCapabilities(String capabilities) {
		        this.capabilities = capabilities;
		    }
		
		    public String getCapabilities() {
		        return capabilities;
		    }
		
		    public void setDescription(String description) {
		        this.description = description;
		    }
		
		    public String getDescription() {
		        return description;
		    }
		
		    @Override
		    public String getAgentCapabilities() {
		        return capabilities != null ? capabilities : AgentInfo.super.getAgentCapabilities();
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\common\test\TestCommonClientResponse.java'><![CDATA[
		package io.github.vishalmysore.common.test;
		
		import io.github.vishalmysore.common.CommonClientResponse;
		import java.util.Map;
		
		public class TestCommonClientResponse implements CommonClientResponse {
		    private String textResult;
		    private String error;
		    private Map<String, Object> jsonData;
		
		    @Override
		    public String getTextResult() {
		        return textResult;
		    }
		
		    public void setTextResult(String textResult) {
		        this.textResult = textResult;
		    }
		
		    public String getError() {
		        return error;
		    }
		
		    public void setError(String error) {
		        this.error = error;
		    }
		
		    public Map<String, Object> getJsonData() {
		        return jsonData;
		    }
		
		    public void setJsonData(Map<String, Object> jsonData) {
		        this.jsonData = jsonData;
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\client\MCPAgentTest.java'>
		package io.github.vishalmysore.mcp.client;
		
		import io.github.vishalmysore.common.AgentInfo;
		import io.github.vishalmysore.common.CommonClientResponse;
		import io.github.vishalmysore.mcp.domain.*;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		
		import java.net.URL;
		
		import static org.mockito.Mockito.*;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class MCPAgentTest {
		    
		    private MCPAgent mcpAgent;
		    
		    @Mock
		    private Tool mockTool;
		    
		    @Mock
		    private CallToolResult mockCallToolResult;
		    
		    @BeforeEach
		    void setUp() throws Exception {
		        MockitoAnnotations.openMocks(this);
		        mcpAgent = new MCPAgent();
		    }
		    
		    @Test
		    void testMCPAgentInitialization() {
		        assertNotNull(mcpAgent, "MCPAgent should be created successfully");
		        assertEquals("mcp", mcpAgent.getType(), "Agent type should be 'mcp'");
		        assertFalse(mcpAgent.isConnected(), "MCPAgent should not be connected by default");
		    }
		    
		    @Test
		    void testConnectAndDisconnect() throws Exception {
		        // Use reflection to set the serverUrl directly instead of connecting to a real server
		        MCPAgent spyAgent = spy(mcpAgent);
		        URL testUrl = new URL("http://test-server:8080");
		        java.lang.reflect.Field serverUrlField = MCPAgent.class.getDeclaredField("serverUrl");
		        serverUrlField.setAccessible(true);
		        serverUrlField.set(spyAgent, testUrl);
		        
		        assertEquals(testUrl, spyAgent.getServerUrl(), "Server URL should match the provided URL");
		        
		        // Test disconnect
		        spyAgent.disconnect();
		        // Since we didn't actually connect, isConnected would still return false which is the expected behavior
		        assertFalse(spyAgent.isConnected(), "MCPAgent should be disconnected after disconnect() call");
		    }
		    
		    @Test
		    void testConnectWithAuthToken() throws Exception {
		        // Use reflection to set the serverUrl directly instead of connecting to a real server
		        MCPAgent spyAgent = spy(mcpAgent);
		        URL testUrl = new URL("http://test-server:8080");
		        java.lang.reflect.Field serverUrlField = MCPAgent.class.getDeclaredField("serverUrl");
		        serverUrlField.setAccessible(true);
		        serverUrlField.set(spyAgent, testUrl);
		        
		        assertEquals(testUrl, spyAgent.getServerUrl(), "Server URL should match the provided URL");
		    }
		    
		    @Test
		    void testRemoteMethodCall() throws Exception {
		        // We need to mock the internal JsonNode processing
		        MCPAgent spyAgent = spy(mcpAgent);
		        
		        // Mock the mapper to avoid the NPE in remoteMethodCall
		        com.fasterxml.jackson.databind.ObjectMapper mockMapper = mock(com.fasterxml.jackson.databind.ObjectMapper.class);
		        com.fasterxml.jackson.databind.JsonNode mockRoot = mock(com.fasterxml.jackson.databind.JsonNode.class);
		        com.fasterxml.jackson.databind.JsonNode mockIdNode = mock(com.fasterxml.jackson.databind.JsonNode.class);
		        
		        // Set the mock mapper
		        java.lang.reflect.Field mapperField = MCPAgent.class.getDeclaredField("mapper");
		        mapperField.setAccessible(true);
		        mapperField.set(spyAgent, mockMapper);
		        
		        // Configure the mocks
		        when(mockMapper.readTree(anyString())).thenReturn(mockRoot);
		        when(mockRoot.get("toolName")).thenReturn(mockIdNode);
		        when(mockIdNode.asText()).thenReturn("test-method");
		        
		        // Mock the final call
		        doReturn(mockCallToolResult).when(spyAgent).callTool(any(CallToolRequest.class));
		        
		        // Call the method under test
		        CommonClientResponse response = spyAgent.remoteMethodCall("test-query");
		        
		        assertNotNull(response, "Response should not be null");
		        verify(spyAgent, times(1)).callTool(any(CallToolRequest.class));
		    }
		    
		    @Test
		    void testRemoteMethodCallWithParams() throws Exception {
		        MCPAgent spyAgent = spy(mcpAgent);
		        doReturn(mockCallToolResult).when(spyAgent).callTool(any(CallToolRequest.class));
		        
		        CommonClientResponse response = spyAgent.remoteMethodCall("test-method", "test-params");
		        
		        assertNotNull(response, "Response should not be null");
		        verify(spyAgent, times(1)).callTool(any(CallToolRequest.class));
		    }
		    
		    @Test
		    void testGetAgentInfo() {
		        // Since the agent isn't connected, we can't test specific properties
		        // We'll just verify the info is retrieved
		        AgentInfo info = mcpAgent.getInfo();
		        
		        // The info might be null initially since the agent isn't connected
		        if (info != null) {
		            assertNotNull(info.getAgentCapabilities(), "Agent capabilities should not be null if info is available");
		        }
		    }
		    
		    @Test
		    void testToString() {
		        String result = mcpAgent.toString();
		        
		        assertNotNull(result, "ToString result should not be null");
		        assertTrue(result.contains("mcp"), "ToString should contain agent type");
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\CallToolResultTest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		
		import java.util.ArrayList;
		import java.util.List;
		
		import static org.junit.jupiter.api.Assertions.*;
		
		public class CallToolResultTest {
		    
		    private CallToolResult callToolResult;
		    private TextContent textContent;
		    private ImageContent imageContent;
		    private Annotations annotations;
		    
		    @BeforeEach
		    void setUp() {
		        callToolResult = new CallToolResult();
		        textContent = new TextContent();
		        imageContent = new ImageContent();
		        annotations = new Annotations();
		    }
		    
		    @Test
		    void testEmptyCallToolResult() {
		        assertNotNull(callToolResult, "CallToolResult should be created successfully");
		        assertNull(callToolResult.getContent(), "Content should be null by default");
		    }
		    
		    @Test
		    void testWithTextContent() {
		        textContent.setText("Test text content");
		        textContent.setType("text/plain");
		        
		        List<Content> contentList = new ArrayList<>();
		        contentList.add(textContent);
		        
		        callToolResult.setContent(contentList);
		        
		        assertNotNull(callToolResult.getContent(), "Content should not be null");
		        assertEquals(1, callToolResult.getContent().size(), "Content list should have one item");
		        assertTrue(callToolResult.getContent().get(0) instanceof TextContent, "First content item should be TextContent");
		        
		        TextContent retrievedContent = (TextContent) callToolResult.getContent().get(0);
		        assertEquals("Test text content", retrievedContent.getText(), "Text content should match");
		        assertEquals("text/plain", retrievedContent.getType(), "Type should match");
		    }
		    
		    @Test
		    void testWithMultipleContentTypes() {
		        textContent.setText("Test text content");
		        textContent.setType("text/plain");
		        
		        imageContent.setData("base64EncodedData");
		        imageContent.setMimeType("image/png");
		        
		        List<Content> contentList = new ArrayList<>();
		        contentList.add(textContent);
		        contentList.add(imageContent);
		        
		        callToolResult.setContent(contentList);
		        
		        assertNotNull(callToolResult.getContent(), "Content should not be null");
		        assertEquals(2, callToolResult.getContent().size(), "Content list should have two items");
		        
		        assertTrue(callToolResult.getContent().get(0) instanceof TextContent, "First content item should be TextContent");
		        assertTrue(callToolResult.getContent().get(1) instanceof ImageContent, "Second content item should be ImageContent");
		        
		        ImageContent retrievedImageContent = (ImageContent) callToolResult.getContent().get(1);
		        assertEquals("base64EncodedData", retrievedImageContent.getData(), "Image data should match");
		        assertEquals("image/png", retrievedImageContent.getMimeType(), "MIME type should match");
		    }
		    
		    @Test
		    void testWithAnnotations() {
		        annotations.setPriority(1.5);
		        
		        textContent.setText("Annotated text");
		        textContent.setType("text/plain");
		        textContent.setAnnotations(annotations);
		        
		        List<Content> contentList = new ArrayList<>();
		        contentList.add(textContent);
		        
		        callToolResult.setContent(contentList);
		        
		        TextContent retrievedContent = (TextContent) callToolResult.getContent().get(0);
		        assertNotNull(retrievedContent.getAnnotations(), "Annotations should not be null");
		        assertEquals(1.5, retrievedContent.getAnnotations().getPriority(), "Priority should match");
		    }
		    
		    @Test
		    void testWithNullContent() {
		        callToolResult.setContent(null);
		        assertNull(callToolResult.getContent(), "Content should remain null");
		    }
		    
		    @Test
		    void testWithEmptyContentList() {
		        callToolResult.setContent(new ArrayList<>());
		        assertNotNull(callToolResult.getContent(), "Content list should not be null");
		        assertEquals(0, callToolResult.getContent().size(), "Content list should be empty");
		    }
		    
		    @Test
		    void testToString() {
		        textContent.setText("ToString test");
		        textContent.setType("text/plain");
		        
		        List<Content> contentList = new ArrayList<>();
		        contentList.add(textContent);
		        
		        callToolResult.setContent(contentList);
		        
		        String result = callToolResult.toString();
		        
		        assertNotNull(result, "ToString result should not be null");
		        assertTrue(result.contains("ToString test"), "ToString should contain text content");
		    }
		    
		    @Test
		    void testEquality() {
		        textContent.setText("Equality test");
		        
		        List<Content> contentList1 = new ArrayList<>();
		        contentList1.add(textContent);
		        
		        List<Content> contentList2 = new ArrayList<>();
		        contentList2.add(textContent);
		        
		        CallToolResult result1 = new CallToolResult();
		        result1.setContent(contentList1);
		        
		        CallToolResult result2 = new CallToolResult();
		        result2.setContent(contentList2);
		        
		        assertEquals(result1, result1, "Object should equal itself");
		        assertNotEquals(result1, new Object(), "Different types should not be equal");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\ClientCapabilitiesTest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class ClientCapabilitiesTest {
		
		    @Test
		    public void testClientCapabilitiesInitialization() {
		        ClientCapabilities capabilities = new ClientCapabilities();
		        assertNotNull(capabilities, "ClientCapabilities should be initialized successfully");
		    }
		
		    // Additional tests for ClientCapabilities methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\CompleteResultTest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class CompleteResultTest {
		
		    @Test
		    public void testCompleteResultInitialization() {
		        CompleteResult result = new CompleteResult();
		        assertNotNull(result, "CompleteResult should be initialized successfully");
		    }
		
		    // Additional tests for CompleteResult methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\InitializeResultTest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class InitializeResultTest {
		
		    @Test
		    public void testInitializeResultInitialization() {
		        InitializeResult result = new InitializeResult();
		        assertNotNull(result, "InitializeResult should be initialized successfully");
		    }
		
		    // Additional tests for InitializeResult methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\MCPTestDomain.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import com.fasterxml.jackson.databind.DeserializationFeature;
		import com.fasterxml.jackson.databind.ObjectMapper;
		import io.github.vishalmysore.mcp.client.MCPAgent;
		import org.junit.jupiter.api.Test;
		
		import java.net.MalformedURLException;
		import java.net.URL;
		import java.util.*;
		
		import static org.junit.jupiter.api.Assertions.*;
		
		public class MCPTestDomain {
		
		    private ObjectMapper mapper = new ObjectMapper();
		
		
		    @Test
		    public void testCallRequest() {
		        try {
		            String jsonString = "{\"method\":\"tools/call\",\"params\":{\"name\":\"browseWebAndPerformAction\",\"arguments\":{\"provideAllValuesInPlainEnglish\":\"Go to Google.com, search for \\\"a2ajava\\\", wait for results to load, click on the first search result link, wait for the page to load completely, then take a screenshot of the page\"}}}";
		            CallToolRequest request = mapper.readValue(jsonString, CallToolRequest.class);
		            assertNotNull(request);
		            assertEquals("tools/call", request.getMethod());
		            assertEquals("browseWebAndPerformAction", request.getParams().getName());
		        } catch (Exception e) {
		            e.printStackTrace();
		            throw new RuntimeException("Failed to parse CallToolRequest: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testCallToolResult() {
		        try {
		            // Create a sample CallToolResult
		            CallToolResult result = new CallToolResult();
		            List<Content> contentList = new ArrayList<>();
		              // Add a text content
		            TextContent textContent = new TextContent();
		            textContent.setText("Test result message");
		            textContent.setType("text");
		            contentList.add(textContent);
		            
		            // Add an image content
		            ImageContent imageContent = new ImageContent();
		            imageContent.setMimeType("image/png");
		            imageContent.setData("base64EncodedData");
		            contentList.add(imageContent);
		            
		            result.setContent(contentList);
		
		            String jsonString = mapper.writeValueAsString(result);
		            CallToolResult parsedResult = mapper.readValue(jsonString, CallToolResult.class);
		            
		            assertNotNull(parsedResult);
		            assertNotNull(parsedResult.getContent());
		            assertEquals(2, parsedResult.getContent().size());
		            
		            // Verify text content
		            Content firstContent = parsedResult.getContent().get(0);
		            assertEquals(TextContent.class, firstContent.getClass());
		            assertEquals("text", ((TextContent)firstContent).getType());
		            assertEquals("Test result message", ((TextContent)firstContent).getText());
		            
		            // Verify image content
		            Content secondContent = parsedResult.getContent().get(1);
		            assertEquals(ImageContent.class, secondContent.getClass());
		            assertEquals("image/png", ((ImageContent)secondContent).getMimeType());
		            assertEquals("base64EncodedData", ((ImageContent)secondContent).getData());
		        } catch (Exception e) {
		            e.printStackTrace();
		            throw new RuntimeException("Failed to test CallToolResult: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testJsonRpcResponse() {
		        try {
		            JSONRPCResponse response = new JSONRPCResponse();
		            response.setId("test-id-123");
		            
		            CallToolResult result = new CallToolResult();
		            List<Content> contentList = new ArrayList<>();            TextContent textContent = new TextContent();
		            textContent.setText("Response message");
		            textContent.setType("text");
		            contentList.add(textContent);
		            result.setContent(contentList);
		            
		            response.setResult(result);
		
		            String jsonString = mapper.writeValueAsString(response);
		            JSONRPCResponse parsedResponse = mapper.readValue(jsonString, JSONRPCResponse.class);
		            
		            assertNotNull(parsedResponse);
		            assertEquals("test-id-123", parsedResponse.getId());
		            assertEquals("2.0", parsedResponse.getJsonrpc());
		            
		            assertNotNull(parsedResponse.getResult());
		            assertTrue(parsedResponse.getResult() instanceof CallToolResult);
		            CallToolResult parsedResult = (CallToolResult) parsedResponse.getResult();
		            assertNotNull(parsedResult.getContent());
		            assertEquals(1, parsedResult.getContent().size());
		            
		            Content content = parsedResult.getContent().get(0);
		            assertEquals(TextContent.class, content.getClass());
		            assertEquals("text", ((TextContent)content).getType());
		            assertEquals("Response message", ((TextContent)content).getText());
		        } catch (Exception e) {
		            e.printStackTrace();
		            throw new RuntimeException("Failed to test JSONRPCResponse: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testAudioContent() {
		        try {
		            AudioContent audioContent = new AudioContent();
		            audioContent.setData("base64EncodedAudioData");
		            audioContent.setMimeType("audio/mp3");
		            
		            Annotations annotations = new Annotations();
		            annotations.setPriority(1.0);
		            annotations.setAudience(Arrays.asList(Role.USER));
		            audioContent.setAnnotations(annotations);
		
		            String jsonString = mapper.writeValueAsString(audioContent);
		            AudioContent parsedContent = mapper.readValue(jsonString, AudioContent.class);
		            
		            assertNotNull(parsedContent);
		            assertEquals("audio", parsedContent.getType());
		            assertEquals("audio/mp3", parsedContent.getMimeType());
		            assertEquals("base64EncodedAudioData", parsedContent.getData());
		            assertNotNull(parsedContent.getAnnotations());
		            assertEquals(1.0, parsedContent.getAnnotations().getPriority());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test AudioContent: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testBlobAndTextResourceContents() {
		        try {
		            // Test BlobResourceContents
		            BlobResourceContents blobContent = new BlobResourceContents();
		            blobContent.setBlob("base64EncodedData");
		            blobContent.setMimeType("application/octet-stream");
		            blobContent.setUri("file:///example/blob.dat");
		
		            String blobJson = mapper.writeValueAsString(blobContent);
		            BlobResourceContents parsedBlob = mapper.readValue(blobJson, BlobResourceContents.class);
		            
		            assertNotNull(parsedBlob);
		            assertEquals("base64EncodedData", parsedBlob.getBlob());
		            assertEquals("application/octet-stream", parsedBlob.getMimeType());
		            assertEquals("file:///example/blob.dat", parsedBlob.getUri());
		
		            // Test TextResourceContents
		            TextResourceContents textContent = new TextResourceContents();
		            textContent.setText("Sample text content");
		            textContent.setMimeType("text/plain");
		            
		            Annotations textAnnotations = new Annotations();
		            textAnnotations.setPriority(2.0);
		            textContent.setAnnotations(textAnnotations);
		
		            String textJson = mapper.writeValueAsString(textContent);
		            TextResourceContents parsedText = mapper.readValue(textJson, TextResourceContents.class);
		            
		            assertNotNull(parsedText);
		            assertEquals("Sample text content", parsedText.getText());
		            assertEquals("text/plain", parsedText.getMimeType());
		            assertEquals(2.0, parsedText.getAnnotations().getPriority());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test Resource Contents: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testServerCapabilities() {
		        try {
		            ServerCapabilities capabilities = new ServerCapabilities();
		            capabilities.setContentTypes(Arrays.asList("text/plain", "image/png"));
		            capabilities.setRoles(Arrays.asList("user", "assistant"));
		            capabilities.setSamplingMethods(Arrays.asList("temperature", "top_p"));
		            capabilities.setToolTypes(Arrays.asList("function", "command"));
		
		            String jsonString = mapper.writeValueAsString(capabilities);
		            ServerCapabilities parsedCapabilities = mapper.readValue(jsonString, ServerCapabilities.class);
		            
		            assertNotNull(parsedCapabilities);
		            assertEquals(2, parsedCapabilities.getContentTypes().size());
		            assertEquals(2, parsedCapabilities.getRoles().size());
		            assertEquals(2, parsedCapabilities.getSamplingMethods().size());
		            assertEquals(2, parsedCapabilities.getToolTypes().size());
		            assertTrue(parsedCapabilities.getContentTypes().contains("text/plain"));
		            assertTrue(parsedCapabilities.getToolTypes().contains("function"));
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test ServerCapabilities: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testImplementationAndPreferences() {
		        try {
		            Implementation impl = new Implementation();
		            impl.setName("TestServer");
		            impl.setVersion("1.0.0");
		
		            String implJson = mapper.writeValueAsString(impl);
		            Implementation parsedImpl = mapper.readValue(implJson, Implementation.class);
		            
		            assertNotNull(parsedImpl);
		            assertEquals("TestServer", parsedImpl.getName());
		            assertEquals("1.0.0", parsedImpl.getVersion());
		
		            ModelPreferences prefs = new ModelPreferences();
		            prefs.setModelName("gpt-4");
		
		            String prefsJson = mapper.writeValueAsString(prefs);
		            ModelPreferences parsedPrefs = mapper.readValue(prefsJson, ModelPreferences.class);
		            
		            assertNotNull(parsedPrefs);
		            assertEquals("gpt-4", parsedPrefs.getModelName());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test Implementation/Preferences: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testSamplingMessage() {
		        try {
		            SamplingMessage message = new SamplingMessage();            message.setRole(Role.USER);
		            
		            TextContent textContent = new TextContent();
		            textContent.setText("Sample message content");
		            textContent.setType("text");
		            message.setContent(textContent);
		
		            String jsonString = mapper.writeValueAsString(message);
		            SamplingMessage parsedMessage = mapper.readValue(jsonString, SamplingMessage.class);
		            
		            assertNotNull(parsedMessage);
		            assertEquals(Role.USER, parsedMessage.getRole());
		            assertNotNull(parsedMessage.getContent());
		            assertTrue(parsedMessage.getContent() instanceof TextContent);
		            assertEquals("Sample message content", ((TextContent)parsedMessage.getContent()).getText());
		            assertEquals("text", ((TextContent)parsedMessage.getContent()).getType());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test SamplingMessage: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testCancelNotification() {
		        try {
		            CancelledNotification cancelledNotification = new CancelledNotification();
		           // cancelledNotification.setId("test-id-123");
		            Map<String, Object> meta = new HashMap<>();
		            meta.put("reason", "user_request");
		         //   cancelledNotification.getParams().setMeta(meta);
		
		            String jsonString = mapper.writeValueAsString(cancelledNotification);
		            CancelledNotification parsedNotification = mapper.readValue(jsonString, CancelledNotification.class);
		
		            assertNotNull(parsedNotification);
		            assertEquals("notifications/cancelled", parsedNotification.getMethod());
		           // assertEquals("test-id-123", parsedNotification.getId());
		          //  assertNotNull(parsedNotification.getParams().getMeta());
		          //  assertEquals("user_request", parsedNotification.getParams().getMeta().get("reason"));
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test CancelledNotification: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testClientNotification() {
		        try {
		            InitializedNotification notification = new InitializedNotification();
		            InitializedNotification.Params params = new InitializedNotification.Params();
		            Map<String, Object> meta = new HashMap<>();
		            meta.put("clientVersion", "1.0.0");
		            params.setMeta(meta);
		            notification.setParams(params);
		
		            String jsonString = mapper.writeValueAsString(notification);
		            InitializedNotification parsedNotification = mapper.readValue(jsonString, InitializedNotification.class);
		
		            assertNotNull(parsedNotification);
		            assertEquals("notifications/initialized", parsedNotification.getMethod());
		            assertNotNull(parsedNotification.getParams());
		            assertNotNull(parsedNotification.getParams().getMeta());
		            assertEquals("1.0.0", parsedNotification.getParams().getMeta().get("clientVersion"));
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test ClientNotification: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testCompleteResult() {
		        try {
		            CompleteResult result = new CompleteResult();
		            Map<String, Object> meta = new HashMap<>();
		            meta.put("source", "test");
		            result.setMeta(meta);
		
		            CompleteResult.Completion completion = new CompleteResult.Completion();
		            completion.setHasMore(true);
		            completion.setTotal(5);
		            completion.setValues(Arrays.asList("completion1", "completion2"));
		            result.setCompletion(completion);
		
		            String jsonString = mapper.writeValueAsString(result);
		            CompleteResult parsedResult = mapper.readValue(jsonString, CompleteResult.class);
		
		            assertNotNull(parsedResult);
		            assertEquals("test", parsedResult.getMeta().get("source"));
		            assertTrue(parsedResult.getCompletion().getHasMore());
		            assertEquals(Integer.valueOf(5), parsedResult.getCompletion().getTotal());
		            assertEquals(2, parsedResult.getCompletion().getValues().size());
		            assertEquals("completion1", parsedResult.getCompletion().getValues().get(0));
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test CompleteResult: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testCreateMessageRequest() {
		        try {
		            CreateMessageRequest request = new CreateMessageRequest();
		            CreateMessageRequest.Params params = new CreateMessageRequest.Params();
		            params.setIncludeContext("all");
		            params.setMaxTokens(100);
		            
		            List<SamplingMessage> messages = new ArrayList<>();
		            SamplingMessage message = new SamplingMessage();
		            message.setRole(Role.USER);
		            TextContent content = new TextContent();
		            content.setText("Test message");
		            content.setType("text");
		            message.setContent(content);
		            messages.add(message);
		            params.setMessages(messages);
		            
		            ModelPreferences prefs = new ModelPreferences();
		            prefs.setModelName("gpt-4");
		            params.setModelPreferences(prefs);
		            
		            params.setStopSequences(Arrays.asList("stop1", "stop2"));
		            request.setParams(params);
		
		            String jsonString = mapper.writeValueAsString(request);
		            CreateMessageRequest parsedRequest = mapper.readValue(jsonString, CreateMessageRequest.class);
		
		            assertNotNull(parsedRequest);
		            assertEquals("sampling/createMessage", parsedRequest.getMethod());
		            assertEquals("all", parsedRequest.getParams().getIncludeContext());
		            assertEquals(Integer.valueOf(100), parsedRequest.getParams().getMaxTokens());
		            assertEquals(1, parsedRequest.getParams().getMessages().size());
		            assertEquals(2, parsedRequest.getParams().getStopSequences().size());
		            assertEquals("gpt-4", parsedRequest.getParams().getModelPreferences().getModelName());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test CreateMessageRequest: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testCreateMessageResult() {
		        try {
		            CreateMessageResult result = new CreateMessageResult();
		            Map<String, Object> meta = new HashMap<>();
		            meta.put("temperature", 0.7);
		            result.setMeta(meta);
		            
		            TextContent content = new TextContent();
		            content.setText("Generated response");
		            content.setType("text");
		            result.setContent(content);
		            
		            result.setModel("gpt-4");
		            result.setRole(Role.ASSISTANT);
		            result.setStopReason("length");
		
		            String jsonString = mapper.writeValueAsString(result);
		            CreateMessageResult parsedResult = mapper.readValue(jsonString, CreateMessageResult.class);
		
		            assertNotNull(parsedResult);
		            assertEquals(0.7, parsedResult.getMeta().get("temperature"));
		            assertTrue(parsedResult.getContent() instanceof TextContent);
		            assertEquals("Generated response", ((TextContent)parsedResult.getContent()).getText());
		            assertEquals("gpt-4", parsedResult.getModel());
		            assertEquals(Role.ASSISTANT, parsedResult.getRole());
		            assertEquals("length", parsedResult.getStopReason());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test CreateMessageResult: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testEmbeddedResource() {
		        try {
		            EmbeddedResource resource = new EmbeddedResource();
		            
		            Annotations annotations = new Annotations();
		            annotations.setPriority(1.0);
		            resource.setAnnotations(annotations);
		            
		            TextResourceContents textResource = new TextResourceContents();
		            textResource.setText("Resource content");
		            textResource.setMimeType("text/plain");
		            resource.setResource(textResource);
		
		            String jsonString = mapper.writeValueAsString(resource);
		            EmbeddedResource parsedResource = mapper.readValue(jsonString, EmbeddedResource.class);
		
		            assertNotNull(parsedResource);
		            assertEquals("resource", parsedResource.getType());
		            assertEquals(1.0, parsedResource.getAnnotations().getPriority());
		            assertTrue(parsedResource.getResource() instanceof TextResourceContents);
		            TextResourceContents parsedTextResource = (TextResourceContents)parsedResource.getResource();
		            assertEquals("Resource content", parsedTextResource.getText());
		            assertEquals("text/plain", parsedTextResource.getMimeType());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test EmbeddedResource: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testListToolsResult() {
		        try {
		            ListToolsResult result = new ListToolsResult();
		            Map<String, Object> meta = new HashMap<>();
		            meta.put("source", "test");
		            result.setMeta(meta);
		            
		            List<Tool> tools = new ArrayList<>();            Tool tool = new Tool();
		            tool.setName("testTool");
		            tool.setDescription("A test tool");
		            ToolParameters params = new ToolParameters();
		            params.setRequired(Arrays.asList("param1", "param2"));
		            tool.setParameters(params);
		            tools.add(tool);
		            result.setTools(tools);
		
		            String jsonString = mapper.writeValueAsString(result);
		            ListToolsResult parsedResult = mapper.readValue(jsonString, ListToolsResult.class);
		
		            assertNotNull(parsedResult);
		            assertEquals("test", parsedResult.getMeta().get("source"));
		            assertEquals(1, parsedResult.getTools().size());
		            Tool parsedTool = parsedResult.getTools().get(0);
		            assertEquals("testTool", parsedTool.getName());
		            assertEquals("A test tool", parsedTool.getDescription());
		            assertNotNull(parsedTool.getParameters());
		            assertEquals(2, parsedTool.getParameters().getRequired().size());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test ListToolsResult: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testListResourcesResult() {
		        try {
		            ListResourcesResult result = new ListResourcesResult();
		            Map<String, Object> meta = new HashMap<>();
		            meta.put("total", 10);
		            result.setMeta(meta);
		            
		            result.setNextCursor("next-page-token");
		              List<Resource> resources = new ArrayList<>();
		            Resource resource = new Resource();
		            resource.setUri("file:///test.txt");
		            TextResourceContents contents = new TextResourceContents();
		            contents.setText("Test content");
		            contents.setMimeType("text/plain");
		            resource.setContents(contents);
		            resources.add(resource);
		            result.setResources(resources);
		
		            String jsonString = mapper.writeValueAsString(result);
		            ListResourcesResult parsedResult = mapper.readValue(jsonString, ListResourcesResult.class);
		
		            assertNotNull(parsedResult);
		            assertEquals(10, parsedResult.getMeta().get("total"));
		            assertEquals("next-page-token", parsedResult.getNextCursor());
		            assertEquals(1, parsedResult.getResources().size());
		            Resource parsedResource = parsedResult.getResources().get(0);
		            assertEquals("file:///test.txt", parsedResource.getUri());
		            assertTrue(parsedResource.getContents() instanceof TextResourceContents);
		            TextResourceContents parsedContents = (TextResourceContents) parsedResource.getContents();
		            assertEquals("Test content", parsedContents.getText());
		            assertEquals("text/plain", parsedContents.getMimeType());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test ListResourcesResult: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testInitializeResult() {
		        try {
		            InitializeResult result = new InitializeResult();
		            Map<String, Object> meta = new HashMap<>();
		            meta.put("version", "1.0");
		            result.setMeta(meta);
		            
		            ServerCapabilities capabilities = new ServerCapabilities();
		            capabilities.setContentTypes(Arrays.asList("text", "image"));
		            result.setCapabilities(capabilities);
		            
		            result.setInstructions("Test server instructions");
		            result.setProtocolVersion("1.0.0");
		            
		            Implementation serverInfo = new Implementation();
		            serverInfo.setName("TestServer");
		            serverInfo.setVersion("2.0.0");
		            result.setServerInfo(serverInfo);
		
		            String jsonString = mapper.writeValueAsString(result);
		            InitializeResult parsedResult = mapper.readValue(jsonString, InitializeResult.class);
		
		            assertNotNull(parsedResult);
		            assertEquals("1.0", parsedResult.getMeta().get("version"));
		            assertNotNull(parsedResult.getCapabilities());
		            assertEquals(2, parsedResult.getCapabilities().getContentTypes().size());
		            assertEquals("Test server instructions", parsedResult.getInstructions());
		            assertEquals("1.0.0", parsedResult.getProtocolVersion());
		            assertEquals("TestServer", parsedResult.getServerInfo().getName());
		            assertEquals("2.0.0", parsedResult.getServerInfo().getVersion());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test InitializeResult: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testUnsubscribeRequest() {
		        try {
		            UnsubscribeRequest request = new UnsubscribeRequest();
		            UnsubscribeRequest.Params params = new UnsubscribeRequest.Params();
		            params.setUri("file:///test/resource.txt");
		            request.setParams(params);
		
		            String jsonString = mapper.writeValueAsString(request);
		            UnsubscribeRequest parsedRequest = mapper.readValue(jsonString, UnsubscribeRequest.class);
		
		            assertNotNull(parsedRequest);
		            assertEquals("resources/unsubscribe", parsedRequest.getMethod());
		            assertEquals("file:///test/resource.txt", parsedRequest.getParams().getUri());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test UnsubscribeRequest: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testToolSchemas() {
		        try {
		            // Test ToolPropertySchema
		            ToolPropertySchema propSchema = new ToolPropertySchema();
		            propSchema.setType("string");
		            propSchema.setDescription("A test property");
		            Map<String, Object> additionalProps = new HashMap<>();
		            additionalProps.put("format", "date-time");
		            propSchema.setAdditionalProperties(additionalProps);
		            propSchema.setItems(true);
		
		            String propJson = mapper.writeValueAsString(propSchema);
		            ToolPropertySchema parsedPropSchema = mapper.readValue(propJson, ToolPropertySchema.class);
		
		            assertNotNull(parsedPropSchema);
		            assertEquals("string", parsedPropSchema.getType());
		            assertEquals("A test property", parsedPropSchema.getDescription());
		            assertTrue(parsedPropSchema.isItems());
		            assertEquals("date-time", parsedPropSchema.getAdditionalProperties().get("format"));
		
		            // Test ToolInputSchema
		            ToolInputSchema inputSchema = new ToolInputSchema();
		            Map<String, ToolPropertySchema> properties = new HashMap<>();
		            properties.put("testProp", propSchema);
		            inputSchema.setProperties(properties);
		            inputSchema.setRequired(Arrays.asList("testProp"));
		
		            String inputJson = mapper.writeValueAsString(inputSchema);
		            ToolInputSchema parsedInputSchema = mapper.readValue(inputJson, ToolInputSchema.class);
		
		            assertNotNull(parsedInputSchema);
		            assertEquals("object", parsedInputSchema.getType());
		            assertEquals(1, parsedInputSchema.getProperties().size());
		            assertEquals(1, parsedInputSchema.getRequired().size());
		            assertEquals("testProp", parsedInputSchema.getRequired().get(0));
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test Tool Schemas: " + e.getMessage(), e);
		        }
		    }    @Test
		    public void testResourceReference() {
		        try {
		            ResourceReference ref = new ResourceReference();
		            ref.setUri("file:///test/ref.txt");
		
		            String jsonString = mapper.writeValueAsString(ref);
		            ResourceReference parsedRef = mapper.readValue(jsonString, ResourceReference.class);
		
		            assertNotNull(parsedRef);
		            assertEquals("file:///test/ref.txt", parsedRef.getUri());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test ResourceReference: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testSubscribeRequest() {
		        try {
		            SubscribeRequest request = new SubscribeRequest();
		            SubscribeRequest.Params params = new SubscribeRequest.Params();
		            params.setUri("file:///test/resource.txt");
		            request.setParams(params);
		
		            String jsonString = mapper.writeValueAsString(request);
		            SubscribeRequest parsedRequest = mapper.readValue(jsonString, SubscribeRequest.class);
		
		            assertNotNull(parsedRequest);
		            assertEquals("resources/subscribe", parsedRequest.getMethod());
		            assertEquals("file:///test/resource.txt", parsedRequest.getParams().getUri());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test SubscribeRequest: " + e.getMessage(), e);
		        }
		    }    @Test
		    public void testSetLevelRequest() {
		        try {
		            SetLevelRequest request = new SetLevelRequest();
		            SetLevelRequest.Params params = new SetLevelRequest.Params();
		            params.setLevel("info");
		            request.setParams(params);
		
		            String jsonString = mapper.writeValueAsString(request);
		            SetLevelRequest parsedRequest = mapper.readValue(jsonString, SetLevelRequest.class);
		
		            assertNotNull(parsedRequest);
		            assertEquals("server/setLevel", parsedRequest.getMethod());
		            assertEquals("info", parsedRequest.getParams().getLevel());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test SetLevelRequest: " + e.getMessage(), e);
		        }
		    }    @Test
		    public void testSamplingContext() {
		        try {
		            SamplingContext context = new SamplingContext();
		            context.setUri("file:///test/context.txt");
		            
		            List<PromptMessage> messages = new ArrayList<>();
		            PromptMessage message = new PromptMessage();
		            message.setRole(Role.USER);
		            TextContent content = new TextContent();
		            content.setText("Test context");
		            content.setType("text");
		            message.setContent(content);
		            messages.add(message);
		            context.setMessages(messages);
		
		            String jsonString = mapper.writeValueAsString(context);
		            SamplingContext parsedContext = mapper.readValue(jsonString, SamplingContext.class);
		
		            assertNotNull(parsedContext);
		            assertEquals("file:///test/context.txt", parsedContext.getUri());
		            assertEquals(1, parsedContext.getMessages().size());
		            PromptMessage parsedMessage = parsedContext.getMessages().get(0);
		            assertEquals(Role.USER, parsedMessage.getRole());
		            assertTrue(parsedMessage.getContent() instanceof TextContent);
		            assertEquals("Test context", ((TextContent)parsedMessage.getContent()).getText());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test SamplingContext: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testResourceTemplate() {
		        try {
		            ResourceTemplate template = new ResourceTemplate();
		            template.setName("test-template");
		            template.setUri("file:///templates/test.txt");
		            
		            Annotations annotations = new Annotations();
		            annotations.setPriority(2.0);
		            template.setAnnotations(annotations);
		
		            String jsonString = mapper.writeValueAsString(template);
		            ResourceTemplate parsedTemplate = mapper.readValue(jsonString, ResourceTemplate.class);
		
		            assertNotNull(parsedTemplate);
		            assertEquals("test-template", parsedTemplate.getName());
		            assertEquals("file:///templates/test.txt", parsedTemplate.getUri());
		            assertEquals(2.0, parsedTemplate.getAnnotations().getPriority());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test ResourceTemplate: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testToolAnnotationsAndParameters() {
		        try {
		            // Test ToolAnnotations
		            ToolAnnotations annotations = new ToolAnnotations();
		            Map<String, Object> props = new HashMap<>();
		            props.put("isAsync", true);
		            props.put("timeout", 5000);
		            annotations.setProperties(props);
		
		            String annotationsJson = mapper.writeValueAsString(annotations);
		            ToolAnnotations parsedAnnotations = mapper.readValue(annotationsJson, ToolAnnotations.class);
		
		            assertNotNull(parsedAnnotations);
		            assertTrue((Boolean) parsedAnnotations.getProperties().get("isAsync"));
		            assertEquals(5000, parsedAnnotations.getProperties().get("timeout"));
		
		            // Test ToolParameter
		            ToolParameter param = new ToolParameter();
		            param.setType("string");
		            param.setDescription("A test parameter");
		
		            String paramJson = mapper.writeValueAsString(param);
		            ToolParameter parsedParam = mapper.readValue(paramJson, ToolParameter.class);
		
		            assertNotNull(parsedParam);
		            assertEquals("string", parsedParam.getType());
		            assertEquals("A test parameter", parsedParam.getDescription());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test Tool annotations and parameters: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testToolCallRequest() {
		        try {
		            ToolCallRequest request = new ToolCallRequest();
		            request.setName("testTool");
		            Map<String, Object> args = new HashMap<>();
		            args.put("input", "test input");
		            args.put("options", Arrays.asList("opt1", "opt2"));
		            request.setArguments(args);
		
		            String jsonString = mapper.writeValueAsString(request);
		            ToolCallRequest parsedRequest = mapper.readValue(jsonString, ToolCallRequest.class);
		
		            assertNotNull(parsedRequest);
		            assertEquals("testTool", parsedRequest.getName());
		            assertEquals("test input", parsedRequest.getArguments().get("input"));
		            assertTrue(parsedRequest.getArguments().get("options") instanceof List);
		            @SuppressWarnings("unchecked")
		            List<String> options = (List<String>) parsedRequest.getArguments().get("options");
		            assertEquals(2, options.size());
		            assertEquals("opt1", options.get(0));
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test ToolCallRequest: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testToolParameterCombinations() {
		        try {
		            // Create tool parameter with all fields
		            ToolParameter param = new ToolParameter();
		            param.setType("object");
		            param.setDescription("Complex parameter");
		
		            // Test array type parameter
		            String paramJson1 = "{\"type\":\"array\",\"description\":\"List parameter\"}";
		            ToolParameter parsedParam1 = mapper.readValue(paramJson1, ToolParameter.class);
		            assertEquals("array", parsedParam1.getType());
		            assertEquals("List parameter", parsedParam1.getDescription());
		
		            // Test number type parameter
		            String paramJson2 = "{\"type\":\"number\",\"description\":\"Numeric parameter\"}";
		            ToolParameter parsedParam2 = mapper.readValue(paramJson2, ToolParameter.class);
		            assertEquals("number", parsedParam2.getType());
		            assertEquals("Numeric parameter", parsedParam2.getDescription());
		
		            // Test boolean type parameter
		            String paramJson3 = "{\"type\":\"boolean\",\"description\":\"Flag parameter\"}";
		            ToolParameter parsedParam3 = mapper.readValue(paramJson3, ToolParameter.class);
		            assertEquals("boolean", parsedParam3.getType());
		            assertEquals("Flag parameter", parsedParam3.getDescription());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test Tool parameter combinations: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testToolAnnotationsEdgeCases() {
		        try {
		            ToolAnnotations annotations = new ToolAnnotations();
		            
		            // Test with empty map
		            String jsonString1 = mapper.writeValueAsString(annotations);
		            ToolAnnotations parsedAnnotations1 = mapper.readValue(jsonString1, ToolAnnotations.class);
		            assertNotNull(parsedAnnotations1.getProperties());
		            assertTrue(parsedAnnotations1.getProperties().isEmpty());
		
		            // Test with null values
		            Map<String, Object> props = new HashMap<>();
		            props.put("nullValue", null);
		            annotations.setProperties(props);
		            String jsonString2 = mapper.writeValueAsString(annotations);
		            ToolAnnotations parsedAnnotations2 = mapper.readValue(jsonString2, ToolAnnotations.class);
		            assertTrue(parsedAnnotations2.getProperties().containsKey("nullValue"));
		            assertNull(parsedAnnotations2.getProperties().get("nullValue"));
		
		            // Test with nested objects
		            Map<String, Object> nestedProps = new HashMap<>();
		            Map<String, Object> nestedMap = new HashMap<>();
		            nestedMap.put("nestedKey", "nestedValue");
		            nestedProps.put("nested", nestedMap);
		            annotations.setProperties(nestedProps);
		            String jsonString3 = mapper.writeValueAsString(annotations);
		            ToolAnnotations parsedAnnotations3 = mapper.readValue(jsonString3, ToolAnnotations.class);
		            assertTrue(parsedAnnotations3.getProperties().get("nested") instanceof Map);
		            @SuppressWarnings("unchecked")
		            Map<String, Object> parsedNestedMap = (Map<String, Object>) parsedAnnotations3.getProperties().get("nested");
		            assertEquals("nestedValue", parsedNestedMap.get("nestedKey"));
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test Tool annotations edge cases: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testResourceTemplateEdgeCases() {
		        try {
		            ResourceTemplate template = new ResourceTemplate();
		            
		            // Test with minimum required fields
		            String jsonString1 = mapper.writeValueAsString(template);
		            ResourceTemplate parsedTemplate1 = mapper.readValue(jsonString1, ResourceTemplate.class);
		            assertNotNull(parsedTemplate1);
		            assertNull(parsedTemplate1.getName());
		            assertNull(parsedTemplate1.getUri());
		            assertNull(parsedTemplate1.getAnnotations());
		
		            // Test with empty strings
		            template.setName("");
		            template.setUri("");
		            String jsonString2 = mapper.writeValueAsString(template);
		            ResourceTemplate parsedTemplate2 = mapper.readValue(jsonString2, ResourceTemplate.class);
		            assertEquals("", parsedTemplate2.getName());
		            assertEquals("", parsedTemplate2.getUri());
		
		            // Test with special characters in name and URI
		            template.setName("Test Template!@#$%^&*()");
		            template.setUri("file:///path/with/spaces and ★special★ chars/template.txt");
		            String jsonString3 = mapper.writeValueAsString(template);
		            ResourceTemplate parsedTemplate3 = mapper.readValue(jsonString3, ResourceTemplate.class);
		            assertEquals("Test Template!@#$%^&*()", parsedTemplate3.getName());
		            assertEquals("file:///path/with/spaces and ★special★ chars/template.txt", parsedTemplate3.getUri());
		        } catch (Exception e) {
		            throw new RuntimeException("Failed to test Resource template edge cases: " + e.getMessage(), e);
		        }
		    }
		
		    @Test
		    public void testImplementation() {
		        Implementation impl = new Implementation();
		        impl.setName("TestServer");
		        impl.setVersion("1.0.0");
		        
		        assertEquals("TestServer", impl.getName());
		        assertEquals("1.0.0", impl.getVersion());
		    }
		
		    @Test
		    public void testClientCapabilitiesConfig() {
		        ClientCapabilities caps = new ClientCapabilities();
		        
		        // Test roots capabilities
		        ClientCapabilities.Roots roots = new ClientCapabilities.Roots();
		        roots.setListChanged(true);
		        assertEquals(true, roots.getListChanged());
		        
		        Map<String, Object> sampling = new HashMap<>();
		        sampling.put("method", "temperature");
		        sampling.put("value", 0.7);
		        caps.setSampling(sampling);
		    }
		    
		    @Test
		    public void testServerCapabilitiesConfig() {
		        ServerCapabilities caps = new ServerCapabilities();
		        
		        List<String> contentTypes = Arrays.asList("text/plain", "application/json");
		        caps.setContentTypes(contentTypes);
		        assertEquals(contentTypes, caps.getContentTypes());
		        
		        List<String> roles = Arrays.asList("USER", "ASSISTANT", "SYSTEM");
		        caps.setRoles(roles);
		        assertEquals(roles, caps.getRoles());
		        
		        List<String> samplingMethods = Arrays.asList("temperature", "top_p");
		        caps.setSamplingMethods(samplingMethods);
		        assertEquals(samplingMethods, caps.getSamplingMethods());
		    }
		    
		    @Test
		    public void testMCPGenericResponse() {
		        MCPGenericResponse<String> response = new MCPGenericResponse<>();
		        response.setJsonrpc("2.0");
		        response.setId("123");
		        response.setResult("Test Result");
		        
		        assertEquals("2.0", response.getJsonrpc());
		        assertEquals("123", response.getId());
		        assertEquals("Test Result", response.getResult());
		    }
		    
		    @Test
		    public void testInitializedNotification() {
		        // Test InitializedNotification as example
		        InitializedNotification notification = new InitializedNotification();
		        InitializedNotification.Params params = new InitializedNotification.Params();
		        
		        Map<String, Object> meta = new HashMap<>();
		        meta.put("clientId", "test-client");
		        meta.put("timestamp", System.currentTimeMillis());
		        
		        params.setMeta(meta);
		        notification.setParams(params);
		        
		        assertEquals("notifications/initialized", notification.getMethod());
		        assertEquals(meta, notification.getParams().getMeta());
		    }
		    
		    @Test
		    public void testMCPAgentSetup() throws MalformedURLException {
		        URL serverUrl = new URL("http://localhost:8080");
		        MCPAgent agent = new MCPAgent(serverUrl);
		        
		        // Test basic properties
		        assertEquals("mcp", agent.getType());
		        assertEquals(serverUrl, agent.getServerUrl());
		        assertFalse(agent.isConnected());
		        
		        // Test object mapper configuration
		        ObjectMapper mapper = agent.getMapper();
		        assertFalse(mapper.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));
		    }
		    
		    // ...existing tests...
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\ServerCapabilitiesTest.java'>
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class ServerCapabilitiesTest {
		
		    @Test
		    public void testServerCapabilitiesInitialization() {
		        ServerCapabilities capabilities = new ServerCapabilities();
		        assertNotNull(capabilities, "ServerCapabilities should be initialized successfully");
		    }
		
		    // Additional tests for ServerCapabilities methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\TextContentTest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class TextContentTest {
		    
		    private TextContent textContent;
		    private static final String TEST_TEXT = "Test text content";
		    private static final String TEST_TYPE = "text/plain";
		    
		    @BeforeEach
		    void setUp() {
		        textContent = new TextContent();
		    }
		    
		    @Test
		    void testBasicTextContentCreation() {
		        assertNotNull(textContent, "TextContent should be created successfully");
		    }
		    
		    @Test
		    void testTextHandling() {
		        textContent.setText(TEST_TEXT);
		        assertEquals(TEST_TEXT, textContent.getText(), "Text should match set value");
		    }
		    
		    @Test
		    void testTypeHandling() {
		        textContent.setType(TEST_TYPE);
		        assertEquals(TEST_TYPE, textContent.getType(), "Type should match set value");
		    }
		    
		    @Test
		    void testTextContentWithAnnotations() {
		        Annotations annotations = new Annotations();
		        annotations.setPriority(1.5);
		        
		        textContent.setAnnotations(annotations);
		        textContent.setText(TEST_TEXT);
		        textContent.setType(TEST_TYPE);
		        
		        assertEquals(TEST_TEXT, textContent.getText(), "Text should match set value");
		        assertEquals(TEST_TYPE, textContent.getType(), "Type should match set value");
		        assertEquals(1.5, textContent.getAnnotations().getPriority(), "Annotations priority should match");
		    }
		    
		    @Test
		    void testNullValues() {
		        textContent.setText(null);
		        textContent.setType(null);
		        textContent.setAnnotations(null);
		        
		        assertNull(textContent.getText(), "Text should be null");
		        assertNull(textContent.getType(), "Type should be null");
		        assertNull(textContent.getAnnotations(), "Annotations should be null");
		    }
		    
		    @Test
		    void testEmptyValues() {
		        textContent.setText("");
		        textContent.setType("");
		        
		        assertEquals("", textContent.getText(), "Text should be empty string");
		        assertEquals("", textContent.getType(), "Type should be empty string");
		    }
		    
		    @Test
		    void testToString() {
		        textContent.setText(TEST_TEXT);
		        textContent.setType(TEST_TYPE);
		        
		        String result = textContent.toString();
		        assertTrue(result.contains(TEST_TEXT), "ToString should contain the text value");
		        assertTrue(result.contains(TEST_TYPE), "ToString should contain the type value");
		    }
		    
		    @Test
		    void testLongText() {
		        String longText = "This is a very long text that should be handled properly by the TextContent class. " +
		                "It contains multiple sentences and should be stored and retrieved correctly without any truncation " +
		                "or modification. This tests the ability to handle larger text inputs which is common in real-world usage.";
		        
		        textContent.setText(longText);
		        assertEquals(longText, textContent.getText(), "Long text should be stored and retrieved without modification");
		    }
		    
		    @Test
		    void testSpecialCharacters() {
		        String specialText = "Special characters: !@#$%^&*()_+{}|:<>?~`-=[]\\;',./\n\t\"";
		        textContent.setText(specialText);
		        assertEquals(specialText, textContent.getText(), "Special characters should be preserved");
		    }
		    
		    @Test
		    void testHtmlContent() {
		        String htmlContent = "<html><body><h1>Test</h1><p>This is HTML content</p></body></html>";
		        textContent.setText(htmlContent);
		        textContent.setType("text/html");
		        
		        assertEquals(htmlContent, textContent.getText(), "HTML content should be preserved");
		        assertEquals("text/html", textContent.getType(), "Type should be text/html");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\ToolAnnotationsTest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.HashMap;
		import java.util.Map;
		
		public class ToolAnnotationsTest {
		
		    private ToolAnnotations annotations;
		
		    @BeforeEach
		    public void setUp() {
		        annotations = new ToolAnnotations();
		    }
		
		    @Test
		    public void testToolAnnotationsInitialization() {
		        assertNotNull(annotations, "ToolAnnotations should be initialized successfully");
		        assertNotNull(annotations.getProperties(), "Properties map should be initialized");
		        assertTrue(annotations.getProperties().isEmpty(), "Properties map should be empty initially");
		    }
		
		    @Test
		    public void testSetAndGetProperties() {
		        Map<String, Object> properties = new HashMap<>();
		        properties.put("key1", "value1");
		        properties.put("key2", 123);
		        properties.put("key3", true);
		        
		        annotations.setProperties(properties);
		        
		        assertNotNull(annotations.getProperties(), "Properties should not be null after setting");
		        assertEquals(3, annotations.getProperties().size(), "Properties should contain 3 items");
		        assertEquals("value1", annotations.getProperties().get("key1"), "key1 should have value1");
		        assertEquals(123, annotations.getProperties().get("key2"), "key2 should have value 123");
		        assertEquals(true, annotations.getProperties().get("key3"), "key3 should have value true");
		    }
		
		    @Test
		    public void testAddProperty() {
		        annotations.getProperties().put("testKey", "testValue");
		        
		        assertEquals(1, annotations.getProperties().size(), "Properties should contain 1 item");
		        assertEquals("testValue", annotations.getProperties().get("testKey"), "testKey should have testValue");
		    }
		
		    @Test
		    public void testToString() {
		        annotations.getProperties().put("key1", "value1");
		        annotations.getProperties().put("key2", 123);
		        
		        String result = annotations.toString();
		        
		        assertTrue(result.contains("key1"), "toString should contain key1");
		        assertTrue(result.contains("value1"), "toString should contain value1");
		        assertTrue(result.contains("key2"), "toString should contain key2");
		        assertTrue(result.contains("123"), "toString should contain 123");
		    }
		
		    @Test
		    public void testEqualsAndHashCode() {
		        ToolAnnotations anno1 = new ToolAnnotations();
		        anno1.getProperties().put("key", "value");
		        
		        ToolAnnotations anno2 = new ToolAnnotations();
		        anno2.getProperties().put("key", "value");
		        
		        ToolAnnotations anno3 = new ToolAnnotations();
		        anno3.getProperties().put("differentKey", "differentValue");
		        
		        assertEquals(anno1, anno2, "Annotations with same properties should be equal");
		        assertNotEquals(anno1, anno3, "Annotations with different properties should not be equal");
		        assertEquals(anno1.hashCode(), anno2.hashCode(), "Hash codes should be equal for equal annotations");
		    }
		    
		    @Test
		    public void testComplexPropertyValues() {
		        Map<String, Object> nestedMap = new HashMap<>();
		        nestedMap.put("nestedKey1", "nestedValue1");
		        nestedMap.put("nestedKey2", 456);
		        
		        annotations.getProperties().put("simpleKey", "simpleValue");
		        annotations.getProperties().put("numericKey", 123);
		        annotations.getProperties().put("booleanKey", true);
		        annotations.getProperties().put("nullKey", null);
		        annotations.getProperties().put("complexKey", nestedMap);
		        
		        assertEquals(5, annotations.getProperties().size(), "Properties should contain 5 items");
		        assertEquals("simpleValue", annotations.getProperties().get("simpleKey"), "simpleKey should have correct value");
		        assertEquals(123, annotations.getProperties().get("numericKey"), "numericKey should have correct value");
		        assertEquals(true, annotations.getProperties().get("booleanKey"), "booleanKey should have correct value");
		        assertNull(annotations.getProperties().get("nullKey"), "nullKey should have null value");
		        
		        @SuppressWarnings("unchecked")
		        Map<String, Object> retrievedNestedMap = (Map<String, Object>) annotations.getProperties().get("complexKey");
		        
		        assertNotNull(retrievedNestedMap, "Retrieved nested map should not be null");
		        assertEquals(2, retrievedNestedMap.size(), "Retrieved nested map should have 2 entries");
		        assertEquals("nestedValue1", retrievedNestedMap.get("nestedKey1"), "Nested value 1 should be correct");
		        assertEquals(456, retrievedNestedMap.get("nestedKey2"), "Nested value 2 should be correct");
		    }
		    
		    @Test
		    public void testClearProperties() {
		        annotations.getProperties().put("key1", "value1");
		        annotations.getProperties().put("key2", "value2");
		        
		        assertEquals(2, annotations.getProperties().size(), "Properties should contain 2 items before clearing");
		        
		        annotations.getProperties().clear();
		        
		        assertEquals(0, annotations.getProperties().size(), "Properties should be empty after clearing");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\ToolInputSchemaTest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.Arrays;
		import java.util.HashMap;
		import java.util.List;
		import java.util.Map;
		
		public class ToolInputSchemaTest {
		
		    private ToolInputSchema schema;
		
		    @BeforeEach
		    public void setUp() {
		        schema = new ToolInputSchema();
		    }
		
		    @Test
		    public void testToolInputSchemaInitialization() {
		        assertNotNull(schema, "ToolInputSchema should be initialized successfully");
		        assertEquals("object", schema.getType(), "Type should be initialized to 'object'");
		        assertNull(schema.getProperties(), "Properties should be null initially");
		        assertNull(schema.getRequired(), "Required list should be null initially");
		    }
		
		    @Test
		    public void testGetType() {
		        assertEquals("object", schema.getType(), "Type should always be 'object'");
		    }
		
		    @Test
		    public void testSetAndGetProperties() {
		        Map<String, ToolPropertySchema> properties = new HashMap<>();
		        
		        ToolPropertySchema prop1 = new ToolPropertySchema();
		        prop1.setType("string");
		        prop1.setDescription("First property");
		        
		        ToolPropertySchema prop2 = new ToolPropertySchema();
		        prop2.setType("integer");
		        prop2.setDescription("Second property");
		        
		        properties.put("prop1", prop1);
		        properties.put("prop2", prop2);
		        
		        schema.setProperties(properties);
		        
		        assertNotNull(schema.getProperties(), "Properties should not be null after setting");
		        assertEquals(2, schema.getProperties().size(), "Properties should contain 2 items");
		        assertTrue(schema.getProperties().containsKey("prop1"), "Properties should contain prop1");
		        assertTrue(schema.getProperties().containsKey("prop2"), "Properties should contain prop2");
		        assertEquals("string", schema.getProperties().get("prop1").getType(), "prop1 should be of type string");
		        assertEquals("integer", schema.getProperties().get("prop2").getType(), "prop2 should be of type integer");
		    }
		    
		    @Test
		    public void testSetAndGetRequired() {
		        List<String> required = Arrays.asList("prop1", "prop2");
		        schema.setRequired(required);
		        
		        assertNotNull(schema.getRequired(), "Required list should not be null after setting");
		        assertEquals(2, schema.getRequired().size(), "Required list should contain 2 items");
		        assertEquals("prop1", schema.getRequired().get(0), "First required property should be prop1");
		        assertEquals("prop2", schema.getRequired().get(1), "Second required property should be prop2");
		    }
		    
		    @Test
		    public void testToString() {
		        Map<String, ToolPropertySchema> properties = new HashMap<>();
		        ToolPropertySchema prop = new ToolPropertySchema();
		        prop.setType("string");
		        prop.setDescription("Test property");
		        properties.put("testProp", prop);
		        schema.setProperties(properties);
		        
		        List<String> required = Arrays.asList("testProp");
		        schema.setRequired(required);
		        
		        String result = schema.toString();
		        
		        assertTrue(result.contains("testProp"), "toString should contain property name");
		        assertTrue(result.contains("type=object"), "toString should contain type value");
		        assertTrue(result.contains("string"), "toString should contain property type");
		    }
		    
		    @Test
		    public void testEqualsAndHashCode() {
		        ToolInputSchema schema1 = new ToolInputSchema();
		        Map<String, ToolPropertySchema> properties1 = new HashMap<>();
		        ToolPropertySchema prop1 = new ToolPropertySchema();
		        prop1.setType("string");
		        properties1.put("testProp", prop1);
		        schema1.setProperties(properties1);
		        schema1.setRequired(Arrays.asList("testProp"));
		        
		        ToolInputSchema schema2 = new ToolInputSchema();
		        Map<String, ToolPropertySchema> properties2 = new HashMap<>();
		        ToolPropertySchema prop2 = new ToolPropertySchema();
		        prop2.setType("string");
		        properties2.put("testProp", prop2);
		        schema2.setProperties(properties2);
		        schema2.setRequired(Arrays.asList("testProp"));
		        
		        ToolInputSchema schema3 = new ToolInputSchema();
		        Map<String, ToolPropertySchema> properties3 = new HashMap<>();
		        ToolPropertySchema prop3 = new ToolPropertySchema();
		        prop3.setType("integer");
		        properties3.put("differentProp", prop3);
		        schema3.setProperties(properties3);
		        
		        assertEquals(schema1, schema2, "Schemas with same properties should be equal");
		        assertNotEquals(schema1, schema3, "Schemas with different properties should not be equal");
		        assertEquals(schema1.hashCode(), schema2.hashCode(), "Hash codes should be equal for equal schemas");
		    }
		    
		    @Test
		    public void testEmptyProperties() {
		        Map<String, ToolPropertySchema> emptyProperties = new HashMap<>();
		        schema.setProperties(emptyProperties);
		        
		        assertNotNull(schema.getProperties(), "Properties should not be null even when empty");
		        assertTrue(schema.getProperties().isEmpty(), "Properties should be empty");
		    }
		    
		    @Test
		    public void testEmptyRequired() {
		        List<String> emptyRequired = Arrays.asList();
		        schema.setRequired(emptyRequired);
		        
		        assertNotNull(schema.getRequired(), "Required list should not be null even when empty");
		        assertTrue(schema.getRequired().isEmpty(), "Required list should be empty");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\ToolParametersTest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.Arrays;
		import java.util.HashMap;
		import java.util.List;
		import java.util.Map;
		
		public class ToolParametersTest {
		
		    private ToolParameters parameters;
		
		    @BeforeEach
		    public void setUp() {
		        parameters = new ToolParameters();
		    }
		
		    @Test
		    public void testToolParametersInitialization() {
		        assertNotNull(parameters, "ToolParameters should be initialized successfully");
		        assertNotNull(parameters.getProperties(), "Properties map should be initialized");
		        assertNotNull(parameters.getRequired(), "Required list should be initialized");
		        assertEquals("object", parameters.getType(), "Type should have correct default value");
		        assertFalse(parameters.isAdditionalProperties(), "AdditionalProperties should be false by default");
		    }
		    
		    // Skipping $schema tests due to Lombok not generating standard getters/setters for fields starting with $
		    
		    @Test
		    public void testSetAndGetType() {
		        String newType = "customType";
		        parameters.setType(newType);
		        assertEquals(newType, parameters.getType(), "Type should be updated");
		    }
		    
		    @Test
		    public void testSetAndGetProperties() {
		        Map<String, ToolParameter> newProperties = new HashMap<>();
		        
		        ToolParameter param1 = new ToolParameter();
		        param1.setType("string");
		        param1.setDescription("First parameter");
		        
		        ToolParameter param2 = new ToolParameter();
		        param2.setType("integer");
		        param2.setDescription("Second parameter");
		        
		        newProperties.put("param1", param1);
		        newProperties.put("param2", param2);
		        
		        parameters.setProperties(newProperties);
		        
		        assertEquals(2, parameters.getProperties().size(), "Properties should contain 2 items");
		        assertTrue(parameters.getProperties().containsKey("param1"), "Properties should contain param1");
		        assertTrue(parameters.getProperties().containsKey("param2"), "Properties should contain param2");
		        assertEquals("string", parameters.getProperties().get("param1").getType(), "param1 should be of type string");
		        assertEquals("integer", parameters.getProperties().get("param2").getType(), "param2 should be of type integer");
		    }
		    
		    @Test
		    public void testAddProperty() {
		        ToolParameter param = new ToolParameter();
		        param.setType("boolean");
		        param.setDescription("Test parameter");
		        
		        parameters.getProperties().put("testParam", param);
		        
		        assertEquals(1, parameters.getProperties().size(), "Properties should contain 1 item");
		        assertTrue(parameters.getProperties().containsKey("testParam"), "Properties should contain testParam");
		        assertEquals("boolean", parameters.getProperties().get("testParam").getType(), "Parameter should be of type boolean");
		    }
		    
		    @Test
		    public void testSetAndGetRequired() {
		        List<String> required = Arrays.asList("param1", "param2", "param3");
		        parameters.setRequired(required);
		        
		        assertEquals(3, parameters.getRequired().size(), "Required list should contain 3 items");
		        assertTrue(parameters.getRequired().contains("param1"), "Required list should contain param1");
		        assertTrue(parameters.getRequired().contains("param2"), "Required list should contain param2");
		        assertTrue(parameters.getRequired().contains("param3"), "Required list should contain param3");
		    }
		    
		    @Test
		    public void testAddRequired() {
		        parameters.getRequired().add("param1");
		        parameters.getRequired().add("param2");
		        
		        assertEquals(2, parameters.getRequired().size(), "Required list should contain 2 items");
		        assertEquals("param1", parameters.getRequired().get(0), "First required parameter should be param1");
		        assertEquals("param2", parameters.getRequired().get(1), "Second required parameter should be param2");
		    }
		    
		    @Test
		    public void testSetAndGetAdditionalProperties() {
		        parameters.setAdditionalProperties(true);
		        assertTrue(parameters.isAdditionalProperties(), "AdditionalProperties should be true");
		        
		        parameters.setAdditionalProperties(false);
		        assertFalse(parameters.isAdditionalProperties(), "AdditionalProperties should be false");
		    }
		    
		    @Test
		    public void testToString() {
		        ToolParameter param = new ToolParameter();
		        param.setType("string");
		        param.setDescription("Test parameter");
		        parameters.getProperties().put("testParam", param);
		        parameters.getRequired().add("testParam");
		        
		        String result = parameters.toString();
		        
		        assertTrue(result.contains("testParam"), "toString should contain property name");
		        // Not verifying schema since Lombok might generate different toString implementation
		        assertTrue(result.contains("object"), "toString should contain type");
		        assertTrue(result.contains("additionalProperties=false"), "toString should contain additionalProperties value");
		    }
		    
		    @Test
		    public void testEqualsAndHashCode() {
		        ToolParameters params1 = new ToolParameters();
		        params1.setType("object");
		        params1.getRequired().add("param1");
		        
		        ToolParameters params2 = new ToolParameters();
		        params2.setType("object");
		        params2.getRequired().add("param1");
		        
		        ToolParameters params3 = new ToolParameters();
		        params3.setType("array");
		        params3.getRequired().add("param2");
		        
		        assertEquals(params1, params2, "Parameters with same properties should be equal");
		        assertNotEquals(params1, params3, "Parameters with different properties should not be equal");
		        assertEquals(params1.hashCode(), params2.hashCode(), "Hash codes should be equal for equal parameters");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\ToolParameterTest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class ToolParameterTest {
		
		    private ToolParameter toolParameter;
		
		    @BeforeEach
		    public void setUp() {
		        toolParameter = new ToolParameter();
		    }
		
		    @Test
		    public void testToolParameterInitialization() {
		        assertNotNull(toolParameter, "ToolParameter should be initialized successfully");
		        assertNull(toolParameter.getType(), "Type should be null initially");
		        assertNull(toolParameter.getDescription(), "Description should be null initially");
		    }
		
		    @Test
		    public void testSetAndGetType() {
		        String type = "string";
		        toolParameter.setType(type);
		        assertEquals(type, toolParameter.getType(), "Type should be set and retrieved correctly");
		    }
		
		    @Test
		    public void testSetAndGetDescription() {
		        String description = "Test parameter description";
		        toolParameter.setDescription(description);
		        assertEquals(description, toolParameter.getDescription(), "Description should be set and retrieved correctly");
		    }
		
		    @Test
		    public void testToString() {
		        toolParameter.setType("integer");
		        toolParameter.setDescription("A number parameter");
		        
		        String result = toolParameter.toString();
		        
		        assertTrue(result.contains("integer"), "toString should contain the type");
		        assertTrue(result.contains("A number parameter"), "toString should contain the description");
		    }
		
		    @Test
		    public void testEqualsAndHashCode() {
		        ToolParameter param1 = new ToolParameter();
		        param1.setType("string");
		        param1.setDescription("Test description");
		        
		        ToolParameter param2 = new ToolParameter();
		        param2.setType("string");
		        param2.setDescription("Test description");
		        
		        ToolParameter param3 = new ToolParameter();
		        param3.setType("number");
		        param3.setDescription("Different description");
		        
		        assertEquals(param1, param2, "Parameters with same properties should be equal");
		        assertNotEquals(param1, param3, "Parameters with different properties should not be equal");
		        assertEquals(param1.hashCode(), param2.hashCode(), "Hash codes should be equal for equal parameters");
		    }
		
		    @Test
		    public void testSpecialCharactersInDescription() {
		        String description = "Parameter with special characters: !@#$%^&*()_+";
		        toolParameter.setDescription(description);
		        assertEquals(description, toolParameter.getDescription(), "Description with special characters should be handled correctly");
		    }
		    
		    @Test
		    public void testNonStringTypes() {
		        String[] types = {"string", "number", "integer", "boolean", "object", "array"};
		        
		        for (String type : types) {
		            toolParameter.setType(type);
		            assertEquals(type, toolParameter.getType(), "Type " + type + " should be set and retrieved correctly");
		        }
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\ToolPropertySchemaTest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.HashMap;
		import java.util.Map;
		
		public class ToolPropertySchemaTest {
		
		    private ToolPropertySchema propertySchema;
		
		    @BeforeEach
		    public void setUp() {
		        propertySchema = new ToolPropertySchema();
		    }
		
		    @Test
		    public void testToolPropertySchemaInitialization() {
		        assertNotNull(propertySchema, "ToolPropertySchema should be initialized successfully");
		        assertNull(propertySchema.getType(), "Type should be null initially");
		        assertNull(propertySchema.getDescription(), "Description should be null initially");
		        assertNull(propertySchema.getAdditionalProperties(), "AdditionalProperties should be null initially");
		        assertFalse(propertySchema.isItems(), "Items should be false initially");
		    }
		
		    @Test
		    public void testSetAndGetType() {
		        String type = "string";
		        propertySchema.setType(type);
		        assertEquals(type, propertySchema.getType(), "Type should be set and retrieved correctly");
		    }
		
		    @Test
		    public void testSetAndGetDescription() {
		        String description = "Test property description";
		        propertySchema.setDescription(description);
		        assertEquals(description, propertySchema.getDescription(), "Description should be set and retrieved correctly");
		    }
		
		    @Test
		    public void testSetAndGetAdditionalProperties() {
		        Map<String, Object> additionalProps = new HashMap<>();
		        additionalProps.put("format", "date-time");
		        additionalProps.put("minimum", 0);
		        additionalProps.put("maximum", 100);
		        
		        propertySchema.setAdditionalProperties(additionalProps);
		        
		        assertNotNull(propertySchema.getAdditionalProperties(), "AdditionalProperties should not be null after setting");
		        assertEquals(3, propertySchema.getAdditionalProperties().size(), "AdditionalProperties should have 3 entries");
		        assertEquals("date-time", propertySchema.getAdditionalProperties().get("format"), "Format should be date-time");
		        assertEquals(0, propertySchema.getAdditionalProperties().get("minimum"), "Minimum should be 0");
		        assertEquals(100, propertySchema.getAdditionalProperties().get("maximum"), "Maximum should be 100");
		    }
		
		    @Test
		    public void testSetAndGetItems() {
		        propertySchema.setItems(true);
		        assertTrue(propertySchema.isItems(), "Items should be true after setting to true");
		        
		        propertySchema.setItems(false);
		        assertFalse(propertySchema.isItems(), "Items should be false after setting to false");
		    }
		
		    @Test
		    public void testToString() {
		        propertySchema.setType("number");
		        propertySchema.setDescription("A numeric property");
		        propertySchema.setItems(true);
		        
		        Map<String, Object> additionalProps = new HashMap<>();
		        additionalProps.put("format", "float");
		        propertySchema.setAdditionalProperties(additionalProps);
		        
		        String result = propertySchema.toString();
		        
		        assertTrue(result.contains("number"), "toString should contain the type");
		        assertTrue(result.contains("A numeric property"), "toString should contain the description");
		        assertTrue(result.contains("items=true"), "toString should contain the items value");
		        assertTrue(result.contains("format"), "toString should contain the additionalProperties keys");
		        assertTrue(result.contains("float"), "toString should contain the additionalProperties values");
		    }
		
		    @Test
		    public void testEqualsAndHashCode() {
		        ToolPropertySchema schema1 = new ToolPropertySchema();
		        schema1.setType("boolean");
		        schema1.setDescription("A boolean property");
		        schema1.setItems(false);
		        
		        ToolPropertySchema schema2 = new ToolPropertySchema();
		        schema2.setType("boolean");
		        schema2.setDescription("A boolean property");
		        schema2.setItems(false);
		        
		        ToolPropertySchema schema3 = new ToolPropertySchema();
		        schema3.setType("array");
		        schema3.setDescription("An array property");
		        schema3.setItems(true);
		        
		        assertEquals(schema1, schema2, "Property schemas with same values should be equal");
		        assertNotEquals(schema1, schema3, "Property schemas with different values should not be equal");
		        assertEquals(schema1.hashCode(), schema2.hashCode(), "Hash codes should be equal for equal property schemas");
		    }
		    
		    @Test
		    public void testVariousTypes() {
		        String[] types = {"string", "number", "integer", "boolean", "object", "array", "null"};
		        
		        for (String type : types) {
		            propertySchema.setType(type);
		            assertEquals(type, propertySchema.getType(), "Type " + type + " should be set and retrieved correctly");
		        }
		    }
		    
		    @Test
		    public void testNestedAdditionalProperties() {
		        Map<String, Object> nestedMap = new HashMap<>();
		        nestedMap.put("nestedKey", "nestedValue");
		        
		        Map<String, Object> additionalProps = new HashMap<>();
		        additionalProps.put("simpleKey", "simpleValue");
		        additionalProps.put("nestedObject", nestedMap);
		        
		        propertySchema.setAdditionalProperties(additionalProps);
		        
		        assertEquals("simpleValue", propertySchema.getAdditionalProperties().get("simpleKey"), 
		                    "Simple value should be retrieved correctly");
		        
		        @SuppressWarnings("unchecked")
		        Map<String, Object> retrievedNestedMap = 
		            (Map<String, Object>) propertySchema.getAdditionalProperties().get("nestedObject");
		        
		        assertNotNull(retrievedNestedMap, "Nested map should not be null");
		        assertEquals("nestedValue", retrievedNestedMap.get("nestedKey"), 
		                    "Nested value should be retrieved correctly");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\domain\ToolTest.java'><![CDATA[
		package io.github.vishalmysore.mcp.domain;
		
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		import java.util.Arrays;
		import java.util.HashMap;
		import java.util.Map;
		
		public class ToolTest {
		
		    private Tool tool;
		
		    @BeforeEach
		    public void setUp() {
		        tool = new Tool();
		    }
		
		    @Test
		    public void testToolInitialization() {
		        assertNotNull(tool, "Tool should be initialized successfully");
		    }
		
		    @Test
		    public void testSetAndGetName() {
		        String name = "testToolName";
		        tool.setName(name);
		        assertEquals(name, tool.getName(), "Tool name should be set and retrieved correctly");
		    }
		
		    @Test
		    public void testSetAndGetDescription() {
		        String description = "This is a test description for the tool";
		        tool.setDescription(description);
		        assertEquals(description, tool.getDescription(), "Tool description should be set and retrieved correctly");
		    }
		
		    @Test
		    public void testSetAndGetType() {
		        String type = "function";
		        tool.setType(type);
		        assertEquals(type, tool.getType(), "Tool type should be set and retrieved correctly");
		    }
		
		    @Test
		    public void testSetAndGetParameters() {
		        ToolParameters parameters = new ToolParameters();
		        parameters.setType("object");
		        
		        ToolParameter param = new ToolParameter();
		        param.setType("string");
		        param.setDescription("Parameter description");
		        
		        parameters.getProperties().put("testParam", param);
		        parameters.getRequired().add("testParam");
		        
		        tool.setParameters(parameters);
		        
		        assertNotNull(tool.getParameters(), "Tool parameters should not be null");
		        assertEquals("object", tool.getParameters().getType(), "Tool parameters type should match");
		        assertEquals(1, tool.getParameters().getProperties().size(), "Tool should have one parameter");
		        assertTrue(tool.getParameters().getProperties().containsKey("testParam"), "Tool should contain the test parameter");
		        assertEquals(1, tool.getParameters().getRequired().size(), "Tool should have one required parameter");
		        assertEquals("testParam", tool.getParameters().getRequired().get(0), "Required parameter should be testParam");
		    }
		
		    @Test
		    public void testSetAndGetInputSchema() {
		        ToolInputSchema inputSchema = new ToolInputSchema();
		        
		        ToolPropertySchema propSchema = new ToolPropertySchema();
		        propSchema.setType("string");
		        propSchema.setDescription("Property description");
		        
		        Map<String, ToolPropertySchema> properties = new HashMap<>();
		        properties.put("testProp", propSchema);
		        inputSchema.setProperties(properties);
		        inputSchema.setRequired(Arrays.asList("testProp"));
		        
		        tool.setInputSchema(inputSchema);
		        
		        assertNotNull(tool.getInputSchema(), "Tool input schema should not be null");
		        assertEquals("object", tool.getInputSchema().getType(), "Tool input schema type should be object");
		        assertEquals(1, tool.getInputSchema().getProperties().size(), "Tool input schema should have one property");
		        assertTrue(tool.getInputSchema().getProperties().containsKey("testProp"), "Tool input schema should contain testProp");
		        assertEquals(1, tool.getInputSchema().getRequired().size(), "Tool input schema should have one required property");
		        assertEquals("testProp", tool.getInputSchema().getRequired().get(0), "Required property should be testProp");
		    }
		
		    @Test
		    public void testSetAndGetAnnotations() {
		        ToolAnnotations annotations = new ToolAnnotations();
		        Map<String, Object> properties = new HashMap<>();
		        properties.put("key1", "value1");
		        properties.put("key2", 123);
		        annotations.setProperties(properties);
		        
		        tool.setAnnotations(annotations);
		        
		        assertNotNull(tool.getAnnotations(), "Tool annotations should not be null");
		        assertEquals(2, tool.getAnnotations().getProperties().size(), "Tool annotations should have two properties");
		        assertEquals("value1", tool.getAnnotations().getProperties().get("key1"), "Annotation key1 should have value1");
		        assertEquals(123, tool.getAnnotations().getProperties().get("key2"), "Annotation key2 should have value 123");
		    }
		
		    @Test
		    public void testToString() {
		        tool.setName("testTool");
		        tool.setDescription("Test description");
		        tool.setType("function");
		        
		        String toolString = tool.toString();
		        
		        assertTrue(toolString.contains("testTool"), "toString should contain the tool name");
		        assertTrue(toolString.contains("Test description"), "toString should contain the tool description");
		        assertTrue(toolString.contains("function"), "toString should contain the tool type");
		    }
		    
		    @Test
		    public void testEqualsAndHashCode() {
		        Tool tool1 = new Tool();
		        tool1.setName("tool1");
		        tool1.setDescription("desc1");
		        
		        Tool tool2 = new Tool();
		        tool2.setName("tool1");
		        tool2.setDescription("desc1");
		        
		        Tool tool3 = new Tool();
		        tool3.setName("tool3");
		        tool3.setDescription("desc3");
		        
		        assertEquals(tool1, tool2, "Tools with same properties should be equal");
		        assertNotEquals(tool1, tool3, "Tools with different properties should not be equal");
		        assertEquals(tool1.hashCode(), tool2.hashCode(), "Hash codes should be equal for equal tools");
		    }
		    
		    @Test
		    public void testNullValues() {
		        Tool tool = new Tool();
		        
		        assertNull(tool.getName(), "Name should be null initially");
		        assertNull(tool.getDescription(), "Description should be null initially");
		        assertNull(tool.getType(), "Type should be null initially");
		        assertNull(tool.getParameters(), "Parameters should be null initially");
		        assertNull(tool.getInputSchema(), "InputSchema should be null initially");
		        assertNull(tool.getAnnotations(), "Annotations should be null initially");
		    }
		}]]></file>
	<file path='src\test\java\io\github\vishalmysore\mcp\server\MCPToolsControllerTest.java'>
		package io.github.vishalmysore.mcp.server;
		
		import org.junit.jupiter.api.Test;
		
		import java.io.IOException;
		import java.io.InputStream;
		import java.util.Properties;
		
		import static org.junit.jupiter.api.Assertions.*;
		
		public class MCPToolsControllerTest {
		
		
		
		
		    // Additional tests for MCPToolsController methods can be added here
		}</file>
	<file path='src\test\java\io\github\vishalmysore\mesh\AgentCatalogTest.java'>
		package io.github.vishalmysore.mesh;
		
		import io.github.vishalmysore.a2a.client.A2AAgent;
		import io.github.vishalmysore.common.Agent;
		
		import io.github.vishalmysore.common.AgentInfo;
		import io.github.vishalmysore.mcp.client.MCPAgent;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		import static org.mockito.Mockito.*;
		import static org.junit.jupiter.api.Assertions.*;
		import java.net.URL;
		
		public class AgentCatalogTest {
		    
		    private AgentCatalog catalog;
		    
		    @Mock
		    private AgentInfo mockAgentInfo;
		    
		    @Mock
		    private MCPAgent mockMcpAgent;
		    
		    @Mock
		    private A2AAgent mockA2aAgent;
		    
		    @BeforeEach
		    public void setUp() {
		        MockitoAnnotations.openMocks(this);
		        catalog = new AgentCatalog();
		        
		        // Configure mocks
		        when(mockMcpAgent.getInfo()).thenReturn(mockAgentInfo);
		        when(mockMcpAgent.getType()).thenReturn("mcp");
		        when(mockA2aAgent.getInfo()).thenReturn(mockAgentInfo);
		        when(mockA2aAgent.getType()).thenReturn("a2a");
		    }
		    
		
		
		    
		
		
		    
		    @Test
		    public void testAddAgentDirectly() {
		        // Setup
		        when(mockMcpAgent.isConnected()).thenReturn(true);
		        
		        // Test
		        boolean result = catalog.addAgent(mockMcpAgent);
		        
		        // Verify
		        assertTrue(result);
		        assertTrue(catalog.getAgents().containsValue(mockMcpAgent));
		    }
		    
		    @Test
		    public void testAddNullAgent() {
		        assertFalse(catalog.addAgent((Agent)null));
		        assertEquals(0, catalog.getAgents().size());
		    }
		    
		    @Test
		    public void testRetrieveAgentByInfo() {
		        // Setup
		        catalog.addAgent(mockMcpAgent);
		        
		        // Test
		        Agent result = catalog.retrieveAgent(mockAgentInfo);
		        
		        // Verify
		        assertNotNull(result);
		        assertEquals(mockMcpAgent, result);
		    }
		    
		
		    
		
		    
		    @Test
		    public void testGetAgentsInfoEmpty() {
		        String result = catalog.getAgentsInfo();
		        assertEquals("", result);
		    }
		}</file>
	<file path='src\test\java\io\github\vishalmysore\mesh\AgenticMeshTest.java'>
		package io.github.vishalmysore.mesh;
		
		import io.github.vishalmysore.common.CommonClientResponse;
		import org.junit.jupiter.api.BeforeEach;
		import org.junit.jupiter.api.Test;
		import org.mockito.Mock;
		import org.mockito.MockitoAnnotations;
		
		import static org.mockito.Mockito.*;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class AgenticMeshTest {
		    
		    private AgenticMesh agenticMesh;
		    
		    @Mock
		    private AgentCatalog mockCatalog;
		    
		    @Mock
		    private CommonClientResponse mockResponse;
		    
		    @BeforeEach
		    void setUp() {
		        MockitoAnnotations.openMocks(this);
		        agenticMesh = new AgenticMesh(mockCatalog);
		    }
		    
		    @Test
		    void testPipeLineMeshWithNullPreviousResponse() {
		        // Arrange
		        String query = "test query";
		        when(mockCatalog.processQuery(query)).thenReturn(mockResponse);
		        when(mockResponse.getTextResult()).thenReturn("response text");
		        
		        // Act
		        CommonClientResponse result = agenticMesh.pipeLineMesh(query);
		        
		        // Assert
		        assertNotNull(result);
		        assertEquals(mockResponse, result);
		        verify(mockCatalog).processQuery(query);
		    }
		    
		    @Test
		    void testHubAndSpokeWithValidQuery() {
		        // Arrange
		        String query = "test hub query";
		        when(mockCatalog.processQuery(anyString())).thenReturn(mockResponse);
		        when(mockResponse.getTextResult()).thenReturn("hub response");
		        
		        // Act
		        CommonClientResponse result = agenticMesh.hubAndSpoke(query);
		        
		        // Assert
		        assertNotNull(result);
		        assertEquals(mockResponse, result);
		        verify(mockCatalog, atLeastOnce()).processQuery(anyString());
		    }
		    
		    @Test
		    void testBlackboardWithValidQuery() {
		        // Arrange
		        String query = "test blackboard query";
		        when(mockCatalog.processQuery(anyString())).thenReturn(mockResponse);
		        when(mockResponse.getTextResult()).thenReturn("blackboard response");
		        
		        // Act
		        CommonClientResponse result = agenticMesh.blackboard(query);
		        
		        // Assert
		        assertNotNull(result);
		        assertEquals(mockResponse, result);
		        verify(mockCatalog, atLeastOnce()).processQuery(anyString());
		    }
		    
		    @Test
		    void testPipeLineMeshWithNullResponse() {
		        // Arrange
		        String query = "test query";
		        when(mockCatalog.processQuery(query)).thenReturn(null);
		        
		        // Act
		        CommonClientResponse result = agenticMesh.pipeLineMesh(query);
		        
		        // Assert
		        assertNull(result);
		        verify(mockCatalog).processQuery(query);
		    }
		    
		    @Test
		    void testBlackboardWithNullInitialResponse() {
		        // Arrange
		        String query = "test query";
		        when(mockCatalog.processQuery(query)).thenReturn(null);
		        
		        // Act
		        CommonClientResponse result = agenticMesh.blackboard(query);
		        
		        // Assert
		        assertNull(result);
		        verify(mockCatalog).processQuery(query);
		    }
		    
		    @Test
		    void testHubAndSpokeWithNullResponse() {
		        // Arrange
		        String query = "test query";
		        when(mockCatalog.processQuery(query)).thenReturn(null);
		        
		        // Act
		        CommonClientResponse result = agenticMesh.hubAndSpoke(query);
		        
		        // Assert
		        assertNull(result);
		        verify(mockCatalog).processQuery(query);
		    }
		    
		    @Test
		    void testPipeLineMeshWithRecursiveCall() {
		        // Arrange
		        String query = "test recursive query";
		        when(mockCatalog.processQuery(anyString())).thenReturn(mockResponse);
		        when(mockResponse.getTextResult()).thenReturn("No"); // Simulate a "No" response to force recursion
		        
		        // Act
		        CommonClientResponse result = agenticMesh.pipeLineMesh(query);
		        
		        // Assert
		        assertNotNull(result);
		        verify(mockCatalog, atLeast(1)).processQuery(anyString());
		    }
		}</file>
	<file path='src\test\java\regression\A2AStandalone.java'>
		package regression;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.detect.ActionState;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.processor.GeminiV2ActionProcessor;
		import com.t4a.transform.GeminiV2PromptTransformer;
		import com.t4a.transform.PromptTransformer;
		import lombok.extern.java.Log;
		import regression.pojo.Customer;
		import regression.pojo.Organization;
		
		@Log
		public class A2AStandalone {
		    public static void main(String[] args) throws AIProcessingException {
		        GeminiV2ActionProcessor processor = new GeminiV2ActionProcessor();
		        ActionCallback callback = new ActionCallback() {
		
		            @Override
		            public void setContext(Object obj) {
		
		            }
		
		            @Override
		            public Object getContext() {
		                return null;
		            }
		
		            @Override
		            public String getType() {
		                return "";
		            }
		
		            @Override
		            public String setType(String type) {
		                return "";
		            }
		
		            @Override
		            public void sendtStatus(String status, ActionState state) {
		
		            }
		
		
		
		        };
		
		        processor.processSingleAction("what does vishal like to eat",callback);
		        String promptText = "Shahrukh Khan works for MovieHits inc and his salary is $ 100  he joined Toronto on Labor day, his tasks are acting and dancing. He also works out of Montreal and Bombay.Hrithik roshan is another employee of same company based in Chennai his taks are jumping and Gym he joined on Indian Independce Day";
		        PromptTransformer promptTransformer = new GeminiV2PromptTransformer();
		        log.info(promptTransformer.transformIntoPojo(promptText, Organization.class).toString());
		        promptText = "Customer has a problem with his Computer create customer support ticket for him";
		        log.info(promptTransformer.transformIntoPojo(promptText, Customer.class).toString());
		
		        log.info((String) processor.processSingleAction(promptText));
		    }
		}</file>
	<file path='src\test\java\regression\action\ComplexAction.java'>
		package regression.action;
		
		import com.t4a.annotations.Action;
		import com.t4a.annotations.Agent;
		import regression.pojo.Customer;
		
		@Agent(groupName = "customer support", groupDescription = "actions related to customer support")
		public class ComplexAction {
		
		    public static int COUNTER = 0;
		    public ComplexAction() {
		        COUNTER++;
		    }
		    @Action(description = "Customer has problem create ticket for him")
		    public String computerRepair(Customer customer) {
		        return customer.toString();
		    }
		}</file>
	<file path='src\test\java\regression\action\SimpleAction.java'>
		package regression.action;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.detect.ActionState;
		
		
		//@Agent(groupName = "food preference", groupDescription = "actions related to food preference")
		public class SimpleAction  {
		
		    /**
		     * This will be used for streaming the status of the action
		     * it will be populated if its part of the streaming request else not
		     */
		    private ActionCallback actionCallback;
		
		  //  @Action( description = "what is the food preference of this person")
		    public String whatFoodDoesThisPersonLike(String name) {
		        if(actionCallback!= null) {
		            actionCallback.sendtStatus("success", ActionState.WORKING);
		        }
		        if("vishal".equalsIgnoreCase(name)) {
		            if(actionCallback!= null) {
		                actionCallback.sendtStatus("Paneer butter masala", ActionState.WORKING);
		            }
		            return "Paneer Butter Masala";
		        }
		        else if ("vinod".equalsIgnoreCase(name)) {
		            if(actionCallback!= null) {
		                actionCallback.sendtStatus("aloo kofta", ActionState.WORKING);
		            }
		            return "aloo kofta";
		        }else {
		            if(actionCallback!= null) {
		                actionCallback.sendtStatus("Raw Onions", ActionState.WORKING);
		            }
		            return "something yummy";
		        }
		    }
		
		}</file>
	<file path='src\test\java\regression\action\SimpleActionTest.java'>
		package regression.action;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class SimpleActionTest {
		
		    @Test
		    public void testWhatFoodDoesThisPersonLike() {
		        SimpleAction action = new SimpleAction();
		
		        // Test for Vishal
		        String result = action.whatFoodDoesThisPersonLike("vishal");
		        assertEquals("Paneer Butter Masala", result);
		
		        // Test for Vinod
		        result = action.whatFoodDoesThisPersonLike("vinod");
		        assertEquals("aloo kofta", result);
		
		        // Test for unknown name
		        result = action.whatFoodDoesThisPersonLike("unknown");
		        assertEquals("something yummy", result);
		    }
		}</file>
	<file path='src\test\java\regression\action\TicketBookingAction.java'>
		package regression.action;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.detect.ActionState;
		
		//@Agent(groupName = "ticket booking", groupDescription = "actions related to ticket booking")
		public class TicketBookingAction {
		    private ActionCallback actionCallback;
		   //  @Action(description = "book a ticket")
		     public String bookTicket(String name, String source, String destination, String date) {
		         actionCallback.sendtStatus("booking your ticket from "+source+" to "+destination+" for "+date.toString(), ActionState.WORKING);
		         //do all the ticket booking logic here
		         // call you api etc
		         actionCallback.sendtStatus("Your Ticket has been booked", ActionState.COMPLETED);
		         return "Ticket booked for " + name + " from " + source + " to " + destination;
		     }
		
		    // @Action(description = "cancel a ticket")
		     public String cancelTicket(String name, String ticketId) {
		         if(actionCallback!= null) {
		             actionCallback.sendtStatus("cancelling your ticket", ActionState.WORKING);
		         }
		         return "Ticket with ID " + ticketId + " cancelled for " + name;
		     }
		}</file>
	<file path='src\test\java\regression\AgentCatalogTest.java'>
		package regression;
		
		import com.t4a.JsonUtils;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.transform.OpenAIPromptTransformer;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.a2a.domain.AgentCard;
		import io.github.vishalmysore.common.Agent;
		import io.github.vishalmysore.common.AgentIdentity;
		import io.github.vishalmysore.mcp.client.MCPAgent;
		import io.github.vishalmysore.mesh.AgentCatalog;
		import lombok.extern.java.Log;
		
		@Log
		public class AgentCatalogTest {
		    public static void main(String[] args) throws AIProcessingException {
		        AgentCatalog agentCatalog = new AgentCatalog();
		        Agent agent = agentCatalog.addAgent("https://vishalmysore-a2amcpspring.hf.space/");
		        JsonUtils jsonUtils = new JsonUtils();
		      //  MCPAgent mcpAgent = new MCPAgent();
		    //    mcpAgent.connect("http://localhost:7860/");
		      //  agentCatalog.addAgent(mcpAgent);
		
		     //   log.info(agentCatalog.getAgentsInfo());
		       // PromptTransformer promptTransformer = new OpenAIPromptTransformer();
		       // String identiy = promptTransformer.transformIntoJson("{agentUniqueIDTobeUsedToIdentifyTheAgent:''}"," this is user prompt { what is vishals favorite food }  I am trying to find which agent can handle it from this info {"+agentCatalog.getAgentsInfo()+"}");
		     //   log.info("Agent Identity: " + identiy);
		        //agent = agentCatalog.retrieveAgentByJson(jsonUtils.extractJson(identiy));
		        //log.info("Retrieved Agent: " + agent.getType());
		
		        //identiy = promptTransformer.transformIntoJson("{agentUniqueIDTobeUsedToIdentifyTheAgent:''}"," this is user prompt { i need to read harry potter book }  I am trying to find which agent can handle it from this info {"+agentCatalog.getAgentsInfo()+"}");
		      //  log.info("Agent Identity: " + identiy);
		      //  agent = agentCatalog.retrieveAgentByJson(jsonUtils.extractJson(identiy));
		     //   log.info("Retrieved Agent: " + agent.getType());
		
		        log.info(agentCatalog.processQuery("what is vishal favorite food:").getTextResult());
		
		        log.info(agentCatalog.processQuery("get me the list of the books").getTextResult());
		
		    }
		}</file>
	<file path='src\test\java\regression\AgenticMeshTest.java'>
		package regression;
		
		import com.t4a.JsonUtils;
		import io.github.vishalmysore.common.Agent;
		import io.github.vishalmysore.mcp.client.MCPAgent;
		import io.github.vishalmysore.mesh.AgentCatalog;
		import io.github.vishalmysore.mesh.AgenticMesh;
		
		public class AgenticMeshTest {
		    public static void main(String[] args) {
		        AgentCatalog agentCatalog = new AgentCatalog();
		        Agent agent = agentCatalog.addAgent("https://vishalmysore-a2amcpspring.hf.space/");
		        MCPAgent mcpAgent = new MCPAgent();
		        mcpAgent.connect("http://localhost:7860/");
		        agentCatalog.addAgent(mcpAgent);
		        AgenticMesh agenticMesh = new AgenticMesh(agentCatalog);
		        String reponse = agenticMesh.pipeLineMesh("what is vishal favorite food:").getTextResult();
		        System.out.println("Response: " + reponse);
		        reponse = agenticMesh.pipeLineMesh("what is vishal favorite food and get him a list of books to read").getTextResult();
		        System.out.println("Response: " + reponse);
		    }
		}</file>
	<file path='src\test\java\regression\client\A2ATaskClientExampleTest.java'>
		package regression.client;
		
		import com.t4a.predict.PredictionLoader;
		import io.github.vishalmysore.a2a.client.LocalA2ATaskClient;
		import io.github.vishalmysore.a2a.domain.JsonRpcRequest;
		import io.github.vishalmysore.a2a.domain.Task;
		import io.github.vishalmysore.common.server.JsonRpcController;
		import io.github.vishalmysore.mcp.domain.CallToolRequest;
		import org.junit.jupiter.api.BeforeAll;
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class A2ATaskClientExampleTest {
		
		    @BeforeAll
		    public static void initLoader() {
		        System.out.println("Waiting for other tests to complete...");
		        try {
		            Thread.sleep(5000); // ⏱️ 5 seconds
		        } catch (InterruptedException e) {
		            throw new RuntimeException(e);
		        }
		        PredictionLoader.getInstance();  // trigger once per test class
		    }
		    @Test
		    public void testSendTask() {
		        // Mock or simulate the behavior of sendTask
		        // Example: Assert that the task is sent successfully
		        LocalA2ATaskClient client = new LocalA2ATaskClient();
		        Task result = client.sendTask("what food vishal likes");
		        assertNotNull(result);
		        assertTrue(true, "Task sent successfully");
		    }
		
		    @Test
		    public void testMCPClient() {
		        try {
		            String toolsCall = "{\"method\":\"tools/call\",\"params\":{\"name\":\"computerRepair\",\"arguments\":{\"provideAllValuesInPlainEnglish\":\"fix my computer, my name is vishal mysore and comptuer is very slow i can think faster that that since I am chacha choudhry\"}},\"jsonrpc\":\"2.0\",\"id\":17}";
		            JsonRpcRequest request = JsonRpcRequest.fromString(toolsCall);
		
		            JsonRpcController controller = new JsonRpcController();
		            Object response = controller.handleRpc(request);
		            assertNotNull(response);
		        } catch (Exception e) {
		            System.out.println("AI not responding: " + e.getMessage());
		        }
		    }
		
		@Test
		    public void testMCPClientLifeCycle() {
		        String[] jsonRequests = {
		                "{\"method\":\"initialize\",\"params\":{\"protocolVersion\":\"2024-11-05\",\"capabilities\":{},\"clientInfo\":{\"name\":\"claude-ai\",\"version\":\"0.1.0\"}},\"jsonrpc\":\"2.0\",\"id\":0}",
		                "{\"method\":\"tools/list\",\"params\":{},\"jsonrpc\":\"2.0\",\"id\":1}",
		                "{\"method\":\"resources/list\",\"params\":{},\"jsonrpc\":\"2.0\",\"id\":3}",
		                "{\"method\":\"notifications/initialized\",\"jsonrpc\":\"2.0\"}"
		        };
		
		        JsonRpcController controller = new JsonRpcController();
		
		        assertDoesNotThrow(() -> {
		            for (String jsonStr : jsonRequests) {
		                JsonRpcRequest request = JsonRpcRequest.fromString(jsonStr);
		                Object response = controller.handleRpc(request);
		                assertNotNull(response);
		            }
		        });
		    }
		
		    @Test
		    public void testBrowseWebTool() {
		        String toolsCall = "{\"method\":\"tools/call\",\"params\":{\"name\":\"browseWebAndPerformAction\",\"arguments\":{\"provideAllValuesInPlainEnglish\":\"Go to Google.com, search for \\\"a2ajava\\\", wait for results to load, click on the first search result link, wait for the page to load completely, then take a screenshot of the page\"}}}";
		        CallToolRequest request = CallToolRequest.fromString(toolsCall);
		        assertNotNull(request);
		        assertEquals("tools/call", request.getMethod());
		        assertEquals("browseWebAndPerformAction", request.getParams().getName());
		    }
		
		    @Test
		    public void testGetTask() {
		        // Mock or simulate the behavior of getTask
		        // Example: Assert that the task is retrieved successfully
		        assertTrue(true, "Task retrieved successfully");
		    }
		}</file>
	<file path='src\test\java\regression\client\TaskClientExample.java'><![CDATA[
		package regression.client;
		
		
		import com.fasterxml.jackson.core.JsonProcessingException;
		import com.fasterxml.jackson.databind.ObjectMapper;
		import io.github.vishalmysore.a2a.domain.Message;
		import io.github.vishalmysore.a2a.domain.Task;
		import io.github.vishalmysore.a2a.domain.TaskSendParams;
		import io.github.vishalmysore.a2a.domain.TextPart;
		import lombok.extern.java.Log;
		import org.springframework.http.*;
		import org.springframework.web.client.HttpClientErrorException;
		import org.springframework.web.client.RestTemplate;
		import org.springframework.web.util.UriComponentsBuilder;
		
		import java.util.Collections;
		import java.util.UUID;
		
		@Log
		public class TaskClientExample {
		
		    private static final String BASE_URL = "http://localhost:8080"; // Replace with your server's URL
		    private static final RestTemplate restTemplate = new RestTemplate();
		    private static final ObjectMapper objectMapper = new ObjectMapper();
		
		    public static void main(String[] args) throws JsonProcessingException {
		        // Send a task
		        String taskId = UUID.randomUUID().toString();
		        Message message = new Message();
		        message.setRole("user");
		        TextPart textPart = new TextPart();
		        textPart.setText("Book a flight from New York to Los Angeles on 2024-05-10");
		        message.setParts(Collections.singletonList(textPart));
		
		        TaskSendParams sendParams = new TaskSendParams();
		        sendParams.setId(taskId);
		        sendParams.setMessage(message);
		
		        Task sentTask = sendTask(sendParams);
		        log.info("Sent Task: " + objectMapper.writeValueAsString(sentTask));
		
		        // Get the task
		        Task retrievedTask = getTask(taskId, 0);
		        log.info("Retrieved Task: " + objectMapper.writeValueAsString(retrievedTask));
		
		        // Send another task to check the input required
		        String taskId2 = UUID.randomUUID().toString();
		        Message message2 = new Message();
		        message2.setRole("user");
		        TextPart textPart2 = new TextPart();
		        textPart2.setText("Change the date of the ticket");
		        message2.setParts(Collections.singletonList(textPart2));
		
		        TaskSendParams sendParams2 = new TaskSendParams();
		        sendParams2.setId(taskId2);
		        sendParams2.setMessage(message2);
		
		        Task sentTask2 = sendTask(sendParams2);
		        log.info("Sent Task: " + objectMapper.writeValueAsString(sentTask2));
		
		        Task retrievedTask2 = getTask(taskId2, 0);
		        log.info("Retrieved Task: " + objectMapper.writeValueAsString(retrievedTask2));
		
		        //send the new date
		        Message newMessage = new Message();
		        newMessage.setRole("user");
		        TextPart newTextPart = new TextPart();
		        newTextPart.setText("2024-05-12");
		        newMessage.setParts(Collections.singletonList(newTextPart));
		        TaskSendParams updateParams = new TaskSendParams();
		        updateParams.setId(taskId2);
		        updateParams.setMessage(newMessage);
		        Task updatedTask = sendTask(updateParams);
		        log.info("Updated task " + objectMapper.writeValueAsString(updatedTask));
		
		        //get the task
		        Task getUpdatedTask = getTask(taskId2, 0);
		        log.info("Get updated Task: " + objectMapper.writeValueAsString(getUpdatedTask));
		
		    }
		
		    public static Task sendTask(TaskSendParams sendParams) throws JsonProcessingException {
		        String url = BASE_URL + "/tasks/send";
		        HttpHeaders headers = new HttpHeaders();
		        headers.setContentType(MediaType.APPLICATION_JSON);
		        String json = objectMapper.writeValueAsString(sendParams);
		        HttpEntity<String> requestEntity = new HttpEntity<>(json, headers);
		        try {
		            ResponseEntity<Task> responseEntity = restTemplate.exchange(url, HttpMethod.POST, requestEntity, Task.class);
		            return responseEntity.getBody();
		        } catch (HttpClientErrorException e) {
		            log.severe("Error sending task: " + e.getResponseBodyAsString());
		            throw e; // Re-throw the exception to be handled by the caller
		        }
		    }
		
		    public static Task getTask(String taskId, int historyLength) throws JsonProcessingException {
		        String url = BASE_URL + "/tasks/get";
		        UriComponentsBuilder builder = UriComponentsBuilder.fromHttpUrl(url)
		                .queryParam("id", taskId)
		                .queryParam("historyLength", historyLength);
		        try {
		            ResponseEntity<Task> responseEntity = restTemplate.exchange(
		                    builder.toUriString(),
		                    HttpMethod.GET,
		                    null, // No body for GET request
		                    Task.class
		            );
		            return responseEntity.getBody();
		        } catch (HttpClientErrorException e) {
		            log.severe("Error getting task: " + e.getResponseBodyAsString());
		            throw e; // Re-throw the exception to be handled by the caller
		        }
		    }
		}]]></file>
	<file path='src\test\java\regression\ConnectToServer.java'>
		package regression;
		
		import io.github.vishalmysore.a2a.client.A2AAgent;
		import io.github.vishalmysore.a2a.client.A2ATaskClient;
		import io.github.vishalmysore.a2a.domain.AgentCard;
		import io.github.vishalmysore.common.AgentInfo;
		import io.github.vishalmysore.mcp.client.MCPAgent;
		import io.github.vishalmysore.mcp.domain.CallToolRequest;
		import io.github.vishalmysore.mcp.domain.CallToolResult;
		import io.github.vishalmysore.mcp.domain.Content;
		import lombok.extern.java.Log;
		
		import java.util.List;
		
		@Log
		public class ConnectToServer {
		    public static void main(String[] args) {
		      //  A2AAgent a2aagent = new A2AAgent();
		         //a2aagent.connect("https://vishalmysore-a2amcpspring.hf.space/");
		       // AgentInfo card = a2aagent.getInfo();
		       // A2ATaskClient taskClient = new A2ATaskClient("http://localhost:7860");
		       // Object task =taskClient.sendTask("vishal is coming home what should i cook");
		       // Object task = a2aagent.remoteMethodCall("vishal is coming home what should i cook");
		       //log.info("Task result: " + task);
		    //   a2aagent.connect("http://localhost:7860/");
		     //   Object task = a2aagent.remoteMethodCall("get me list of car types");
		      //  log.info("Task result: " + task);
		
		     //   log.info("Connected to server: " + card);
		
		        MCPAgent mcpAgent = new MCPAgent();
		        mcpAgent.connect("https://vishalmysore-a2amcpspring.hf.space/");
		        AgentInfo mcpCard = mcpAgent.getInfo();
		        log.info("Connected to MCP server: " + mcpCard);
		        CallToolResult result = (CallToolResult) mcpAgent.remoteMethodCall( "vishal is coming home what should i cook");
		        log.info("Tool call result: " + result);
		     /*   CallToolRequest request = new CallToolRequest();
		        String json = "{\n" +
		                "    \"method\": \"tools/call\",\n" +
		                "    \"params\": {\n" +
		                "        \"name\": \"whatThisPersonFavFood\",\n" +
		                "        \"arguments\": {\n" +
		                "            \"provideAllValuesInPlainEnglish\": \"vishal is coming home what should i cook\"\n" +
		                "        }\n" +
		                "    },\n" +
		                "    \"jsonrpc\": \"2.0\",\n" +
		                "    \"id\": 17\n" +
		                "}";
		        String toolsCall = "{\"method\":\"tools/call\",\"params\":{\"name\":\"browseWebAndPerformAction\",\"arguments\":{\"provideAllValuesInPlainEnglish\":\"Go to Google.com, search for \\\"a2ajava\\\", wait for results to load, click on the first search result link, wait for the page to load completely, then take a screenshot of the page\"}}}";
		        request = CallToolRequest.fromString(json);
		
		        CallToolResult result =mcpAgent.callTool(request);
		        log.info("Tool call result: " + result);
		
		        result = (CallToolResult) mcpAgent.remoteMethodCall("whatThisPersonFavFood", "vishal is coming home what should i cook");
		        log.info("Tool call result: " + result);
		        */
		
		    }
		}</file>
	<file path='src\test\java\regression\pojo\Activity.java'>
		package regression.pojo;
		
		import lombok.Getter;
		import lombok.NoArgsConstructor;
		import lombok.Setter;
		import lombok.ToString;
		
		@Getter
		@Setter
		@NoArgsConstructor
		@ToString
		public class Activity {
		    String dayOfTheWeek;
		    String activityName;
		}</file>
	<file path='src\test\java\regression\pojo\ActivityTest.java'>
		package regression.pojo;
		
		import org.junit.jupiter.api.Test;
		import static org.junit.jupiter.api.Assertions.*;
		
		public class ActivityTest {
		
		    @Test
		    public void testActivityGettersAndSetters() {
		        Activity activity = new Activity();
		        activity.setDayOfTheWeek("Monday");
		        activity.setActivityName("Yoga");
		
		        assertEquals("Monday", activity.getDayOfTheWeek());
		        assertEquals("Yoga", activity.getActivityName());
		    }
		
		    @Test
		    public void testToString() {
		        Activity activity = new Activity();
		        activity.setDayOfTheWeek("Monday");
		        activity.setActivityName("Yoga");
		
		        String expected = "Activity(dayOfTheWeek=Monday, activityName=Yoga)";
		        assertEquals(expected, activity.toString());
		    }
		}</file>
	<file path='src\test\java\regression\pojo\AutoRepairScreen.java'>
		package regression.pojo;
		
		import lombok.*;
		
		@Getter
		@Setter
		@ToString
		@NoArgsConstructor
		@AllArgsConstructor
		public class AutoRepairScreen {
		    double fullInspectionValue;
		    double tireRotationValue;
		    double oilChangeValue;
		    Integer phoneNumber;
		    String email;
		    String[] customerReviews;
		
		}</file>
	<file path='src\test\java\regression\pojo\Customer.java'>
		package regression.pojo;
		
		import com.t4a.annotations.Prompt;
		import lombok.*;
		
		import java.util.Date;
		
		@NoArgsConstructor
		@AllArgsConstructor
		@Getter
		@Setter
		@ToString
		@EqualsAndHashCode
		public class Customer {
		    private String firstName;
		    private String lastName;
		    @Prompt(describe = "convert this to Hindi")
		    private String reasonForCalling;
		    @Prompt(ignore = true)
		    private String location;
		    @Prompt(dateFormat = "yyyy-MM-dd" ,describe = "if you dont find date provide todays date in fieldValue")
		    private Date dateJoined;
		}</file>
	<file path='src\test\java\regression\pojo\Dictionary.java'><![CDATA[
		package regression.pojo;
		
		import com.t4a.annotations.MapKeyType;
		import com.t4a.annotations.MapValueType;
		import lombok.AllArgsConstructor;
		import lombok.Getter;
		import lombok.NoArgsConstructor;
		import lombok.Setter;
		
		import java.util.Map;
		
		@Setter
		@Getter
		@NoArgsConstructor
		@AllArgsConstructor
		public class Dictionary {
		    String nameOfDictionary;
		    @MapValueType(String.class)
		    @MapKeyType(String.class)
		    Map<String,String> wordMeanings;
		    String locations[];
		}]]></file>
	<file path='src\test\java\regression\pojo\Employee.java'>
		package regression.pojo;
		
		import com.t4a.annotations.Prompt;
		import lombok.*;
		
		import java.util.Date;
		
		@Getter
		@Setter
		@NoArgsConstructor
		@AllArgsConstructor
		@ToString
		public class Employee {
		    private String name;
		    @Prompt(ignore = true)
		    private int id;
		    private String department;
		    private double salary;
		    private String location;
		    @Prompt(dateFormat = "ddMMyyyy" ,describe = "convert to actual date")
		    private Date dateJoined;
		    private String[] tasks;
		}</file>
	<file path='src\test\java\regression\pojo\MyDiary.java'>
		package regression.pojo;
		
		import com.t4a.annotations.Prompt;
		
		import lombok.Getter;
		import lombok.NoArgsConstructor;
		import lombok.Setter;
		import lombok.ToString;
		
		import java.util.Date;
		
		@Getter
		@Setter
		@NoArgsConstructor
		@ToString
		public class MyDiary {
		    @Prompt(dateFormat = "ddMMyyyy")
		    Date[] allTheDatesOfAppointment;
		    String[] friendsNames;
		    Customer customer;
		    Employee employee;
		}</file>
	<file path='src\test\java\regression\pojo\MyGymSchedule.java'><![CDATA[
		package regression.pojo;
		
		import com.t4a.annotations.ListType;
		import lombok.Getter;
		import lombok.NoArgsConstructor;
		import lombok.Setter;
		import lombok.ToString;
		
		import java.util.List;
		
		@Getter
		@Setter
		@NoArgsConstructor
		@ToString
		public class MyGymSchedule {
		  @ListType(Activity.class)
		  List<Activity> myWeeklyActivity;
		
		}]]></file>
	<file path='src\test\java\regression\pojo\Organization.java'><![CDATA[
		package regression.pojo;
		
		import com.t4a.annotations.ListType;
		
		import lombok.*;
		
		import java.util.List;
		
		@Getter
		@Setter
		@NoArgsConstructor
		@AllArgsConstructor
		@ToString
		public class Organization {
		    String name;
		    @ListType(Employee.class)
		    List<Employee> em;
		    @ListType(String.class)
		    List<String> locations;
		    Customer[] customers;
		}]]></file>
	<file path='src\test\java\regression\server\TicketAgentCardController.java'><![CDATA[
		package regression.server;
		
		import com.t4a.transform.GeminiV2PromptTransformer;
		import com.t4a.transform.PromptTransformer;
		import io.github.vishalmysore.a2a.domain.*;
		import io.github.vishalmysore.a2a.server.A2AAgentCardController;
		import lombok.extern.java.Log;
		import org.springframework.http.ResponseEntity;
		import org.springframework.stereotype.Service;
		
		import java.util.List;
		
		/**
		 * This will be used to provide the agent card for the agent
		 * The agent card is a JSON object that describes the capabilities of the agent
		 * and how to interact with it.
		 * RENAME THE /ticketagent.json to your agent.json before you runt the applicaiton
		 */
		//@RestController
		//@RequestMapping("/.well-known")
		@Service
		@Log
		public class TicketAgentCardController implements A2AAgentCardController {
		    //@GetMapping(value = "/ticketagent.json", produces = MediaType.APPLICATION_JSON_VALUE)
		
		    private GeminiV2PromptTransformer geminiV2PromptTransformer = new GeminiV2PromptTransformer();
		
		    public PromptTransformer getPromptTransformer() {
		        return geminiV2PromptTransformer;
		    }
		
		    public ResponseEntity<AgentCard> getAgentCard() {
		        AgentCard agentCard = new AgentCard();
		        agentCard.setName("TicketQueen : Ticket Booking Agent");
		        agentCard.setDescription("book your airlines ticket, hotel ticket, and train ticket , also find out the preference of food of a person, it will also provide details on your existing booking or help in cancelling it or provideing realt time update ");
		        agentCard.setUrl("http://localhost:8080"); //  Replace with actual URL
		        agentCard.setProvider(new Provider("Ticket Corp", "https://github.com/vishalmysore/choturobo"));
		        agentCard.setVersion("1.0.0");
		        agentCard.setDocumentationUrl("https://github.com/vishalmysore/Tools4AI");  // Replace
		        agentCard.setCapabilities(new Capabilities(false, false, false));
		        agentCard.setAuthentication(new Authentication(new String[]{"Bearer"}));
		        agentCard.setDefaultInputModes(new String[]{"text/plain"});
		        agentCard.setDefaultOutputModes(new String[]{"application/json"});
		
		        Skill foodPreferenceSkill = new Skill();
		        foodPreferenceSkill.setId("food-preference");
		        foodPreferenceSkill.setName("Food Preference");
		        foodPreferenceSkill.setDescription("Provide food preference of a person");
		        foodPreferenceSkill.setTags(new String[]{"food", "food preference", "favorite food"});
		        foodPreferenceSkill.setExamples(new String[]{"what does the james like to eat?", "what is the food preference of this person?"});
		        foodPreferenceSkill.setInputModes(new String[]{"application/json"}); //override
		        foodPreferenceSkill.setOutputModes(new String[]{"application/json"});
		
		        Skill bookTicketSkill = new Skill();
		        bookTicketSkill.setId("book-ticket");
		        bookTicketSkill.setName("Book Ticket");
		        bookTicketSkill.setDescription("Book an airline ticket");
		        bookTicketSkill.setTags(new String[]{"travel", "airline", "booking"});
		        bookTicketSkill.setExamples(new String[]{"Book a flight from New York to Los Angeles on 2024-05-10"});
		        bookTicketSkill.setInputModes(new String[]{"application/json"}); //override
		        bookTicketSkill.setOutputModes(new String[]{"application/json"});
		
		        Skill[] sk = new Skill[2];
		        sk[0] = foodPreferenceSkill;
		        sk[1] = bookTicketSkill;
		
		        agentCard.setSkills(List.of(sk));
		
		        return ResponseEntity.ok(agentCard);
		    }
		}]]></file>
	<file path='src\test\java\regression\server\TicketTaskController.java'><![CDATA[
		package regression.server;
		
		import com.t4a.detect.ActionCallback;
		import com.t4a.processor.AIProcessor;
		import com.t4a.processor.GeminiV2ActionProcessor;
		import io.github.vishalmysore.a2a.domain.*;
		import io.github.vishalmysore.a2a.server.A2ATaskController;
		import lombok.extern.java.Log;
		import org.springframework.http.HttpStatus;
		import org.springframework.http.MediaType;
		import org.springframework.http.ResponseEntity;
		import org.springframework.web.bind.annotation.*;
		import org.springframework.web.server.ResponseStatusException;
		import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;
		
		import java.io.IOException;
		import java.util.*;
		import java.util.concurrent.ConcurrentHashMap;
		import java.util.concurrent.ExecutorService;
		import java.util.concurrent.Executors;
		
		/**
		 * This class handles ticket booking tasks and provides endpoints for sending,
		 * retrieving, and canceling tasks. It also supports Server-Sent Events (SSE) for
		 * real-time updates. As you can see from name it is a ticket booking task handler only
		 * But if you get a prompt for other tasks it wont be able to handle such tasks need to be
		 * handled by DyanamicTaskController which will dyanamilly call the action/task based on nlp
		 */
		@RestController
		@RequestMapping("/tasks")
		@Log
		public class TicketTaskController implements A2ATaskController {
		
		    private final Map<String, Task> tasks = new ConcurrentHashMap<>();
		    private final Map<String, SseEmitter> emitters = new ConcurrentHashMap<>();
		    private final ExecutorService nonBlockingService = Executors.newCachedThreadPool();
		
		    // Helper method to send SSE events
		    private void sendSseEvent(String taskId, Object event) {
		        SseEmitter emitter = emitters.get(taskId);
		        if (emitter != null) {
		            try {
		                emitter.send(SseEmitter.event().name("message").data(event));
		            } catch (IOException e) {
		                // Handle client disconnection or error
		                emitters.remove(taskId);
		                emitter.completeWithError(e);
		                log.severe("Error sending SSE event: " + e.getMessage()); // Log
		            }        }
		    }
		
		
		
		    @PostMapping("/send")
		    public SendTaskResponse sendTask(@RequestBody TaskSendParams taskSendParams, ActionCallback callback, boolean isAsync) {
		        String taskId = taskSendParams.getId();
		        Task task;
		        if (tasks.containsKey(taskId)) {
		            task = tasks.get(taskId);
		            // In a real implementation, you would check the task's status
		            // and determine if a new message can be added.  For this example,
		            // we'll just add the message.
		            List<Message> history = task.getHistory();
		            if (history == null) {
		                history = new ArrayList<>();
		            }
		            List<Message> mutableHistory = new ArrayList<>(history);
		            mutableHistory.add(taskSendParams.getMessage());
		            task.setHistory(mutableHistory);
		
		        } else {
		            //creates a new task
		            task = new Task();
		            task.setId(taskId);
		            String sessionId = taskSendParams.getSessionId();
		            if (sessionId == null || sessionId.isEmpty()) {
		                sessionId = UUID.randomUUID().toString();
		            }
		            task.setSessionId(sessionId);
		            TaskStatus taskStatus = new TaskStatus();
		            Message taskMessage = new Message();
		            taskMessage.setRole("agent");
		            TextPart textPart = new TextPart();
		            textPart.setType("text");
		            textPart.setText("Your task has been submitted " + taskId);
		          //  taskMessage.setParts(List.of(textPart));
		            List<Part> parts = new ArrayList<>(); // Create mutable list
		            parts.add(textPart);
		            taskMessage.setParts(parts);
		            taskStatus.setMessage(taskMessage);
		            taskStatus.setState(TaskState.SUBMITTED);
		            task.setStatus(taskStatus); // Initial status
		            task.setHistory(List.of(taskSendParams.getMessage())); //adds the first message
		            tasks.put(taskId, task);
		        }
		
		        // Simulate ticket booking (long-running)
		        nonBlockingService.execute(() -> {
		            try {
		                // Simulate processing time
		                Thread.sleep(3000);
		                TextPart part1 = (TextPart) taskSendParams.getMessage().getParts().get(0);
		                //check for input required.
		                if (part1.getText().toLowerCase().contains("change")) {
		                    TaskStatus inputRequiredStatus = new TaskStatus("input-required");
		                    Message agentMessage = new Message();
		                    agentMessage.setRole("agent");
		                    TextPart textPart = new TextPart();
		                    textPart.setType("text");
		                    textPart.setText("Please provide the new date for your ticket");
		                    agentMessage.setParts(List.of(textPart));
		                    inputRequiredStatus.setMessage(agentMessage);
		                    task.setStatus(inputRequiredStatus);
		                    tasks.put(taskId, task);
		                    sendSseEvent(taskId, new TaskStatusUpdateEvent(taskId, inputRequiredStatus, false));
		                }
		                else {
		                    TaskStatus workingStatus = new TaskStatus("working on it");
		                    Message agentWorkingMessage = new Message();
		                    agentWorkingMessage.setRole("agent");
		                    TextPart workingTextPart = new TextPart();
		                    workingTextPart.setType("text");
		                    workingTextPart.setText("Booking your ticket...");
		                    workingStatus.setMessage(agentWorkingMessage);
		                    task.setStatus(workingStatus);
		                    tasks.put(taskId, task);
		                    sendSseEvent(taskId, new TaskStatusUpdateEvent(taskId, workingStatus, false));
		                    Thread.sleep(2000);  // Simulate booking process
		
		                    //create a success status
		                    TaskStatus completedStatus = new TaskStatus("completed");
		                    Message agentMessage = new Message();
		                    agentMessage.setRole("agent");
		                    TextPart textPart = new TextPart();
		                    textPart.setType("text");
		                    textPart.setText("Ticket booked successfully! Confirmation number: " + UUID.randomUUID());
		                    agentMessage.setParts(List.of(textPart));
		                    completedStatus.setMessage(agentMessage);
		
		                    // Create an artifact.
		                    Artifact artifact = new Artifact();
		                    artifact.setName("Ticket Confirmation");
		                    artifact.setDescription("Your airline ticket confirmation");
		                    TextPart artifactTextPart = new TextPart();
		                    artifactTextPart.setType("text");
		                    artifactTextPart.setText("Your ticket is confirmed.  Details will be sent to your email.");
		                    artifact.setParts(List.of(artifactTextPart));
		                    artifact.setIndex(0);
		                    artifact.setAppend(false);
		                    artifact.setLastChunk(true);
		
		                    task.setArtifacts(List.of(artifact));
		                    task.setStatus(completedStatus);
		                    tasks.put(taskId, task);
		                    sendSseEvent(taskId, new TaskStatusUpdateEvent(taskId, completedStatus, true)); //send final
		                    sendSseEvent(taskId, new TaskArtifactUpdateEvent(taskId, artifact));
		
		                    // Complete the SSE emitter if it exists
		                    SseEmitter emitter = emitters.get(taskId);
		                    if (emitter != null) {
		                        emitter.complete();
		                        emitters.remove(taskId);
		                    }
		                }
		
		
		            } catch (InterruptedException e) {
		                Thread.currentThread().interrupt(); // Restore the interrupted status
		                TaskStatus failedStatus = new TaskStatus("failed");
		                Message agentErrorMessage = new Message();
		                agentErrorMessage.setRole("agent");
		                TextPart errorPart = new TextPart();
		                errorPart.setType("text");
		                errorPart.setText("Ticket booking failed: " + e.getMessage());
		                failedStatus.setMessage(agentErrorMessage);
		                task.setStatus(failedStatus);
		                tasks.put(taskId, task);
		                sendSseEvent(taskId, new TaskStatusUpdateEvent(taskId, failedStatus, true)); //send final
		                SseEmitter emitter = emitters.get(taskId);
		                if (emitter != null) {
		                    emitter.completeWithError(e);
		                    emitters.remove(taskId);
		                }
		            }
		        });
		        SendTaskResponse response = new SendTaskResponse();
		        response.setId(taskId);
		        response.setResult(task);
		        return response;
		    }
		
		    @Override
		    public AIProcessor getBaseProcessor() {
		        return new GeminiV2ActionProcessor();
		    }
		
		
		    @GetMapping("/get")
		    public ResponseEntity<Task> getTask(@RequestParam String id, @RequestParam(defaultValue = "0") int historyLength) {
		        Task task = tasks.get(id);
		        if (task == null) {
		            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Task not found");
		        }
		        //basic get
		        if (historyLength == 0) {
		            return ResponseEntity.ok(task);
		        }
		        else {
		            //return history
		            Task taskWithHistory = new Task();
		            taskWithHistory.setId(task.getId());
		            taskWithHistory.setSessionId(task.getSessionId());
		            taskWithHistory.setStatus(task.getStatus());
		            //get artifacts
		            taskWithHistory.setArtifacts(task.getArtifacts());
		            //get history
		            List<Message> history = task.getHistory();
		            if (history != null) {
		                int start = Math.max(0, history.size() - historyLength);
		                taskWithHistory.setHistory(history.subList(start, history.size()));
		            }
		            return ResponseEntity.ok(taskWithHistory);
		        }
		    }
		
		    @PostMapping("/cancel")
		    public ResponseEntity<Task> cancelTask(@RequestBody Map<String, String> body) {
		        String id = body.get("id");
		        Task task = tasks.get(id);
		        if (task == null) {
		            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Task not found");
		        }
		        task.setStatus(new TaskStatus("canceled"));
		        tasks.put(id, task); //update
		        return ResponseEntity.ok(task);
		    }
		
		    public String setTaskPushNotification(TaskSetPushNotificationParams params) {
		        // Retrieve the task from the map
		        Task task = tasks.get(params.getTaskId());
		
		        if (task == null) {
		            throw new IllegalArgumentException("Task not found");
		        }
		
		        // Set the push notification URL
		        task.setPushNotificationUrl(params.getPushNotificationUrl());
		
		        return "Push notification URL set successfully!";
		    }
		
		    public String resubscribeToTask(TaskResubscriptionParams params) {
		        // Retrieve the task from the map
		        Task task = tasks.get(params.getTaskId());
		
		        if (task == null) {
		            throw new IllegalArgumentException("Task not found");
		        }
		
		        // Resubscribe logic (e.g., resetting the task's subscription status)
		        task.setSubscribed(true);
		        task.setSubscriptionDateNow(new Date()); //
		
		        return "Task resubscribed successfully!";
		    }
		
		    public String cancelTask(String taskId) {
		        // Retrieve the task from the map
		        Task task = tasks.get(taskId);
		
		        if (task == null) {
		            throw new IllegalArgumentException("Task not found");
		        }
		
		        // Mark the task as cancelled
		        task.setCancelled(true);
		
		        // Optionally, remove the task from the map if needed
		        // tasks.remove(taskId);
		
		        return "Task cancelled successfully!";
		    }
		    public String getTaskPushNotification(TaskGetPushNotificationParams params) {
		        // Retrieve the task from the map
		        Task task = tasks.get(params.getTaskId());
		
		        if (task == null) {
		            throw new IllegalArgumentException("Task not found");
		        }
		
		        // Return the push notification URL
		        return task.getPushNotificationUrl();
		    }
		    @PostMapping("/pushNotification/set")
		    public ResponseEntity<TaskPushNotificationConfig> setTaskPushNotificationConfig(
		            @RequestBody TaskPushNotificationConfigRequest request) {
		        String id = request.getId();
		        Task task = tasks.get(id);
		        if (task == null) {
		            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Task not found");
		        }
		        // In a real application, you would store this configuration
		        // and use it when sending push notifications.  For this
		        // example, we just store it in the Task object.
		        task.setPushNotificationConfig(request.getPushNotificationConfig());
		        tasks.put(id, task);
		        return ResponseEntity.ok(request.getPushNotificationConfig());
		    }
		
		    @GetMapping("/pushNotification/get")
		    public ResponseEntity<TaskPushNotificationConfig> getTaskPushNotificationConfig(@RequestParam String id) {
		        Task task = tasks.get(id);
		        if (task == null) {
		            throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Task not found");
		        }
		        TaskPushNotificationConfig config = task.getPushNotificationConfig();
		        if (config == null) {
		            return ResponseEntity.notFound().build();
		        }
		        return ResponseEntity.ok(config);
		    }
		
		
		    @Override
		    @PostMapping(value = "/sendSubscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
		    public SseEmitter sendSubscribeTask(@RequestBody TaskSendSubscribeParams params) {
		        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE); //timeout
		        String id = params.getId();
		        emitters.put(id, emitter);
		
		
		        nonBlockingService.execute(() -> {
		            try {
		                TextPart textPart = new TextPart();
		                textPart.setType("text");
		                textPart.setText("Processing your ticket booking request...");
		
		                Message message = new Message();
		                message.setRole("agent");
		                message.setParts(List.of(textPart));
		
		                TaskStatus processingStatus = new TaskStatus("working");
		                processingStatus.setMessage(message);
		                SendTaskStreamingResponse response = new SendTaskStreamingResponse();
		                response.setId(id);
		                response.setResult((new TaskStatusUpdateEvent(id, processingStatus, false)));
		
		                sendSseEvent(id, response);
		            } catch (Exception e) {
		                emitter.completeWithError(e);
		            }
		        });
		        //handle client disconnects
		        emitter.onCompletion(() -> {
		            emitters.remove(id);
		            log.info("Client disconnected for task: " + id);
		        });
		        emitter.onError((throwable) -> {
		            emitters.remove(id);
		            log.info("Error occurred for task " + id + ": " + throwable.getMessage());
		        });
		        emitter.onTimeout(() -> {
		            emitters.remove(id);
		            emitter.complete();
		            log.info("Timeout occurred for task: " + id);
		        });
		        return emitter;
		    }
		
		    @GetMapping(value = "/resubscribe/{id}", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
		    public SseEmitter resubscribe(@PathVariable String id) {
		        SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
		        emitters.put(id, emitter);
		
		        Task task = tasks.get(id);
		        if (task != null) {
		            //send current status
		            try {
		                emitter.send(SseEmitter.event().name("message").data(new TaskStatusUpdateEvent(id, task.getStatus(), false)));
		                //send all artifacts
		                if (task.getArtifacts() != null) {
		                    for (Artifact artifact : task.getArtifacts()) {
		                        emitter.send(SseEmitter.event().name("message").data(new TaskArtifactUpdateEvent(id, artifact)));
		                    }
		                }
		
		            } catch (IOException e) {
		                emitters.remove(id);
		                emitter.completeWithError(e);
		                log.severe("Error re-subscribing" + e.getMessage());
		            }
		        }
		        else {
		            try {
		                emitter.send(SseEmitter.event().name("message").data("Task does not exist"));
		                emitter.complete();
		                emitters.remove(id);
		            } catch (IOException e) {
		                log.severe("Error sending task  message" + e.getMessage());
		            }
		
		        }
		
		        emitter.onCompletion(() -> {
		            emitters.remove(id);
		            log.severe("Client disconnected on resubscribe: " + id);
		        });
		        emitter.onError((throwable) -> {
		            emitters.remove(id);
		            log.severe("Error on resubscribe for task " + id + ": " + throwable.getMessage());
		        });
		        emitter.onTimeout(() -> {
		            emitters.remove(id);
		            emitter.complete();
		            log.severe("Timeout on resubscribe for task: " + id);
		        });
		        return emitter;
		    }
		}]]></file>
	<file path='src\test\resources\tools4ai.properties'>
		##Gemini related settings
		gemini.modelName=gemini-2.0-flash-001
		#gemini.modelName=test
		#gemini.modelName=gemini-1.5-pro-preview-0409
		gemini.location=us-central1
		gemini.projectId=cookgptserver
		#gemini.projectId=test
		gemini.vision.modelName=gemini-1.0-pro-vision
		
		##Anthropic related settings
		anthropic.modelName=claude-3-haiku-20240307
		anthropic.logRequests=true
		anthropic.logResponse=true
		
		#set it here or use -DclaudeKey parameter
		claudeKey=
		
		##Open AI Key
		#set it here or use -DopenAiKey parameter
		openAiKey=demo
		##Open AI Base URL keep it empty or set it here or in vm option
		openAiBaseURL=http://langchain4j.dev/demo/openai/v1
		
		openAiModelName=gpt-4o-mini
		
		##Serper Key for google search or hallucination detection
		serperKey=
		
		agent.provider=openai
		action.packages.to.scan=regression.action</file>
	<file path='tasks.json'>
		{"32889e05-ad2f-41dd-9539-06abbd35e2a1":{"id":"32889e05-ad2f-41dd-9539-06abbd35e2a1","sessionId":"3c04126d-3d43-48f2-b6a2-3db508e1ddbe","status":{"state":"failed","message":{"role":"agent","parts":[{"type":"text","type":"text","metadata":{},"text":"Processing failed: null"}],"metadata":null},"timestamp":"2025-05-17T15:01:55.758713800Z"},"history":[{"role":null,"parts":[{"type":"text","type":"text","metadata":{},"text":"Concurrent test 2"}],"metadata":null}],"artifacts":null,"metadata":null,"pushNotificationConfig":null,"pushNotificationUrl":null,"subscribed":false,"subscriptionDateNow":null,"cancelled":false},"2c77c573-6958-4932-9e14-d0b5ea804fb9":{"id":"2c77c573-6958-4932-9e14-d0b5ea804fb9","sessionId":"eaa00afc-947d-49da-957a-eb697dd0010d","status":{"state":"failed","message":{"role":"agent","parts":[{"type":"text","type":"text","metadata":{},"text":"Processing failed: null"}],"metadata":null},"timestamp":"2025-05-17T15:01:55.758713800Z"},"history":[{"role":null,"parts":[{"type":"text","type":"text","metadata":{},"text":"Concurrent test 0"}],"metadata":null}],"artifacts":null,"metadata":null,"pushNotificationConfig":null,"pushNotificationUrl":null,"subscribed":false,"subscriptionDateNow":null,"cancelled":false},"8b258083-b19e-4a32-9ae0-8b3842038946":{"id":"8b258083-b19e-4a32-9ae0-8b3842038946","sessionId":"156a6a47-38b4-4852-af24-eda03b7ce9b8","status":{"state":"failed","message":{"role":"agent","parts":[{"type":"text","type":"text","metadata":{},"text":"Processing failed: null"}],"metadata":null},"timestamp":"2025-05-17T15:01:55.758713800Z"},"history":[{"role":null,"parts":[{"type":"text","type":"text","metadata":{},"text":"Concurrent test 3"}],"metadata":null}],"artifacts":null,"metadata":null,"pushNotificationConfig":null,"pushNotificationUrl":null,"subscribed":false,"subscriptionDateNow":null,"cancelled":false},"5b0776c9-27aa-4cc6-a4d4-3f918312f032":{"id":"5b0776c9-27aa-4cc6-a4d4-3f918312f032","sessionId":"ebc81021-3372-430a-8818-47f46352e261","status":{"state":"failed","message":{"role":"agent","parts":[{"type":"text","type":"text","metadata":{},"text":"Processing failed: null"}],"metadata":null},"timestamp":"2025-05-17T15:01:55.758713800Z"},"history":[{"role":null,"parts":[{"type":"text","type":"text","metadata":{},"text":"Concurrent test 1"}],"metadata":null}],"artifacts":null,"metadata":null,"pushNotificationConfig":null,"pushNotificationUrl":null,"subscribed":false,"subscriptionDateNow":null,"cancelled":false},"a23dec82-9bd4-48c0-9539-7403c2904147":{"id":"a23dec82-9bd4-48c0-9539-7403c2904147","sessionId":"e0ec5421-1fb5-475b-8555-a778f835ccea","status":{"state":"failed","message":{"role":"agent","parts":[{"type":"text","type":"text","metadata":{},"text":"Processing failed: null"}],"metadata":null},"timestamp":"2025-05-17T15:01:55.758713800Z"},"history":[{"role":null,"parts":[{"type":"text","type":"text","metadata":{},"text":"Concurrent test 4"}],"metadata":null}],"artifacts":null,"metadata":null,"pushNotificationConfig":null,"pushNotificationUrl":null,"subscribed":false,"subscriptionDateNow":null,"cancelled":false}}</file>
	<file path='tutorial\0_FAQ.md'><![CDATA[
		# Frequently Asked Questions (FAQ)
		
		## How do I create an A2A agent in Java?
		To create an A2A agent, follow these steps:
		
		1. Add the Maven dependency:
		```xml
		<dependency>
		    <groupId>io.github.vishalmysore</groupId>
		    <artifactId>a2ajava</artifactId>
		    <version>0.1.8.2</version>
		</dependency>
		<dependency>
		<groupId>io.github.vishalmysore</groupId>
		<artifactId>tools4ai-annotations</artifactId>
		<version>0.0.2</version>
		</dependency>
		<dependency>
		<groupId>io.github.vishalmysore</groupId>
		<artifactId>tools4ai-security</artifactId>
		<version>0.0.3</version>
		</dependency>
		```
		
		2. Create a properties file `tools4ai.properties`: By default the provider is set to `gemini` but you can change it to `openai` if needed. you can see the sample of tools4ai.properties file [here](https://github.com/vishalmysore/SpringActions/blob/main/src/main/resources/tools4ai.properties):
		```properties
		agent.provider=gemini  # or openai
		```
		
		3. Create your agent class:
		```java
		@Agent(groupName = "ticket-booking", 
		       groupDescription = "Handles airline ticket booking operations")
		public class BookingAgent {
		    @Action(description = "Book a flight ticket")
		    public String bookFlight(String from, String to, String date) {
		        actionCallback.sendtStatus("Starting booking process", ActionState.WORKING);
		        try {
		            // Booking implementation
		            actionCallback.sendtStatus("Booking completed", ActionState.COMPLETED);
		            return "Booking confirmed";
		        } catch (Exception e) {
		            actionCallback.sendtStatus("Booking failed: " + e.getMessage(), ActionState.ERROR);
		            throw e;
		        }
		    }
		}
		```
		In you spring boot application, you can enable the agent by using the `@EnableAgent` annotation:
		
		
		
		## How does agent card get generated?
		If you are using the @EnableAgent annotation  your agent card will get generated automatically,
		The framework automatically converts `@Action` annotations into agent card skills.
		
		These classes can be used for more customization ( YOU DONT NEED TO USE THEM UNLESS YOU WANT TO CUSTOMIZE THE AGENT CARD):
		
		Agent cards are generated in three ways for custom usage:
		
		1. **Dynamic Generation**: Through `DynamicAgentCardController` which generates cards based on runtime annotations
		2. **Real-time Generation**: Using `RealTimeAgentCardController` which uses AI for dynamic description generation
		3. **Static Generation**: Template-based for specific implementations
		
		
		
		## How is agent card visible?
		A2A Agent cards are exposed through  endpoints:
		
		 A2A Protocol endpoint: `/.well-known/agent.json`
		
		
		## How do I create an MCP agent in Java?
		The same `@Action` annotation creates both A2A and MCP endpoints. For MCP:
		
		```java
		@Agent(groupName = "property-valuation", 
		       groupDescription = "Property valuation services")
		public class PropertyAgent {
		    @Action(description = "Estimate property value",
		            riskLevel = ActionRisk.MEDIUM)
		    public ValuationResult estimateValue(
		        @ActionParameter(name = "propertyDetails",
		                        description = "Property details including location, size")
		        PropertyDetails details) {
		        // Implementation
		    }
		}
		```
		This will automatically get converted to the MCP Tools
		
		
		## How does tool definition get generated?
		Tool definitions are automatically generated by the MCPToolsController which:
		- Converts `@Action` annotated methods to tools
		- Generates parameter schemas
		- Creates AI-friendly descriptions
		- Supports both structured and natural language inputs
		
		
		## How do I test my A2A Agent?
		You can use Curl command to test if you application is running properly:
		
		```bash
		curl -H "Content-Type: application/json" -d '{
		    "jsonrpc": "2.0",
		    "method": "tools/list",
		    "params": {},
		    "id": 1
		}' https://vishalmysore-a2amcpspring.hf.space/
		````
		The above one will get the list of tools available in the agent. You can also use the `tools/call` method to call a specific tool.
		
		```json
		{
		    "method": "tools/call",
		    "params": {
		        "name": "whatThisPersonFavFood",
		        "arguments": {
		            "provideAllValuesInPlainEnglish": "vishal is coming home what should i cook"
		        }
		    },
		    "jsonrpc": "2.0",
		    "id": 17
		}
		```
		
		## How can i connect to the Claude Desktop?
		
		Claude Desktop can be connected to A2A and MCP sever through the pass through server. Please look at the details [here](https://github.com/vishalmysore/mcp-connector/)
		
		
		
		## What different types of processors are there?
		Available processors include:
		- `GeminiV2ActionProcessor`: For Google's Gemini AI
		- `OpenAiActionProcessor`: For OpenAI integration
		- `SpringGeminiProcessor`: Spring-integrated Gemini processor
		- `SpringOpenAIProcessor`: Spring-integrated OpenAI processor
		- `SeleniumProcessor`: For UI automation integration
		- `AnthropicActionProcessor` : Claude 
		- `LocalAiActionProcessor` : Local AI integration
		
		## How do I add risk types to agents?
		Use the `riskLevel` parameter in the `@Action` annotation:
		
		```java
		@Agent(groupName = "banking")
		public class BankingAgent {
		    @Action(description = "Check balance", riskLevel = ActionRisk.LOW)
		    public String checkBalance(String accountId) {
		        // Implementation
		    }
		    
		    @Action(description = "Transfer funds", riskLevel = ActionRisk.HIGH)
		    public String transferFunds(String from, String to, double amount) {
		        // Implementation with additional validation
		    }
		}
		```
		
		Risk levels: LOW, MEDIUM, HIGH. High-risk actions require human validation.
		
		## How can I do image processing?
		Use the `GeminiImageActionProcessor` for image processing:
		
		```java
		public class ImageProcessor {
		    public void processImage(String imagePath) throws AIProcessingException {
		        GeminiImageActionProcessor processor = new GeminiImageActionProcessor();
		        String imageDescription = processor.imageToText(imagePath);
		        
		        // Process the description with an action processor
		        GeminiV2ActionProcessor actionProcessor = new GeminiV2ActionProcessor();
		        Object result = actionProcessor.processSingleAction(imageDescription);
		    }
		}
		```
		
		## What are different prompt annotations?
		Key annotations include:
		- `@Agent`: Defines an agent group and description
		- `@Action`: Marks methods as AI-callable actions
		- `@ActionParameter`: Describes parameters for better AI understanding
		- `@Predict`: Used for automatic action prediction
		- `@ListType`: Specifies collection types for serialization
		
		## How do I handle complex Java types?
		Complex types are handled through:
		1. Automatic parameter mapping:
		```java
		@Action(description = "Process customer data")
		public Response processCustomer(@ActionParameter(
		    name = "customer",
		    description = "Customer details including name, age, and preferences"
		) CustomerDTO customer) {
		    // Implementation
		}
		```
		
		2. PromptTransformer for complex type conversion:
		```java
		@Override
		public PromptTransformer getPromptTransformer() {
		    return new GeminiV2PromptTransformer();
		}
		```
		
		The framework automatically handles JSON serialization/deserialization of complex types.
		
		## How Can i persist the Task?
		
		By Default the tasks are persisted in memory and not persisted to any database. You can use the property 
		
		```
		a2a.persistence=database
		```
		to save the data in db
		
		## How can I build agentic mesh applications?
		 Yes source code for agentic mesh is https://github.com/vishalmysore/agenticmesh]]></file>
	<file path='tutorial\1_introduction.md'><![CDATA[
		# A2AJava: Quick Start Guide to Agent Development
		
		## Table of Contents
		1. [Getting Started](#getting-started)
		2. [Creating Your First Agent](#creating-your-first-agent)
		3. [Advanced Configuration](#advanced-configuration)
		4. [Protocol Details](#protocol-details)
		5. [Error Handling & Best Practices](#error-handling--best-practices)
		6. [Advanced Features](#advanced-features)
		
		## Getting Started
		
		### Installation
		Add the following Maven dependency to your project:
		```xml
		<dependency>
		    <groupId>io.github.vishalmysore</groupId>
		    <artifactId>a2ajava</artifactId>
		    <version>0.0.7.1</version>
		</dependency>
		```
		
		### Basic Configuration
		1. Create `tools4ai.properties` in your resources folder:
		```properties
		agent.provider=gemini  # or openai
		```
		
		## Creating Your First Agent
		
		### 1. Basic Agent Structure
		```java
		@Agent(groupName = "ticket-booking", 
		       groupDescription = "Handles airline ticket booking operations")
		public class BookingAgent {
		    @Action(description = "Book a flight ticket")
		    public String bookFlight(String from, String to, String date) {
		        // Your implementation here
		    }
		}
		```
		
		### 2. Adding Real-time Updates
		```java
		@Action(description = "Book a flight ticket")
		public String bookFlight(String from, String to, String date) {
		    actionCallback.sendtStatus("Starting booking process", ActionState.WORKING);
		    try {
		        // Booking logic here
		        actionCallback.sendtStatus("Booking completed", ActionState.COMPLETED);
		        return "Booking confirmed";
		    } catch (Exception e) {
		        actionCallback.sendtStatus("Booking failed: " + e.getMessage(), ActionState.ERROR);
		        throw e;
		    }
		}
		```
		
		### 3. Handling Different Message Types
		```java
		@Action(description = "Process booking request")
		public void processBooking(Message message) {
		    for (Part part : message.getParts()) {
		        switch (part) {
		            case TextPart textPart -> handleTextBooking(textPart);
		            case DataPart dataPart -> handleStructuredBooking(dataPart);
		            case FilePart filePart -> handleFileAttachment(filePart);
		        }
		    }
		}
		```
		
		## Advanced Configuration
		
		### AI Model Integration
		
		1. Configure the AI Provider:
		```properties
		# tools4ai.properties
		agent.provider=gemini
		```
		
		2. Implement a Custom Transformer:
		```java
		@Override
		public PromptTransformer getPromptTransformer() {
		    return new GeminiV2PromptTransformer();
		}
		```
		
		### Protocol Support
		
		Your agent automatically supports both:
		- A2A Protocol (Agent-to-Agent communication)
		- MCP Protocol (Model Context Protocol for AI model interaction)
		
		The framework exposes:
		1. `/.well-known/agent.json` - A2A protocol endpoint
		2. `/mcp/tools` - MCP protocol endpoint
		
		## Error Handling & Best Practices
		
		### 1. Proper Error Handling
		```java
		@Action(description = "Process transaction")
		public TransactionResult processTransaction(Transaction tx) {
		    try {
		        actionCallback.sendtStatus("Validating", ActionState.WORKING);
		        validateTransaction(tx);
		        
		        actionCallback.sendtStatus("Processing", ActionState.WORKING);
		        return processValidTransaction(tx);
		    } catch (Exception e) {
		        actionCallback.sendtStatus("Failed: " + e.getMessage(), ActionState.ERROR);
		        return new TransactionResult(false, e.getMessage());
		    }
		}
		```
		
		### 2. Best Practices
		- Group related actions using meaningful `@Agent` groupNames
		- Provide clear action descriptions
		- Use appropriate parameter types
		- Implement proper status updates
		- Follow security guidelines
		  - Use HTTPS in production
		  - Implement authentication
		  - Secure sensitive data
		
		## Advanced Features
		
		### 1. Dynamic Tool Discovery
		- Automatic tool registration
		- Parameter type inference
		- JSON schema generation
		- AI-friendly descriptions
		
		### 2. Message Types Support
		- TextPart: Plain text
		- FilePart: File transfers
		- DataPart: Structured data
		
		### 3. Real-time Updates
		Both protocols support status updates through:
		- `ActionCallback` (A2A)
		- `MCPActionCallback` (MCP)
		
		## Security Considerations
		
		1. Authentication Setup
		```java
		agentCard.setAuthentication(new Authentication(new String[]{"Bearer"}));
		```
		
		2. HTTPS Configuration
		3. OAuth2 Integration (if needed)
		4. Proper input validation
		
		## Future Development Areas
		
		1. AI Provider Integration
		   - Additional AI providers
		   - Enhanced configuration options
		   - Custom transformations
		
		2. Protocol Enhancements
		   - Extended message types
		   - Improved real-time capabilities
		   - Enhanced streaming
		
		3. Developer Experience
		   - Additional tools
		   - Enhanced debugging
		   - Comprehensive logging]]></file>
	<file path='tutorial\10_ComplexAgents.md'><![CDATA[
		# Complex Multi-Agent Workflow: House Buying System
		
		*** Please note this tutorial is still work in progres, I will update it shortly ***
		
		## Overview
		This tutorial demonstrates how to build a sophisticated multi-agent system using A2AJava and Tools4AI. We'll create a house buying workflow that showcases advanced features like:
		- Dynamic task processing
		- Real-time agent communication
		- Risk management
		- Human-in-loop approvals
		- Server-Sent Events (SSE) for real-time updates
		
		## 1. Configuration Setup
		
		First, configure your Tools4AI properties:
		
		```properties
		# tools4ai.properties
		agent.provider=gemini
		agent.risk.level.default=LOW
		agent.human.approval.required=true
		```
		
		## 2. Task Processing Infrastructure
		
		### Base Task Controller
		```java
		@Service
		public class HouseBuyingTaskController extends DyanamicTaskContoller {
		    
		    @Autowired
		    private RiskManager riskManager;
		    
		    @Override
		    public SendTaskResponse sendTask(TaskSendParams taskSendParams, ActionCallback callback) {
		        String taskId = taskSendParams.getId();
		        Task task = new Task();
		        task.setId(taskId);
		        task.setSessionId(UUID.randomUUID().toString());
		        
		        // Configure real-time updates
		        task.setPushNotificationConfig(new TaskPushNotificationConfig());
		        
		        // Process task asynchronously
		        nonBlockingService.execute(() -> {
		            try {
		                TextPart textPart = (TextPart) taskSendParams.getMessage().getParts().get(0);
		                String prompt = textPart.getText();
		                
		                SSEEmitterCallback sseCallback = new SSEEmitterCallback(taskId, getEmitter(taskId));
		                sseCallback.setContext(task);
		                
		                // Process with risk awareness
		                if (riskManager.requiresApproval(task, getCurrentAgent())) {
		                    processHighRiskTask(task, prompt, sseCallback);
		                } else {
		                    getBaseProcessor().processSingleAction(prompt, sseCallback);
		                }
		            } catch (Exception e) {
		                handleTaskError(task, e);
		            }
		        });
		        
		        return createResponse(task);
		    }
		}
		```
		
		## 3. Real-Time Updates Implementation
		
		### SSE Callback Handler
		```java
		public class SSEEmitterCallback implements ActionCallback {
		    private final String taskId;
		    private final SseEmitter emitter;
		    private Task context;
		
		    @Override
		    public void sendtStatus(String status, ActionState state) {
		        try {
		            TaskStatusUpdateEvent event = new TaskStatusUpdateEvent(
		                taskId, 
		                new TaskStatus(state.name(), status),
		                false
		            );
		            emitter.send(SseEmitter.event()
		                .name("status_update")
		                .data(event));
		        } catch (IOException e) {
		            log.severe("Failed to send SSE update: " + e.getMessage());
		        }
		    }
		
		    @Override
		    public void setContext(Object context) {
		        if (context instanceof Task) {
		            this.context = (Task) context;
		        }
		    }
		}
		```
		
		## 4. Risk Management Integration
		
		### Risk-Aware Action Processing
		```java
		@Component
		public class HouseBuyingRiskManager extends RiskManager {
		    
		    @Override
		    public boolean requiresApproval(Task task, Agent agent) {
		        if (task.getType() == TaskType.MAKE_OFFER) {
		            Map<String, Object> params = task.getParameters();
		            double offerAmount = Double.parseDouble(params.get("amount").toString());
		            
		            // High-risk conditions
		            if (offerAmount > 1000000) {
		                return true;
		            }
		            
		            // Medium-risk conditions requiring additional checks
		            if (offerAmount > 500000) {
		                return validateMediumRiskOffer(params);
		            }
		        }
		        
		        return false;
		    }
		    
		    private boolean validateMediumRiskOffer(Map<String, Object> params) {
		        // Implement medium-risk validation logic
		        // For example, check buyer's credit score, down payment, etc.
		        return false;
		    }
		}
		```
		
		## 5. Human-in-Loop Integration
		
		### Approval Workflow
		```java
		@Service
		public class HouseOfferApprovalService {
		    
		    @Autowired
		    private StateMachine<ApprovalStates, ApprovalEvents> stateMachine;
		    
		    @Autowired
		    private HumanInLoop humanInLoop;
		    
		    public void processOffer(Task offerTask) {
		        FeedbackLoop feedback = humanInLoop.allow(
		            createApprovalPrompt(offerTask),
		            "validateOffer",
		            offerTask.getParameters()
		        );
		        
		        feedback.setCallback(new ActionCallback() {
		            @Override
		            public void onComplete(ActionState state) {
		                if (state == ActionState.APPROVED) {
		                    stateMachine.sendEvent(ApprovalEvents.APPROVE);
		                    proceedWithOffer(offerTask);
		                } else {
		                    stateMachine.sendEvent(ApprovalEvents.REJECT);
		                    handleRejectedOffer(offerTask);
		                }
		            }
		        });
		    }
		    
		    private String createApprovalPrompt(Task task) {
		        return String.format(
		            "High-value offer requiring approval:\n" +
		            "Property: %s\n" +
		            "Offer Amount: $%s\n" +
		            "Buyer: %s\n" +
		            "Please review and approve/reject.",
		            task.getParameters().get("propertyId"),
		            task.getParameters().get("amount"),
		            task.getParameters().get("buyerId")
		        );
		    }
		}
		```
		
		## 6. Event Handling and Monitoring
		
		### Event Listener Implementation
		```java
		@Component
		public class HouseBuyingEventListener {
		    
		    @EventListener
		    public void onStateChange(StateMachineEvent event) {
		        logStateTransition(event);
		        notifyRelevantParties(event);
		        updateTaskStatus(event);
		    }
		    
		    @EventListener
		    public void onRiskDetected(RiskDetectedEvent event) {
		        // Handle risk events
		        escalateIfNeeded(event);
		        updateRiskMetrics(event);
		    }
		    
		    @Async
		    public void notifyRelevantParties(StateMachineEvent event) {
		        // Implement notification logic
		        // For example, send emails, push notifications, etc.
		    }
		}
		```
		
		## 7. Complete Usage Example
		
		```java
		@RestController
		@RequestMapping("/api/house-buying")
		public class HouseBuyingController {
		    
		    @Autowired
		    private HouseBuyingWorkflowService workflowService;
		    
		    @Autowired
		    private HouseOfferApprovalService approvalService;
		    
		    @PostMapping("/make-offer")
		    public ResponseEntity<String> makeOffer(@RequestBody OfferRequest request) {
		        // Create and validate the task
		        Task offerTask = createOfferTask(request);
		        
		        // Start the workflow
		        if (workflowService.requiresHumanApproval(offerTask)) {
		            approvalService.processOffer(offerTask);
		            return ResponseEntity.ok("Offer submitted for approval");
		        } else {
		            workflowService.processOffer(offerTask);
		            return ResponseEntity.ok("Offer processed automatically");
		        }
		    }
		    
		    @GetMapping("/updates/{taskId}")
		    public SseEmitter subscribeToUpdates(@PathVariable String taskId) {
		        return workflowService.createUpdateEmitter(taskId);
		    }
		}
		```
		
		## 8. MCP (Model Context Protocol) Integration
		
		### MCP Tools Controller
		```java
		@Service
		public class HouseBuyingMCPController extends MCPToolsController {
		    
		    @Override
		    public CallToolResult callTool(ToolCallRequest request, ActionCallback callback) {
		        // Configure AI processing based on tools4ai.properties
		        AIProcessor processor = getBaseProcessor();
		        
		        Map<String, AIAction> predictions = PredictionLoader.getInstance().getPredictions();
		        AIAction action = predictions.get(request.getName());
		        
		        try {
		            // Process with human verification and explanation
		            Object result = processor.processSingleAction(
		                request.toString(),
		                action,
		                new LoggingHumanDecision(),
		                new LogginggExplainDecision(),
		                callback
		            );
		            
		            return createToolResponse(result, callback);
		        } catch (AIProcessingException e) {
		            return handleAIError(e);
		        }
		    }
		    
		    private CallToolResult createToolResponse(Object result, ActionCallback callback) {
		        CallToolResult callToolResult = new CallToolResult();
		        List<Content> content = new ArrayList<>();
		        TextContent textContent = new TextContent();
		        textContent.setText(result.toString());
		        textContent.setType("text");
		        content.add(textContent);
		        callToolResult.setContent(content);
		        callback.setContext(callToolResult);
		        return callToolResult;
		    }
		}
		```
		
		### AI Action Annotations
		```java
		@Agent(groupName = "house-valuation", groupDescription = "Property valuation and analysis")
		public class PropertyValuationAgent {
		
		    @Action(name = "estimatePropertyValue", 
		            description = "Estimates property value based on features and market data",
		            risk = ActionRisk.MEDIUM)
		    public ValuationResult estimatePropertyValue(
		            @ActionParameter(name = "propertyFeatures", description = "Property details including location, size, etc.") 
		            PropertyFeatures features,
		            @ActionParameter(name = "marketData", description = "Current market conditions and comparable sales") 
		            MarketData marketData) {
		        // Implementation
		    }
		}
		```
		
		### MCP Callback Implementation
		```java
		public class MCPHouseBuyingCallback implements MCPActionCallback {
		    private final Task task;
		    
		    @Override
		    public void setContext(Object obj) {
		        if (obj instanceof CallToolResult) {
		            updateTaskWithToolResult((CallToolResult) obj);
		        }
		    }
		    
		    private void updateTaskWithToolResult(CallToolResult result) {
		        TaskStatus status = new TaskStatus(TaskState.COMPLETED);
		        Message message = new Message();
		        message.setParts(convertContentToParts(result.getContent()));
		        status.setMessage(message);
		        task.setStatus(status);
		    }
		}
		```
		
		## 9. AI Model Integration Examples
		
		### Property Value Estimation
		```java
		@Service
		public class PropertyAIService {
		    
		    @Autowired
		    private AIProcessor aiProcessor;
		    
		    public ValuationEstimate getPropertyValuation(PropertyDetails details) {
		        String prompt = String.format(
		            "Analyze the following property details and provide a valuation estimate:\n" +
		            "Location: %s\n" +
		            "Square Footage: %d\n" +
		            "Bedrooms: %d\n" +
		            "Year Built: %d\n" +
		            "Recent Renovations: %s",
		            details.getLocation(),
		            details.getSquareFootage(),
		            details.getBedrooms(),
		            details.getYearBuilt(),
		            details.getRenovations()
		        );
		        
		        try {
		            AIAction action = PredictionLoader.getInstance()
		                .getPredictedAction(prompt, AIPlatform.GEMINI);
		            
		            return (ValuationEstimate) aiProcessor.processSingleAction(
		                prompt, 
		                action,
		                new PropertyValuationHumanVerification(),
		                new ValuationExplanationProvider()
		            );
		        } catch (AIProcessingException e) {
		            log.severe("AI Valuation failed: " + e.getMessage());
		            throw new ValuationException("Failed to estimate property value", e);
		        }
		    }
		}
		```
		
		### Market Analysis Integration
		```java
		@Service
		public class MarketAnalysisService {
		    
		    @Autowired
		    private AIProcessor aiProcessor;
		    
		    public MarketReport analyzeMarketConditions(String location) {
		        String prompt = createMarketAnalysisPrompt(location);
		        
		        try {
		            return (MarketReport) aiProcessor.processSingleAction(
		                prompt,
		                new MarketAnalysisCallback()
		            );
		        } catch (AIProcessingException e) {
		            handleAnalysisError(e);
		            return null;
		        }
		    }
		    
		    private String createMarketAnalysisPrompt(String location) {
		        return String.format(
		            "Analyze current market conditions for %s including:\n" +
		            "1. Average home prices\n" +
		            "2. Price trends over last 6 months\n" +
		            "3. Average days on market\n" +
		            "4. Inventory levels\n" +
		            "5. Buyer/seller market indicators",
		            location
		        );
		    }
		}
		```
		
		This MCP integration enables:
		- AI-powered property valuation
		- Market analysis and predictions
		- Risk assessment automation
		- Decision support for agents
		- Automated document analysis
		- Smart contract recommendations
		
		The combination of A2AJava's task management and Tools4AI's AI capabilities creates a powerful platform for intelligent real estate operations.
		
		## Best Practices and Advanced Features
		
		1. **Error Handling and Recovery**
		   - Implement compensating transactions
		   - Use reliable messaging patterns
		   - Maintain audit logs
		
		2. **Scalability Considerations**
		   - Use asynchronous processing
		   - Implement proper task queuing
		   - Consider distributed state management
		
		3. **Security Best Practices**
		   - Implement proper authentication
		   - Use role-based access control
		   - Validate all inputs
		
		4. **Monitoring and Maintenance**
		   - Track task processing metrics
		   - Monitor state transitions
		   - Set up alerting for failures
		
		## Integration Tips
		
		1. Configure proper timeouts for long-running tasks:
		```java
		@Configuration
		public class TaskConfig {
		    @Bean
		    public SseEmitter createEmitter() {
		        return new SseEmitter(Long.MAX_VALUE);
		    }
		    
		    @Bean
		    public ExecutorService taskExecutor() {
		        return Executors.newCachedThreadPool();
		    }
		}
		```
		
		2. Implement proper cleanup:
		```java
		@PreDestroy
		public void cleanup() {
		    emitters.forEach((id, emitter) -> {
		        try {
		            emitter.complete();
		        } catch (Exception e) {
		            log.warning("Error during emitter cleanup: " + e.getMessage());
		        }
		    });
		}
		```
		
		## Testing Considerations
		
		1. Unit Testing:
		```java
		@Test
		public void testHighRiskOfferRequiresApproval() {
		    Task task = createHighValueOfferTask();
		    assertTrue(riskManager.requiresApproval(task, buyerAgent));
		}
		```
		
		2. Integration Testing:
		```java
		@SpringBootTest
		public class WorkflowIntegrationTest {
		    @Test
		    public void testCompleteWorkflow() {
		        // Test the entire workflow
		        OfferRequest request = createTestOffer();
		        SendTaskResponse response = workflowService.processOffer(request);
		        assertNotNull(response.getTaskId());
		        // Verify state transitions
		    }
		}
		```
		
		## Conclusion
		
		This implementation demonstrates how to:
		- Build complex multi-agent systems
		- Handle real-time updates
		- Manage risks
		- Integrate human approval workflows
		- Scale and monitor the system
		
		Next steps could include:
		- Adding more specialized agents
		- Implementing advanced analytics
		- Adding blockchain integration
		- Implementing machine learning for risk assessment]]></file>
	<file path='tutorial\2_AnnotationsDeepDive.md'><![CDATA[
		# Annotations Deep Dive
		
		## Introduction
		
		A2AJava's annotation system provides a powerful way to convert natural language into structured data and actions. This guide explains how to use annotations effectively in your applications.
		
		## Table of Contents
		1. [Prompt to POJO Conversion](#1-prompt-to-pojo-conversion)
		2. [Action System](#2-action-system)
		3. [Data Annotations](#3-data-annotations)
		4. [Special Features](#4-special-features)
		5. [Security Features](#5-security-features)
		6. [Troubleshooting](#6-troubleshooting)
		
		## 1. Prompt to POJO Conversion
		
		### Overview
		A2AJava can automatically convert natural language text into Java objects. This feature uses AI to extract structured data from unstructured text.
		You can convert you entire springboot based applicaiton into a2a and mcp compliant agent by using these  4 annotations:
		
		```java
		import com.t4a.annotations.Action;
		
		@EnableAgent  - converts your springboot application into an A2A agent
		@EnabaleAgentSecurity- adds security features to your agent
		@Agent(groupName = "organization", groupDescription = "Handles organization data") - creates an agent group
		@Action(description = "") - creates an action within the agent group
		
		```
		
		
		### Basic Example
		```java
		OpenAIPromptTransformer transformer = new OpenAIPromptTransformer();
		
		// Example prompt with employee information
		String promptText = "Shahrukh Khan works for MovieHits inc and his salary is $100. " +
		    "He joined Toronto on Labor day, his tasks are acting and dancing. " +
		    "He also works out of Montreal and Bombay. " +
		    "Krithik roshan is another employee based in Chennai, his tasks are jumping and Gym, " +
		    "he joined on Indian Independence Day";
		
		// Convert to Organization object
		Organization org = (Organization) transformer.transformIntoPojo(promptText, Organization.class);
		
		// The system automatically extracts:
		// - Employee names and their locations
		// - Salary information
		// - Join dates
		// - Tasks/responsibilities
		// - Multiple office locations
		```
		
		### How It Works
		1. The AI analyzes the text to identify relevant information
		2. Maps identified data to POJO fields based on context
		3. Handles data type conversion automatically
		4. Creates object instances with populated data
		
		## 2. Action System
		
		### Overview
		Actions are the core way to handle operations in A2AJava. They can be triggered explicitly or automatically based on natural language input.
		
		### Explicit Actions
		
		```java
		@Agent(groupName = "diary", groupDescription = "Personal diary management")
		public class DiaryAction implements JavaMethodAction {
		    @Action(description = "Record appointments and meetings")
		    public DiaryEntry recordEntry(String entry) {
		        // Implementation
		        return new DiaryEntry(entry);
		    }
		}
		
		// Usage
		OpenAiActionProcessor processor = new OpenAiActionProcessor();
		DiaryAction action = new DiaryAction();
		String prompt = "I have a dentist appointment on July 3rd at 2 PM, " +
		                "and a meeting with the team on July 5th at 10 AM";
		DiaryEntry result = (DiaryEntry) processor.processSingleAction(prompt, action);
		```
		
		### Automatic Action Selection
		```java
		// The system automatically chooses the appropriate action
		String prompt = "Schedule a team meeting for tomorrow at 3 PM";
		Object result = processor.processSingleAction(prompt);
		```
		
		## 3. Data Annotations
		
		### List Handling
		```java
		public class Organization {
		    // Automatically maps employee list from text
		    @ListType(Employee.class)
		    private List<Employee> employees;
		    
		    // Handles simple string lists (e.g., office locations)
		    @ListType(String.class)
		    private List<String> locations;
		}
		```
		
		### Map Handling
		```java
		public class SportSchedule {
		    // Maps key-value pairs from text
		    @MapKeyType(DayOfWeek.class)
		    @MapValueType(String.class)
		    private Map<DayOfWeek, String> schedule;
		}
		
		// Can be populated from text like:
		// "Monday is for swimming, Wednesday for gym, Friday for yoga"
		```
		
		## 4. Special Features
		
		### Multi-Language Support
		```java
		public class TranslationRequest {
		    @Prompt(describe = "translate to Hindi")
		    private String hindi;
		    
		    @Prompt(describe = "translate to Tamil")
		    private String tamil;
		    
		    @Prompt(describe = "translate to Punjabi")
		    private String punjabi;
		}
		
		// Usage
		String text = "Hello, how are you?";
		TranslationRequest translations = transformer.transformIntoPojo(text, TranslationRequest.class);
		// Automatically translates to all specified languages
		```
		
		### Smart Date Handling
		```java
		public class Event {
		    @Prompt(
		        dateFormat = "yyyy-MM-dd",
		        describe = "Extract event date, use today if not specified"
		    )
		    private Date eventDate;
		}
		```
		
		### Field Control
		```java
		public class UserProfile {
		    // Field will be excluded from AI processing
		    @Prompt(ignore = true)
		    private String sensitiveData;
		    
		    // Custom processing instructions
		    @Prompt(describe = "Extract user's full name, capitalize each word")
		    private String fullName;
		}
		```
		
		## 5. Security Features
		
		### High-Risk Actions
		Actions that could affect system stability require explicit invocation:
		
		```java
		@Agent(
		    actionName = "serverRestart",
		    description = "Restart the production server",
		    riskLevel = ActionRisk.HIGH,
		    groupName = "System Administration"
		)
		public class ServerAction implements JavaMethodAction {
		    @Action
		    public String restartServer(String reason, String approver) {
		        // Implementation with safety checks
		        return String.format("Server restarted by %s: %s", approver, reason);
		    }
		}
		```
		
		### Safe vs Unsafe Invocation
		❌ Unsafe (will be blocked):
		```java
		processor.processSingleAction("Please restart the server");
		```
		
		✅ Safe (explicit invocation required):
		```java
		ServerAction action = new ServerAction();
		processor.processSingleAction(
		    "Restart server due to memory leak, approved by John Doe",
		    action
		);
		```
		
		## 6. Troubleshooting
		
		### Common Issues and Solutions
		
		1. **Incorrect Data Extraction**
		   - Make sure prompts are clear and well-structured
		   - Use the `describe` attribute to guide extraction
		   - Check field types match expected data
		
		2. **Action Selection Issues**
		   - Verify action descriptions are clear
		   - Group related actions appropriately
		   - Use explicit action invocation for certainty
		
		3. **Translation Problems**
		   - Ensure language codes are correct
		   - Check for proper encoding support
		   - Verify API keys for translation services
		
		### Debugging Tips
		
		1. Enable debug logging:
		```java
		System.setProperty("tools4ai.debug", "true");
		```
		
		2. Use the test helper:
		```java
		TestHelper.validateExtraction(prompt, expectedData);
		```
		
		3. Monitor AI processing:
		```java
		processor.setVerboseMode(true);
		```
		
		## Best Practices
		
		1. **Clear Annotations**
		   - Use descriptive group names
		   - Provide detailed action descriptions
		   - Document parameter requirements
		
		2. **Data Safety**
		   - Mark sensitive fields with `@Prompt(ignore = true)`
		   - Use HIGH risk level for dangerous operations
		   - Implement proper validation
		
		3. **Performance**
		   - Group related actions together
		   - Use appropriate data types
		   - Cache frequently used transformations]]></file>
	<file path='tutorial\3_EnterpriseIntegration.md'>
		# Enterprise Integration Guide
		
		This guide explains how to integrate A2AJava with various enterprise systems through HTTP APIs and shell scripts.
		
		## 1. HTTP Actions with Swagger/OpenAPI
		
		A2AJava can automatically convert any REST API (defined in Swagger/OpenAPI) into actions. This means you can interact with external APIs using natural language prompts.
		
		### Configuration
		
		Create a `swagger_actions.json` file to define your API endpoints:
		
		```json
		{
		  "endpoints": [
		    {
		      "swaggerurl": "https://fakerestapi.azurewebsites.net/swagger/v1/swagger.json",
		      "group": "Books Author Activity",
		      "description": "Actions for managing books, authors, photos and user activities",
		      "baseurl": "https://fakerestapi.azurewebsites.net/",
		      "id": "fakerestapi"
		    },
		    {
		      "swaggerurl": "https://petstore3.swagger.io/api/v3/openapi.json",
		      "baseurl": "https://petstore3.swagger.io/",
		      "group": "Petstore API",
		      "description": "Actions for managing pets and pet-related operations",
		      "id": "petstore"
		    },
		    {
		      "swaggerurl": "https://vishalmysore-instaservice.hf.space/v3/api-docs",
		      "baseurl": "https://vishalmysore-instaservice.hf.space/",
		      "group": "Enterprise Support and Ticketing System",
		      "description": "Actions for creating and tracking enterprise support tickets",
		      "id": "InstaService"
		    }
		  ]
		}
		```
		
		### Usage Example
		
		Here's how to use the HTTP actions in your code:
		
		```java
		@Test
		public void testHttpActionOpenAI() throws AIProcessingException, IOException {
		    // Initialize the processor
		    OpenAiActionProcessor processor = new OpenAiActionProcessor();
		    
		    // Natural language prompt to create a book
		    String postABook = "post a book harry poster with id 189 the publish date is " +
		                      "2024-03-22 and the description is about harry who likes " +
		                      "poster its around 500 pages";
		    
		    // Process the action
		    String result = (String) processor.processSingleAction(postABook);
		    
		    // Verify the result
		    Assertions.assertNotNull(result);
		    String success = TestHelperOpenAI.getInstance().sendMessage(
		        "Look at this message - " + result + " - was it a success? - Reply in true or false only"
		    );
		    Assertions.assertTrue("True".equalsIgnoreCase(success));
		}
		```
		
		The system will automatically:
		1. Parse the natural language prompt
		2. Identify the appropriate API endpoint
		3. Extract parameters from the text
		4. Make the HTTP call with the correct method and parameters
		
		## 2. Shell Action Integration
		
		A2AJava can convert shell scripts into actions that can be triggered through natural language. This is particularly useful for system administration and automation tasks.
		
		### Configuration
		
		Create a `shell_actions.yml` file to define your shell actions:
		
		```yaml
		groups:
		  - name: Employee Actions
		    description: Actions for managing employee operations
		    scripts:
		      - scriptName: "test_script.cmd"
		        actionName: saveEmployeeInformation
		        parameters: employeeName,employeeLocation
		        description: Saves new employee information to the system
		```
		
		### Usage Example
		
		```java
		// Initialize the action processor
		OpenAiActionProcessor processor = new OpenAiActionProcessor();
		
		// Natural language prompt
		String promptText = "A new employee joined today in Toronto. Her name is Madhuri Khanna";
		
		// Process the action - system will automatically determine which script to run
		processor.processSingleAction(promptText);
		```
		
		## 3. Custom HTTP Actions
		
		For REST APIs without Swagger documentation, you can define custom HTTP actions using a configuration file.
		
		### Configuration
		
		Create a `http_actions.json` file:
		
		```json
		{
		  "endpoints": [
		    {
		      "actionName": "getUserDetails",
		      "description": "Fetches user details from the corporate user inventory system",
		      "url": "https://api.example.com/users/",
		      "type": "GET",
		      "input_object": [
		        {
		          "name": "userId",
		          "type": "path_parameter",
		          "description": "User ID"
		        }
		      ],
		      "output_object": {
		        "type": "json",
		        "description": "User object"
		      },
		      "auth_interface": {
		        "type": "Bearer Token",
		        "description": "Authentication token required"
		      }
		    },
		    {
		      "actionName": "getTemperature",
		      "url": "https://api.example.com/temperature",
		      "description": "Retrieves real-time temperature from the weather API",
		      "type": "GET",
		      "input_object": [
		        {
		          "name": "locationId",
		          "type": "query_parameter",
		          "description": "Location ID"
		        }
		      ],
		      "output_object": {
		        "type": "json",
		        "description": "Real-time temperature data"
		      },
		      "auth_interface": {
		        "type": "API Key",
		        "description": "API key required"
		      }
		    }
		  ]
		}
		```
		
		### Key Features
		
		- **Automatic Parameter Extraction**: The system automatically extracts parameters from natural language prompts
		- **Authentication Support**: Built-in support for various authentication methods (Bearer Token, API Key)
		- **Flexible Input Types**: Supports both path and query parameters
		- **Type Safety**: Validates input and output types according to the configuration
		
		## Best Practices
		
		1. **Group Organization**: Organize related actions into logical groups
		2. **Clear Descriptions**: Provide detailed descriptions for actions and parameters
		3. **Error Handling**: Include proper error responses in your API definitions
		4. **Security**: Always configure appropriate authentication for production endpoints
		5. **Testing**: Test your integrations with both valid and invalid prompts
		
		## Monitoring and Debugging
		
		For monitoring API calls and debugging issues:
		- View InstaService logs: [HuggingFace Space Logs](https://huggingface.co/spaces/VishalMysore/InstaService?logs=container)
		- Use the built-in test helpers for verification
		- Enable debug logging for detailed operation tracing</file>
	<file path='tutorial\4_ImageProcessing.md'>
		# Image Processing with Tools4AI
		
		## Introduction
		
		Agentic AI systems traditionally rely on text-based inputs for function calls and tool integration, limiting their ability to understand and act in real-time, especially in dynamic or visually-rich environments. These systems lacked the capacity to autonomously process and interpret images, restricting their ability to take immediate, contextually relevant actions. However, with the integration of advanced agentic AI, these systems can now perceive visual data, reason in context, and autonomously execute tasks based on both textual and image inputs, enabling a more intuitive, responsive, and action-oriented AI experience.
		
		Tools4AI has introduced a feature that extends the functionality of AI beyond text-based interactions to include image-based action triggers.
		
		> **Note:** All the images in this example have been generated by AI and are available here for testing.
		
		## Innovative Image Recognition Integration
		
		Tools4AI uses Gemini (gemini-1.0-pro-vision) to enhance AI capabilities by enabling the system to analyze images and automatically execute relevant actions based on the visual data it processes. This development is particularly crucial in emergency management, where speed and accuracy of response can save lives and property.
		
		### Basic Image Processing Example
		
		Here's the basic code you'll need to process images and take actions:
		
		```java
		package org.example.image;
		import com.t4a.processor.AIProcessingException;
		import com.t4a.processor.GeminiImageActionProcessor;
		import com.t4a.processor.GeminiV2ActionProcessor;
		
		public class ImageActionExample {
		    public static void main(String[] args) throws AIProcessingException {
		        GeminiImageActionProcessor processor = new GeminiImageActionProcessor();
		        String imageDisription = processor.imageToText(args[0]);
		        GeminiV2ActionProcessor actionProcessor = new GeminiV2ActionProcessor();
		        Object obj = actionProcessor.processSingleAction(imageDisription);
		        String str  = actionProcessor.summarize(imageDisription+obj.toString());
		        System.out.println(str);
		    }
		}
		```
		
		### Emergency Response Example
		
		![Car Accident Scene](accident.png)
		
		When you execute the ImageActionExample with the above image as source, it correctly identifies that we need to call an ambulance. The system detects a car accident involving a blue car and a red car on a city street, with front-end and rear-end damage respectively, and a police officer present at the scene.
		
		Here's the action handler for emergency services:
		
		```java
		@Predict(actionName = "callEmergencyServices", description = "This action will be called in case of emergency", groupName = "emergency")
		public class EmergencyAction implements JavaMethodAction {
		    public String callEmergencyServices(@Prompt(describe = "Ambulance, Fire or Police") String typeOfEmergency) {
		        return typeOfEmergency+" has been called";
		    }
		}
		```
		
		### Vehicle Service Example
		
		![Flat Tire Detection](tire.png)
		
		The integration of image recognition allows Tools4AI to directly interact with other digital systems and services. For instance, detecting a flat tire from traffic camera footage can trigger a roadside assistance call.
		
		```java
		@Predict(actionName = "carRepairService", description = "This action will be called in case of car servicing", groupName = "car services")
		public class CarServiceAction implements JavaMethodAction {
		    public String carRepairService(String typeOfProblem) {
		        return typeOfProblem+" has been found and will be fixed";
		    }
		}
		```
		
		### Fire Emergency Example
		
		![House Fire Scene](fire.png)
		
		Tools4AI correctly identifies and calls the emergency services when it detects a house fire. The system can recognize a building engulfed in flames and automatically alert fire services.
		
		## Key Benefits
		
		1. **Direct Action from Visual Cues**: Whether it's a surveillance image of a car accident or a live feed of a residential fire, Tools4AI can immediately recognize critical situations and initiate appropriate emergency protocols without human input.
		
		2. **Reduced Dependency on Textual Reports**: By reducing the reliance on text-based alerts, Tools4AI allows for a more agile response strategy, directly linking what the camera "sees" to the necessary emergency service.
		
		3. **Scalable and Versatile Applications**: The technology is scalable across multiple environments, enhancing security and response mechanisms in both public and private sectors.
		
		## Future Applications
		
		The potential applications of image recognition combined with function calling are vast:
		
		- **Healthcare**: Analysis of x-rays or MRI scans to automatically identify abnormalities
		- **Retail**: Visual search capabilities for product identification and recommendations
		- **Security**: Automated detection of unauthorized access or suspicious activities
		- **Environmental Monitoring**: Tracking landscape changes, wildlife, and environmental violations
		- **Smart Homes and IoT**: Resident identification and safety hazard monitoring
		- **Agriculture**: Crop health assessment, yield prediction, and pest infestation detection
		
		## Complete Implementation Example
		
		```java
		package org.example.image;
		
		import com.t4a.annotations.Action;
		import com.t4a.annotations.Predict;
		import com.t4a.annotations.Prompt;
		import com.t4a.api.JavaMethodAction;
		
		@Predict(groupDescription = "This group will be called in case of emergency", groupName = "emergency")
		public class EmergencyAction {
		    @Action(description = "This action will be called in case of emergency")
		    public String callEmergencyServices(@Prompt(describe = "Ambulance, FireTruck or Police") String typeOfEmergency,
		                                      boolean isEmergencyVehicleOnScene) {
		        if(isEmergencyVehicleOnScene) {
		            return typeOfEmergency + " has not been called since its already on scene";
		        } else {
		            return typeOfEmergency + " has been called since it was not there on scene";
		        }
		    }
		}</file>
	<file path='tutorial\5_UISeleniumI.md'><![CDATA[
		# AI-Powered UI Testing with Tools4AI and Selenium
		
		## Introduction
		
		Automated UI testing has long been a staple in ensuring that web applications meet design and functionality standards. Traditional methods, such as using Selenium, involve interacting with the UI through specific code tied to the structure of the webpage. However, a new AI-driven method using Tools4AI is changing the game by allowing us to translate visual elements directly into code objects, simplifying the testing process considerably.
		
		> **Note**: For background on image-based function calls, see the [previous article on Image Processing](4_ImageProcessing.md).
		
		## Comparing Traditional and AI-Driven Approaches
		
		### The Traditional Selenium Way
		
		Let's start with a simple example of testing a website for an auto repair shop. With traditional Selenium, you might write code like this to check service prices:
		
		```java
		WebElement oilChangePrice = driver.findElement(By.id("oilChangePrice"));
		assert "29.99".equals(oilChangePrice.getText());
		```
		
		Conventionally, to verify that the "Full Inspection" service on the AutoServicingPro website is listed as "Starting at $99.99," you would:
		1. Use Selenium to locate the web element
		2. Extract the text from the element
		3. Assert the value against your expected text
		
		While this method works, it has drawbacks - any change to the website's layout could break your test, requiring code updates.
		
		### The AI-Based Method
		
		![Auto Repair Shop Screenshot](auto.png)
		
		First, capture the screenshot using Selenium:
		
		```java
		WebDriverManager.chromedriver().setup();
		
		ChromeOptions options = new ChromeOptions();
		options.addArguments("--headless");  // Setting headless mode
		options.addArguments("--disable-gpu");  // GPU hardware acceleration isn't useful in headless mode
		options.addArguments("--window-size=1920,1080");  // Set the window size
		WebDriver driver = new ChromeDriver(options);
		
		driver.get("https://google.com");
		// Take screenshot and save it as file or use as bytes
		TakesScreenshot ts = (TakesScreenshot) driver;
		byte[] screenshotBytes = ts.getScreenshotAs(OutputType.BYTES);
		GeminiImageActionProcessor imageActionProcessor = new GeminiImageActionProcessor();
		imageActionProcessor.imageToText(screenshotBytes);
		// Alternatively, save to file:
		// File srcFile = ts.getScreenshotAs(OutputType.FILE);
		// File destFile = new File("screenshot.png");
		// FileHandler.copy(srcFile, destFile);
		driver.quit();
		```
		
		Then process the image with Tools4AI:
		
		```java
		String jsonStr = processor.imageToJson(
		    GeminiImageExample.class.getClassLoader().getResource("auto.png"),
		    "Full Inspection"
		);
		```
		
		The returned JSON will look like this:
		
		```json
		{
		  "fieldName": "Full Inspection",
		  "fieldType": "String",
		  "fieldValue": "Starting at $99.99"
		}
		```
		
		This JSON can be easily validated against a "golden copy" when UI changes occur.
		
		#### Option 2: POJO-Based Approach
		
		Define your POJO structure:
		
		```java
		@Getter
		@Setter
		@ToString
		@NoArgsConstructor
		@AllArgsConstructor
		public class AutoRepairScreen {
		    double fullInspectionValue;
		    double tireRotationValue;
		    double oilChangeValue;
		    Integer phoneNumber;
		    String email;
		    String[] customerReviews;
		}
		```
		
		Then use it directly with Tools4AI:
		
		```java
		AutoRepairScreen screenData = aiProcessor.imageToPojo("screenshot.png", AutoRepairScreen.class);
		assert screenData.oilChangePrice == 29.99;
		```
		
		## Real-World Example: Gym Schedule Testing
		
		![Gym Schedule Screenshot](fitness.png)
		
		Let's explore a more complex example with a gym schedule. This example demonstrates how visual information can be transformed into structured Java objects.
		
		### The POJO Structure
		
		```java
		@Getter
		@Setter
		@NoArgsConstructor
		@ToString
		public class MyGymSchedule {
		    @ListType(Activity.class)
		    List<Activity> myWeeklyActivity;
		}
		
		@Getter
		@Setter
		@NoArgsConstructor
		@ToString
		public class Activity {
		    String dayOfTheWeek;
		    String activityName;
		}
		```
		
		### Processing the Schedule
		
		```java
		GeminiImageActionProcessor processor = new GeminiImageActionProcessor();
		Object pojo = processor.imageToPojo(
		    GeminiImageExample.class.getClassLoader().getResource("fitness.png"),
		    MyGymSchedule.class
		);
		log.info(pojo.toString());
		```
		
		The processed output will contain the full weekly schedule:
		
		```
		MyGymSchedule(myWeeklyActivity=[
		    Activity(dayOfTheWeek=Monday, activityName=LES MILLS VIRTUAL RPM),
		    Activity(dayOfTheWeek=Monday, activityName=VIRTUAL NEWBODY),
		    Activity(dayOfTheWeek=Tuesday, activityName=VIRTUAL NEWBODY),
		    Activity(dayOfTheWeek=Wednesday, activityName=VIRTUAL ATHLETIC RIDE),
		    Activity(dayOfTheWeek=Thursday, activityName=VIRTUAL CYCLING),
		    Activity(dayOfTheWeek=Friday, activityName=VIRTUAL AWESOME ABS),
		    Activity(dayOfTheWeek=Friday, activityName=VIRTUAL NEWBODY),
		    Activity(dayOfTheWeek=Saturday, activityName=AQUAFIT),
		    Activity(dayOfTheWeek=Sunday, activityName=AQUAFIT)
		])
		```
		
		## Complete Example
		
		Here's a complete example showing various ways to use the Tools4AI image processing capabilities:
		
		```java
		public static void main(String[] args) throws AIProcessingException {
		    GeminiImageActionProcessor processor = new GeminiImageActionProcessor();
		    
		    // Single field extraction
		    String jsonStr = processor.imageToJson(
		        GeminiImageExample.class.getClassLoader().getResource("images/auto.png"),
		        "Full Inspection"
		    );
		    log.info(jsonStr);
		    
		    // Multiple field extraction
		    jsonStr = processor.imageToJson(
		        GeminiImageExample.class.getClassLoader().getResource("images/auto.png"),
		        "Full Inspection", "Tire Rotation", "Oil Change"
		    );
		    log.info(jsonStr);
		    
		    // Full POJO conversion for auto repair screen
		    jsonStr = processor.imageToJson(
		        GeminiImageExample.class.getClassLoader().getResource("images/auto.png"),
		        AutoRepairScreen.class
		    );
		    log.info(jsonStr);
		    
		    // Full POJO conversion for fitness schedule
		    jsonStr = processor.imageToJson(
		        GeminiImageExample.class.getClassLoader().getResource("images/fitness.png"),
		        MyGymSchedule.class
		    );
		    log.info(jsonStr);
		    
		    // Direct POJO creation from images
		    Object pojo = processor.imageToPojo(
		        GeminiImageExample.class.getClassLoader().getResource("images/fitness.png"),
		        MyGymSchedule.class
		    );
		    log.info(pojo.toString());
		    
		    pojo = processor.imageToPojo(
		        GeminiImageExample.class.getClassLoader().getResource("images/auto.png"),
		        AutoRepairScreen.class
		    );
		    log.info(pojo.toString());
		}
		```
		
		## Conclusion
		
		Tools4AI exemplifies how AI can simplify complex processes, offering a glimpse into a future where AI and machine learning continually reduce the manual workload in software development and quality assurance. Whether you're dealing with a photo or a screenshot from a website, the method remains the same, providing quick and accurate digitization of information that was once locked in static images.]]></file>
	<file path='tutorial\6_SpringAndSelenium.md'>
		# Spring and Selenium Integration Guide
		
		## Selenium Integration
		
		Tools4AI's integration with Selenium introduces a flexible way to automate UI testing. Instead of traditional Java code for Selenium scripts, Tools4AI allows you to define test scenarios in plain English, offering a more accessible approach to testing web applications. These English-based commands can be converted into Selenium code to automate web-based interactions and streamline testing.
		
		### Example of Selenium Test with Tools4AI
		
		```java
		WebDriver driver = new ChromeDriver(options);
		SeleniumProcessor processor = new SeleniumProcessor(driver);
		processor.processWebAction("go to website https://the-internet.herokuapp.com");
		boolean buttonPresent = processor.trueFalseQuery("do you see Add/Remove Elements?");
		if(buttonPresent) {
		    processor.processWebAction("click on Add/Remove Elements");
		    // perform other function in simple english
		} 
		//else {
		//    processor.processSingleAction("Create Jira by taking screenshot");
		//}
		
		processor.processWebAction("go to website https://the-internet.herokuapp.com");
		boolean isCheckboxPresent = processor.trueFalseQuery("do you see Checkboxes?");
		if(isCheckboxPresent) {
		    processor.processWebAction("click on Checkboxes");
		    processor.processWebAction("select checkbox 1");
		}
		```
		
		In this example, the SeleniumProcessor processes commands in plain English and converts them into Selenium actions. This approach allows for complex interactions without manually writing Java code for each test. Tools4AI serves as a bridge between natural language and Selenium, making it easier to automate UI testing in a way that is both efficient and intuitive.
		
		This integration offers substantial benefits for teams looking to streamline their UI validation process. By enabling a more straightforward way to define and execute Selenium scripts, Tools4AI provides a flexible framework for automating Selenium-based tests.
		
		## Spring Integration
		
		All the action processors have Spring integration as well:
		
		```java
		SpringAnthropicProcessor springAnthropic = new SpringAnthropicProcessor(applicationContext);
		SpringGeminiProcessor springGemini = new SpringGeminiProcessor();
		SpringOpenAIProcessor springOpenAI = new SpringOpenAIProcessor();
		```
		
		You can use this for spring injection and it works exactly as all other action processors. The only difference is that instead of creating new action beans it will reuse the beans already created by spring.
		
		### Example Implementation
		
		Here are some example implementations showing how to use Spring with Tools4AI:
		
		#### SAM Controller Example
		```java
		package io.github.vishalmysore;
		
		import com.t4a.api.ActionGroup;
		import com.t4a.api.GroupInfo;
		import com.t4a.predict.GeminiPromptTransformer;
		import com.t4a.predict.PredictionLoader;
		import com.t4a.predict.PromptTransformer;
		import com.t4a.processor.*;
		import io.swagger.annotations.ApiResponses;
		import io.swagger.v3.oas.annotations.Operation;
		import lombok.extern.java.Log;
		import io.github.vishalmysore.pojo.Customer;
		import io.github.vishalmysore.pojo.RestaurantPojo;
		import io.github.vishalmysore.service.RestaurantBookingService;
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.context.ApplicationContext;
		import org.springframework.web.bind.annotation.*;
		
		import java.util.List;
		
		@Log
		@RestController
		public class SAMController {
		    @Autowired
		    private ApplicationContext applicationContext;
		    @Autowired
		    private RestaurantBookingService restaurantBookingService;
		
		    @Operation(summary = "Execute any action based on prompt", 
		              description = "Try out with any of these prompts:\n" +
		                          "1) My Customer name is Vishal, his computer needs repair\n" +
		                          "2) Can you compare Honda City to Toyota Corolla\n" +
		                          "3) Can i Go out without Jacket in Toronto today\n" +
		                          "4) what would vishal want to eat today?")
		    public String actOnPrompt(@RequestParam("prompt") String prompt) {
		        AIProcessor processor = new SpringGeminiProcessor(applicationContext);
		        try {
		            return (String) processor.processSingleAction(prompt);
		        } catch (AIProcessingException e) {
		            throw new RuntimeException(e);
		        }
		    }
		
		    // ... other controller methods ...
		}
		
		#### Service Examples
		
		```java
		@Service
		@Log
		@Predict(actionName ="compareCar", description = "Provide 2 cars and compare them")
		public class CompareCarService implements JavaMethodAction {
		    public CompareCarService() {
		        log.info("created compare car service");
		    }
		    
		    public String compareCar(String car1, String car2) {
		        log.info(car2);
		        log.info(car1);
		        // implement the comparison logic here
		        return "this is better - " + car2;
		    }
		}
		
		@Log
		@Service
		public class RestaurantBookingService {
		    public RestaurantBookingService() {
		        log.info("created RestaurantBookingService");
		    }
		    
		    public String bookReservation(RestaurantPojo restaurantPojo) {
		        log.info(restaurantPojo.toString());
		        return "This has been booked " + restaurantPojo.toString();
		    }
		}</file>
	<file path='tutorial\7_HandlingRisksinAgents.md'>
		# Handling Risks in A2A Java Agents
		
		## Overview
		
		A2ajava uses the tools4ai library for converting Java methods to A2A tasks or MCP tools. Each method annotated with `@Action` becomes a task or a tool which can be called by an A2A client or an MCP client.
		
		## Risk Categorization in Tools4AI
		
		In Tools4AI, actions are classified into three levels of risk:
		
		```java
		public enum ActionRisk {
		    LOW, MEDIUM, HIGH
		}
		```
		
		By default, every action is considered `LOW` risk unless explicitly specified otherwise. This provides a baseline for assessing AI agent behavior and implementing necessary safeguards.
		
		## Defining Actions with Risk Levels
		
		Tools4AI uses the `@Action` annotation to mark methods as callable by AI agents while specifying their risk level:
		
		```java
		package com.t4a.annotations;
		import com.t4a.api.ActionRisk;
		import java.lang.annotation.ElementType;
		import java.lang.annotation.Retention;
		import java.lang.annotation.RetentionPolicy;
		import java.lang.annotation.Target;
		
		/**
		 * This annotation marks a method as an action which can be called by AI.
		 */
		@Retention(RetentionPolicy.RUNTIME)
		@Target(ElementType.METHOD)
		public @interface Action {
		    String description() default "";
		    ActionRisk riskLevel() default ActionRisk.LOW;
		}
		```
		
		## Examples of Risk Levels in Action
		
		### Example 1: Comparing Cars (Low Risk)
		
		```java
		@Service
		@Log
		@Agent
		public class CompareCarService {
		    public CompareCarService() {
		        log.info("Created CompareCarService");
		    }
		
		    @Action(description = "Compare two cars", riskLevel = ActionRisk.LOW)
		    public String compareCar(String car1, String car2) {
		        log.info(car1);
		        log.info(car2);
		        // Implement the comparison logic here
		        return "This is better - " + car2;
		    }
		}
		```
		
		### Example 2: Comparing and Placing an Order (High Risk)
		
		```java
		@Agent
		public class CompareCarService {
		    public CompareCarService() {
		        log.info("Created CompareCarService");
		    }
		
		    @Action(description = "Compare two cars", riskLevel = ActionRisk.LOW)
		    public String compareCar(String car1, String car2) {
		        log.info(car1);
		        log.info(car2);
		        // Implement the comparison logic here
		        return "This is better - " + car2;
		    }
		    
		    @Action(description = "Place an order for the car", riskLevel = ActionRisk.HIGH)
		    public String compareAndPlaceOrder(String car1, String car2) {
		        log.info(car1);
		        log.info(car2);
		        // Implement the order placement logic here
		        return "This is better, so sending a buy order - " + car2;
		    }
		}
		```
		
		## Benefits of Risk-Based Action Management
		
		1. **Improved AI Safety**: Prevents unintended execution of critical actions
		2. **Transparency and Accountability**: Enables developers to audit and control AI decisions
		3. **Granular Control**: Different actions can have different risk levels
		4. **Regulatory Compliance**: Helps meet legal and ethical standards
		
		## Complex Example: Vehicle Management Service
		
		```java
		@Agent
		public class VehicleManagementService {
		    public VehicleManagementService() {
		        log.info("Created VehicleManagementService");
		    }
		
		    @Action(description = "Check vehicle status", riskLevel = ActionRisk.LOW)
		    public String checkVehicleStatus(String vehicleId) {
		        log.info("Checking status for vehicle: " + vehicleId);
		        return "Vehicle " + vehicleId + " is in good condition.";
		    }
		    
		    @Action(description = "Schedule a service appointment", riskLevel = ActionRisk.MEDIUM)
		    public String scheduleService(String vehicleId, String date) {
		        log.info("Scheduling service for vehicle: " + vehicleId + " on " + date);
		        return "Service for vehicle " + vehicleId + " scheduled on " + date;
		    }
		    
		    @Action(description = "Initiate payment for service", riskLevel = ActionRisk.HIGH)
		    public String initiatePayment(String vehicleId, double amount) {
		        log.info("Initiating payment of " + amount + " for vehicle: " + vehicleId);
		        return "Payment of " + amount + " initiated for vehicle " + vehicleId;
		    }
		}
		```
		
		## Processing Actions with Risk Management
		
		High-risk actions require explicit human approval before execution:
		
		```java
		public Object processSingleAction(String prompt, AIAction action, 
		    HumanInLoop humanVerification, ExplainDecision explain) throws AIProcessingException {
		    if (action == null) {
		        action = PredictionLoader.getInstance().getPredictedAction(prompt, AIPlatform.OPENAI);
		        
		        if (action == null) {
		            return "No action found for the prompt: " + prompt;
		        }
		
		        if (action.getActionRisk() == ActionRisk.HIGH) {
		            log.warn("This is a high-risk action and requires explicit approval.");
		            return "This is a high-risk action and will not proceed without human intervention: " 
		                   + action.getActionName();
		        }
		    }
		    // ... rest of the processing logic
		}
		```
		
		## Advanced Risk Management Frameworks
		
		For enterprise-level AI systems, it's recommended to integrate with advanced risk management frameworks:
		
		### 1. PASTA (Process for Attack Simulation and Threat Analysis)
		- Risk-centric threat modeling methodology
		- Designed for simulating and assessing potential threats to AI systems
		
		### 2. LINDDUN
		- Privacy threat modeling framework
		- Focuses on identifying and mitigating privacy risks
		
		### 3. OCTAVE
		- Comprehensive risk management approach
		- Identifies critical assets and vulnerabilities
		
		### 4. Trike
		- Threat modeling methodology based on stakeholder interests
		- Particularly suited for complex, multi-agent systems
		
		### 5. VAST (Visual, Agile, and Simple Threat)
		- Visual and agile threat modeling framework
		- Simplifies security risk assessment
		
		### 6. NIST AI Risk Management Framework (AI RMF)
		- Comprehensive framework for AI risk management
		- Emphasizes transparency, accountability, and trust
		
		### 7. Google's Secure AI Framework (SAIF)
		- Focuses on securing AI systems throughout their lifecycle
		- Ensures safety and trustworthiness
		
		### 8. MASTERO
		- Assesses risks and vulnerabilities
		- Provides proactive approach to threat identification
		
		### 9. STRIDE
		- Identifies six key security threat categories:
		  - Spoofing
		  - Tampering
		  - Repudiation
		  - Information Disclosure
		  - Denial of Service
		  - Elevation of Privilege
		
		### 10. OWASP Top 10 for LLM Applications
		- Curated by Open Web Application Security Project
		- Highlights critical security risks in LLM applications
		- Essential guide for developers and security professionals</file>
	<file path='tutorial\8_HumanInLoop.md'><![CDATA[
		# Human In Loop Integration
		
		## Overview
		
		A2AJava uses Tools4AI which provides a simple but efficient mechanism for human validation. Any high-risk actions or actions marked for human validation are sent via this callback.
		
		This API can be extended to perform validation actions using:
		- Spring state machine
		- Any workflow library
		
		The tasks can be stored in DB or file system in pending state with task ID and then picked up when the human validation is done.
		
		## Key Interfaces
		
		### HumanInLoop Interface
		
		This interface provides a mechanism for allowing human involvement in a feedback loop process.
		
		```java
		package com.t4a.detect;
		
		import java.util.Map;
		
		/**
		 * The {@code HumanInLoop} interface represents a mechanism for allowing human involvement
		 * in a feedback loop process.
		 * <p>
		 * This interface defines a method {@link #allow(String, String, Map)} that can be used
		 * to request human input for a given prompt text and method name with optional parameters.
		 * </p>
		 */
		public interface HumanInLoop {
		    public FeedbackLoop allow(String promptText, String methodName, Map<String, Object> params);
		    public FeedbackLoop allow(String promptText, String methodName, String params);
		
		    default void setCallback(ActionCallback callback) {
		    }
		    
		    default ActionCallback getCallback() {
		        return null;
		    }
		}
		```
		
		### ExplainDecision Interface
		
		This interface allows AI to explain its decision-making process.
		
		```java
		package com.t4a.detect;
		
		/**
		 * The {@code ExplainDecision} interface represents a mechanism for AI to explain decisions
		 * regarding a particular prompt text, method name, and reason. AI will call this back
		 * <p>
		 * This interface defines a method {@link #explain(String, String, String)} that can be used
		 * to provide an explanation by AI to a human regarding a decision made based on a prompt text,
		 * method name, and reason.
		 * </p>
		 */
		public interface ExplainDecision {
		    public String explain(String promptText, String methodName, String reason);
		}
		```
		
		## Spring State Machine Integration Example
		
		Below is an example of how to integrate Spring State Machine with the Human-in-Loop functionality to manage approval workflows:
		
		### 1. Define States and Events
		
		```java
		public enum ApprovalStates {
		    PENDING,
		    UNDER_REVIEW,
		    APPROVED,
		    REJECTED
		}
		
		public enum ApprovalEvents {
		    SUBMIT,
		    START_REVIEW,
		    APPROVE,
		    REJECT
		}
		```
		
		### 2. Configure State Machine
		
		```java
		@Configuration
		@EnableStateMachine
		public class ApprovalStateMachineConfig extends StateMachineConfigurerAdapter<ApprovalStates, ApprovalEvents> {
		
		    @Override
		    public void configure(StateMachineStateConfigurer<ApprovalStates, ApprovalEvents> states) throws Exception {
		        states
		            .withStates()
		            .initial(ApprovalStates.PENDING)
		            .states(EnumSet.allOf(ApprovalStates.class));
		    }
		
		    @Override
		    public void configure(StateMachineTransitionConfigurer<ApprovalStates, ApprovalEvents> transitions) throws Exception {
		        transitions
		            .withExternal()
		                .source(ApprovalStates.PENDING)
		                .target(ApprovalStates.UNDER_REVIEW)
		                .event(ApprovalEvents.START_REVIEW)
		                .and()
		            .withExternal()
		                .source(ApprovalStates.UNDER_REVIEW)
		                .target(ApprovalStates.APPROVED)
		                .event(ApprovalEvents.APPROVE)
		                .and()
		            .withExternal()
		                .source(ApprovalStates.UNDER_REVIEW)
		                .target(ApprovalStates.REJECTED)
		                .event(ApprovalEvents.REJECT);
		    }
		}
		```
		
		### 3. Integrate with HumanInLoop
		
		```java
		@Service
		@WithStateMachine
		public class ApprovalWorkflowService implements HumanInLoop {
		    
		    @Autowired
		    private StateMachine<ApprovalStates, ApprovalEvents> stateMachine;
		    
		    private ActionCallback callback;
		    
		    @Override
		    public FeedbackLoop allow(String promptText, String methodName, Map<String, Object> params) {
		        // Start the approval process
		        stateMachine.sendEvent(ApprovalEvents.START_REVIEW);
		        
		        // Create feedback loop with state machine integration
		        return new FeedbackLoop() {
		            @Override
		            public void onApprove() {
		                stateMachine.sendEvent(ApprovalEvents.APPROVE);
		                if (callback != null) {
		                    callback.onComplete(ActionState.APPROVED);
		                }
		            }
		            
		            @Override
		            public void onReject() {
		                stateMachine.sendEvent(ApprovalEvents.REJECT);
		                if (callback != null) {
		                    callback.onComplete(ActionState.REJECTED);
		                }
		            }
		        };
		    }
		    
		    @Override
		    public void setCallback(ActionCallback callback) {
		        this.callback = callback;
		    }
		}
		```
		
		### 4. Using the State Machine Workflow
		
		```java
		@RestController
		@RequestMapping("/api/approvals")
		public class ApprovalController {
		
		    @Autowired
		    private ApprovalWorkflowService approvalService;
		    
		    @PostMapping("/submit")
		    public ResponseEntity<String> submitForApproval(@RequestBody Map<String, Object> request) {
		        FeedbackLoop feedback = approvalService.allow(
		            "High-risk operation requiring approval",
		            "performAction",
		            request
		        );
		        
		        // The state machine will track the approval workflow
		        return ResponseEntity.ok("Request submitted for approval");
		    }
		}
		```
		
		This integration provides several benefits:
		- Clear separation of states and transitions
		- Automatic state management
		- Integration with existing HumanInLoop interface
		- Scalable workflow management
		- Audit trail of state transitions
		
		You can extend this further by:
		- Adding persistence for state machine
		- Implementing event listeners for state transitions
		- Adding timeout handling
		- Integrating with notification systems]]></file>
	<file path='tutorial\9_Kubernetes.md'>
		# Kubernetes Management with A2A and MCP Integration
		
		## Overview
		
		This guide demonstrates how to use Tools4AI's A2A (Agent-to-Agent) and MCP (Model Context Protocol) capabilities to manage Kubernetes clusters through natural language. By combining A2A's agent communication capabilities with MCP's LLM integration, we can create a powerful interface for Kubernetes management.
		
		## Integration Architecture
		
		### A2A Integration
		
		The A2A protocol enables agent-to-agent communication for Kubernetes management through:
		
		```java
		@Service
		public class KubernetesAgentController implements A2ATaskController {
		    @Autowired
		    private ApplicationContext applicationContext;
		    
		    @Override
		    public SendTaskResponse sendTask(TaskSendParams taskSendParams, ActionCallback callback) {
		        // Process Kubernetes commands using natural language
		        return processKubernetesTask(taskSendParams, callback);
		    }
		}
		```
		
		### MCP Integration
		
		MCP tools can be exposed for Kubernetes operations through annotations:
		
		```java
		@Predict(actionName = "deploymentUpgrade", 
		        description = "Upgrade a Kubernetes deployment to a new version")
		public class KubernetesDeploymentService implements JavaMethodAction {
		    public String upgradeDeployment(String deploymentName, String version) {
		        // Implementation for deployment upgrade
		    }
		}
		```
		
		## Configuration Example
		
		Configure Kubernetes endpoints in your A2A/MCP server:
		
		```json
		{
		  "endpoints": [
		    {
		      "swaggerurl": "https://your-k8s-cluster/openapi/v2",
		      "baseurl": "https://your-k8s-cluster",
		      "id": "production-cluster",
		      "headers": [
		        {
		          "key": "Authorization",
		          "value": "Bearer ${K8S_TOKEN}"
		        }
		      ]
		    }
		  ]
		}
		```
		
		## Advanced Usage Examples
		
		### Scenario 1: Deployment Management via A2A
		
		Using A2A's natural language processing capabilities for deployment management:
		
		```java
		// Client-side code
		TaskClient k8sClient = new TaskClient("http://localhost:8080/rpc");
		Task upgradeTask = k8sClient.sendTask(
		    "Upgrade the payment-service deployment to version 2.0"
		);
		```
		
		The A2A server processes this through:
		1. Natural language understanding via MCP
		2. Conversion to Kubernetes API calls
		3. Real-time status updates via SSE
		
		### Scenario 2: Automated Rollbacks with MCP Integration
		
		Combining MCP's decision-making with A2A's task management:
		
		```java
		@Predict(actionName = "rollbackDeployment", 
		        description = "Analyze and rollback problematic deployments")
		public class KubernetesRollbackService {
		    public String analyzeAndRollback(String deploymentName) {
		        // MCP-powered analysis of deployment health
		        // Automatic rollback if issues detected
		    }
		}
		```
		
		### Scenario 3: Intelligent Autoscaling
		
		Using MCP's LLM capabilities for smart autoscaling decisions:
		
		```java
		@Predict(actionName = "configureAutoscaling",
		        description = "Set up intelligent autoscaling based on application patterns")
		public class KubernetesAutoScalingService {
		    public String setupAutoscaling(String deployment, 
		                                 String metrics, 
		                                 int minPods, 
		                                 int maxPods) {
		        // MCP-powered analysis for optimal scaling parameters
		    }
		}
		```
		
		## Benefits of A2A/MCP Integration
		
		1. **Natural Language Operations**: Manage Kubernetes through simple English commands
		2. **Intelligent Decision Making**: Use MCP's LLM capabilities for complex operational decisions
		3. **Real-time Updates**: Leverage A2A's SSE capabilities for live operation status
		4. **Automated Problem Resolution**: Combine A2A and MCP for autonomous issue detection and resolution
		
		## Error Handling and Monitoring
		
		The integration provides robust error handling through both A2A and MCP protocols:
		
		```java
		@Override
		public void sendtStatus(String status, ActionState state) {
		    // A2A status updates for Kubernetes operations
		    this.status = status;
		    TaskState taskState = TaskState.valueOf(state.name());
		    // Update operation status
		}
		```
		
		## Security Considerations
		
		1. Use A2A's authentication mechanisms for secure agent communication
		2. Implement MCP's capability controls for restricted operations
		3. Maintain Kubernetes RBAC integration through proper service account configuration</file>
	<file path='tutorial\mcp\11_MCP.md'><![CDATA[
		# MCP Server in Java with a2ajava – The Swiss Knife for Agentic Applications
		
		## Overview
		
		Let's build a lightweight Model Context Protocol (MCP) server in Java using the powerful and flexible a2ajava library. The a2ajava library is a "swiss knife" for building agentic applications in multiple languages such as Java and Kotlin, supporting multiple protocols.
		
		![Available Tools in MCP Server](toolsList.png)
		
		### Key Features 🚀
		
		- ✅ **Cross-protocol**: Supports both MCP (Model Context Protocol) and Google A2A (Agent-to-Agent)
		- ✅ **Cross-platform**: Runs on any OS with JVM support
		- ✅ **Cross-language**: Compatible with clients built in JavaScript, Python, or even LLM agents like Claude and Google A2A client
		- ✅ **Flexible Implementation**: Use Spring Boot, Quarkus, or pure Java/Kotlin
		
		![Tools Interface Example](tools1.png)
		
		## Implementation Guide
		
		### Step 1: Create Basic Agent
		
		Create a simple Java class to handle MCP requests. Here's a basic example:
		
		
		```java
		@Service
		@Log
		@Agent(groupName ="raiseTicket", groupDescription = "Create a ticket for customer")
		public class RaiseCustomerTicket {
		    @Action(description = "Raise a ticket for customer")
		    public String raiseTicket(String customerName) {
		        return "ticket 111 raised for " + customerName;
		    }
		}
		```
		
		> **Note**: If you're not using Spring/Spring Boot, you can ignore the `@Service` annotation and directly use `@Agent` and `@Action` annotations.
		
		![Chat Interface Example](chat1.png)
		
		### Step 2: Create MCP Controller
		
		Create a controller by extending `MCPToolsController`. This handles the MCP protocol endpoints:
		
		```java
		@Log
		@RestController
		@RequestMapping("/mcp")
		public class MCPController extends MCPToolsController {
		    // Base configuration endpoint
		    @GetMapping("/server-config")
		    public ResponseEntity<Map<String, String>> getServerConfig() {
		        return super.getServerConfig();
		    }
		
		    // Tool listing endpoint
		    @GetMapping("/list-tools")
		    public ResponseEntity<Map<String, List<Tool>>> listTools() {
		        Map<String, List<Tool>> response = new HashMap<>();
		        response.put("tools", super.getToolsResult().getTools());
		        return ResponseEntity.ok(response);
		    }
		
		    // Tool execution endpoint
		    @PostMapping("/call-tool")
		    public ResponseEntity<JSONRPCResponse> callTool(@RequestBody ToolCallRequest request) {
		        CallToolResult result = super.callTool(request, new MCPActionCallback());
		        JSONRPCResponse response = new JSONRPCResponse();
		        response.setId("133");
		        response.setResult(result);
		        return ResponseEntity.ok(response);
		    }
		}
		```
		
		### Step 3: Configure package.json
		
		Create a `package.json` file for the Node.js components:
		
		```json
		{
		  "name": "mcp-sqlagent-server",
		  "version": "0.1.1",
		  "description": "MCP server for interacting with SQL databases.",
		  "license": "MIT",
		  "type": "module",
		  "dependencies": {
		    "@modelcontextprotocol/sdk": "^1.0.3"
		  }
		}
		```
		
		### Step 4: Create mcpserver.js
		
		This file handles the communication between your Java server and MCP clients:
		
		```javascript
		import { Server } from "@modelcontextprotocol/sdk/server/index.js";
		import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
		
		const SERVER_BASE_URL = process.env.SERVER_BASE_URL || "http://localhost:7860";
		
		const server = new Server({
		  name: "springboot-proxy",
		  version: "1.0.0",
		}, {
		  capabilities: {
		    tools: {},
		  },
		});
		
		// Tool listing handler
		server.setRequestHandler(ListToolsRequestSchema, async () => {
		  const response = await fetch("http://localhost:7860/mcp/list-tools");
		  const data = await response.json();
		  return { tools: data.tools };
		});
		
		// Tool execution handler
		server.setRequestHandler(CallToolRequestSchema, async (request) => {
		  const response = await fetch("http://localhost:7860/mcp/call-tool", {
		    method: "POST",
		    headers: { "Content-Type": "application/json" },
		    body: JSON.stringify({
		      name: request.params.name,
		      arguments: request.params.arguments ?? {},
		    }),
		  });
		  const data = await response.json();
		  return data.result;
		});
		
		// Launch server
		async function runServer() {
		  const transport = new StdioServerTransport();
		  await server.connect(transport);
		}
		
		runServer().catch(console.error);
		```
		
		### Step 5: Claude Desktop Configuration
		
		Add the following configuration to your Claude Desktop settings:
		
		```json
		{
		  "customerserviceagent": {
		    "command": "node",
		    "args": [
		      "/work/springactions/src/main/resources/mcpserver.js"
		    ]
		  }
		}
		```
		
		![Car Service Example](car.png)
		
		## Testing Your Server
		
		Once you start the server, you can verify the available tools by visiting:
		http://localhost:7860/mcp/list-tools
		
		The response will show all registered tools with their descriptions and input schemas.
		
		## Next Steps
		
		1. Add more tools and agents to expand functionality
		2. Implement error handling and logging
		3. Add authentication if needed
		4. Create client applications to interact with your MCP server
		
		For the complete source code and more examples, visit the GitHub repository.]]></file>
	<file path='tutorial\Tools4AI.MD'>
		# Configuration Guide
		
		## ✅ Gemini Related Settings
		These settings configure the use of Google's Gemini models.
		
		- **gemini.modelName**: Specifies the main Gemini model to use (e.g., gemini-2.0-flash-001).
		- **gemini.location**: The regional location for the Gemini service (e.g., us-central1).
		- **gemini.projectId**: Google Cloud project ID associated with the Gemini API.
		- **gemini.vision.modelName**: Specifies the Gemini Vision model for image-related tasks (e.g., gemini-1.0-pro-vision).
		
		## 🧠 Anthropic (Claude) Related Settings
		These are settings for integrating with Anthropic's Claude models.
		
		- **anthropic.modelName**: The Claude model to use (e.g., claude-3-haiku-20240307).
		- **anthropic.logRequests**: If set to true, the system logs requests made to Claude.
		- **anthropic.logResponse**: If true, logs the response from Claude.
		- **claudeKey**: API key for authenticating with Claude; can be set in the properties file or passed as a JVM argument (-DclaudeKey).
		
		## 🔓 OpenAI Related Settings
		These define how to connect to OpenAI models.
		
		- **openAiKey**: API key for OpenAI. Can be set here or passed as a JVM option (-DopenAiKey).
		- **openAiBaseURL**: Base URL for OpenAI requests. Useful when using a proxy or custom endpoint (e.g., Langchain4j).
		- **openAiModelName**: The OpenAI model to use (e.g., gpt-4o-mini).
		
		## 🔍 Serper (Google Search/Hallucination Detection)
		- **serperKey**: API key for Serper, a service used for Google Search or hallucination detection. If empty, the feature may be disabled.
		
		## 🧠 Agent Provider Configuration
		- **agent.provider**: Indicates the default agent provider being used (openai, anthropic, etc.).
		
		## 🧘 Action Packages
		- **action.packages.to.scan** : Specifies which Java package(s) to scan for agent actions. Only actions from these packages will be registered with the server.
		
		## 🔧 MCP / A2A Settings
		- **mcp.tools.servername**: Name of the MCP tools server, shown in UI or logs (e.g., "The Best Server For Customer Service").
		- **mcp.tools.version**: Version of the tools server (e.g., "1.0.0").
		- **a2a.card.name**: The display name for the A2A card, typically shown in UIs (e.g., "Tools4AI Based A2A Server").
		
		## 🧠 A2A Card Metadata Configuration
		These properties configure how an AI Agent card appears and behaves in your A2A/MCP system.
		
		| Property Key | Description |
		|-------------|-------------|
		| a2a.card.description | A human-readable description of the agent or tool. |
		| a2a.card.name | The display name of the agent card. |
		| a2a.card.capabilities.streaming | Enables or disables support for streaming responses (true / false). |
		| a2a.card.capabilities.pushNotifications | Enables push notifications capability (true / false). |
		| a2a.card.capabilities.stateTransitionHistory | Records the history of state transitions for the card (true / false). |
		| a2a.card.url | A URL pointing to the service, dashboard, or card landing page. |
		| a2a.card.version | The version of the card or tool. |
		| a2a.card.documentationUrl | URL to the agent/tool's official documentation. |
		| a2a.card.defaultOutputModes | Comma-separated list of default output formats (e.g., text,json). |
		| a2a.card.defaultInputModes | Comma-separated list of input formats supported by the agent. |
		| a2a.card.provider.organization | The organization providing the agent/tool. |
		| a2a.card.provider.url | URL to the provider's homepage or service endpoint. |
		| a2a.card.authentication.schemes | Comma-separated list of supported authentication schemes. |
		| a2a.card.authentication.credentials | Credentials (e.g., tokens or API keys) required to authenticate. |
		
		## ⚙️ MCP Tooling Server Settings
		These properties configure the MCP tools server metadata, usually for UI or service registration.
		
		| Property Key | Description |
		|-------------|-------------|
		| mcp.tools.servername | The display name of your MCP tools server. |
		| mcp.tools.version | Version of the MCP tools server. |
		| mcp.tools.protocolversion | The protocol version of the MCP/A2A communication being used. |</file>
	<file path='uploadnumber.sh'><![CDATA[
		#!/bin/bash
		
		# Assuming Maven generates XML test reports in the "target/surefire-reports" directory
		TEST_REPORT_DIR="target/surefire-reports"
		# Print current directory
		echo "Current directory: $(pwd)"
		
		xml_files=$(find "$(pwd)" -name "TEST-*.xml")
		
		# Concatenate all XML files and count the occurrences of "<testcase" using grep
		test_count=$(cat $xml_files | grep -c "<testcase")
		echo "Total number of tests: $test_count"
		
		
		
		
		echo "GIST_ID: $GIST_ID"
		
		
		json_data='{"schemaVersion": "1", "label": "testcount", "message": "'$test_count'", "color": "orange"}'
		
		echo "JSON data: $json_data"
		
		# Prevent any output from the script
		exec > /dev/null
		exec 2>&1
		
		# Create or update the Gist with the test count
		curl -s -X PATCH \
		     -H "Authorization: token $GIST_TOKEN" \
		     -H "Content-Type: application/vnd.github+json" \
		     -d '{"files":{"test.json":{"content": "{\"schemaVersion\": 1,\"label\": \"testcount\", \"message\": \"'$test_count'\", \"color\":\"orange\"}" }}}' \
		     "https://api.github.com/gists/$GIST_ID"]]></file>
</files>
